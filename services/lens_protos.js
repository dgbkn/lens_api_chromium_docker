/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.lens = (function() {

    /**
     * Namespace lens.
     * @exports lens
     * @namespace
     */
    var lens = {};

    lens.LensOverlayClientContext = (function() {

        /**
         * Properties of a LensOverlayClientContext.
         * @memberof lens
         * @interface ILensOverlayClientContext
         * @property {lens.Platform|null} [platform] LensOverlayClientContext platform
         * @property {lens.Surface|null} [surface] LensOverlayClientContext surface
         * @property {lens.ILocaleContext|null} [localeContext] LensOverlayClientContext localeContext
         * @property {string|null} [appId] LensOverlayClientContext appId
         * @property {lens.IAppliedFilters|null} [clientFilters] LensOverlayClientContext clientFilters
         * @property {lens.IRenderingContext|null} [renderingContext] LensOverlayClientContext renderingContext
         * @property {lens.IClientLoggingData|null} [clientLoggingData] LensOverlayClientContext clientLoggingData
         */

        /**
         * Constructs a new LensOverlayClientContext.
         * @memberof lens
         * @classdesc Represents a LensOverlayClientContext.
         * @implements ILensOverlayClientContext
         * @constructor
         * @param {lens.ILensOverlayClientContext=} [properties] Properties to set
         */
        function LensOverlayClientContext(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayClientContext platform.
         * @member {lens.Platform} platform
         * @memberof lens.LensOverlayClientContext
         * @instance
         */
        LensOverlayClientContext.prototype.platform = 0;

        /**
         * LensOverlayClientContext surface.
         * @member {lens.Surface} surface
         * @memberof lens.LensOverlayClientContext
         * @instance
         */
        LensOverlayClientContext.prototype.surface = 0;

        /**
         * LensOverlayClientContext localeContext.
         * @member {lens.ILocaleContext|null|undefined} localeContext
         * @memberof lens.LensOverlayClientContext
         * @instance
         */
        LensOverlayClientContext.prototype.localeContext = null;

        /**
         * LensOverlayClientContext appId.
         * @member {string} appId
         * @memberof lens.LensOverlayClientContext
         * @instance
         */
        LensOverlayClientContext.prototype.appId = "";

        /**
         * LensOverlayClientContext clientFilters.
         * @member {lens.IAppliedFilters|null|undefined} clientFilters
         * @memberof lens.LensOverlayClientContext
         * @instance
         */
        LensOverlayClientContext.prototype.clientFilters = null;

        /**
         * LensOverlayClientContext renderingContext.
         * @member {lens.IRenderingContext|null|undefined} renderingContext
         * @memberof lens.LensOverlayClientContext
         * @instance
         */
        LensOverlayClientContext.prototype.renderingContext = null;

        /**
         * LensOverlayClientContext clientLoggingData.
         * @member {lens.IClientLoggingData|null|undefined} clientLoggingData
         * @memberof lens.LensOverlayClientContext
         * @instance
         */
        LensOverlayClientContext.prototype.clientLoggingData = null;

        /**
         * Creates a new LensOverlayClientContext instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {lens.ILensOverlayClientContext=} [properties] Properties to set
         * @returns {lens.LensOverlayClientContext} LensOverlayClientContext instance
         */
        LensOverlayClientContext.create = function create(properties) {
            return new LensOverlayClientContext(properties);
        };

        /**
         * Encodes the specified LensOverlayClientContext message. Does not implicitly {@link lens.LensOverlayClientContext.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {lens.ILensOverlayClientContext} message LensOverlayClientContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayClientContext.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.platform != null && Object.hasOwnProperty.call(message, "platform"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.platform);
            if (message.surface != null && Object.hasOwnProperty.call(message, "surface"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.surface);
            if (message.localeContext != null && Object.hasOwnProperty.call(message, "localeContext"))
                $root.lens.LocaleContext.encode(message.localeContext, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.appId != null && Object.hasOwnProperty.call(message, "appId"))
                writer.uint32(/* id 6, wireType 2 =*/50).string(message.appId);
            if (message.clientFilters != null && Object.hasOwnProperty.call(message, "clientFilters"))
                $root.lens.AppliedFilters.encode(message.clientFilters, writer.uint32(/* id 17, wireType 2 =*/138).fork()).ldelim();
            if (message.renderingContext != null && Object.hasOwnProperty.call(message, "renderingContext"))
                $root.lens.RenderingContext.encode(message.renderingContext, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
            if (message.clientLoggingData != null && Object.hasOwnProperty.call(message, "clientLoggingData"))
                $root.lens.ClientLoggingData.encode(message.clientLoggingData, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayClientContext message, length delimited. Does not implicitly {@link lens.LensOverlayClientContext.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {lens.ILensOverlayClientContext} message LensOverlayClientContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayClientContext.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayClientContext message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayClientContext} LensOverlayClientContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayClientContext.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayClientContext();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.platform = reader.int32();
                        break;
                    }
                case 2: {
                        message.surface = reader.int32();
                        break;
                    }
                case 4: {
                        message.localeContext = $root.lens.LocaleContext.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.appId = reader.string();
                        break;
                    }
                case 17: {
                        message.clientFilters = $root.lens.AppliedFilters.decode(reader, reader.uint32());
                        break;
                    }
                case 20: {
                        message.renderingContext = $root.lens.RenderingContext.decode(reader, reader.uint32());
                        break;
                    }
                case 23: {
                        message.clientLoggingData = $root.lens.ClientLoggingData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayClientContext message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayClientContext} LensOverlayClientContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayClientContext.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayClientContext message.
         * @function verify
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayClientContext.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.platform != null && message.hasOwnProperty("platform"))
                switch (message.platform) {
                default:
                    return "platform: enum value expected";
                case 0:
                case 3:
                case 6:
                    break;
                }
            if (message.surface != null && message.hasOwnProperty("surface"))
                switch (message.surface) {
                default:
                    return "surface: enum value expected";
                case 0:
                case 4:
                case 42:
                    break;
                }
            if (message.localeContext != null && message.hasOwnProperty("localeContext")) {
                var error = $root.lens.LocaleContext.verify(message.localeContext);
                if (error)
                    return "localeContext." + error;
            }
            if (message.appId != null && message.hasOwnProperty("appId"))
                if (!$util.isString(message.appId))
                    return "appId: string expected";
            if (message.clientFilters != null && message.hasOwnProperty("clientFilters")) {
                var error = $root.lens.AppliedFilters.verify(message.clientFilters);
                if (error)
                    return "clientFilters." + error;
            }
            if (message.renderingContext != null && message.hasOwnProperty("renderingContext")) {
                var error = $root.lens.RenderingContext.verify(message.renderingContext);
                if (error)
                    return "renderingContext." + error;
            }
            if (message.clientLoggingData != null && message.hasOwnProperty("clientLoggingData")) {
                var error = $root.lens.ClientLoggingData.verify(message.clientLoggingData);
                if (error)
                    return "clientLoggingData." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayClientContext message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayClientContext} LensOverlayClientContext
         */
        LensOverlayClientContext.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayClientContext)
                return object;
            var message = new $root.lens.LensOverlayClientContext();
            switch (object.platform) {
            default:
                if (typeof object.platform === "number") {
                    message.platform = object.platform;
                    break;
                }
                break;
            case "PLATFORM_UNSPECIFIED":
            case 0:
                message.platform = 0;
                break;
            case "PLATFORM_WEB":
            case 3:
                message.platform = 3;
                break;
            case "PLATFORM_LENS_OVERLAY":
            case 6:
                message.platform = 6;
                break;
            }
            switch (object.surface) {
            default:
                if (typeof object.surface === "number") {
                    message.surface = object.surface;
                    break;
                }
                break;
            case "SURFACE_UNSPECIFIED":
            case 0:
                message.surface = 0;
                break;
            case "SURFACE_CHROMIUM":
            case 4:
                message.surface = 4;
                break;
            case "SURFACE_LENS_OVERLAY":
            case 42:
                message.surface = 42;
                break;
            }
            if (object.localeContext != null) {
                if (typeof object.localeContext !== "object")
                    throw TypeError(".lens.LensOverlayClientContext.localeContext: object expected");
                message.localeContext = $root.lens.LocaleContext.fromObject(object.localeContext);
            }
            if (object.appId != null)
                message.appId = String(object.appId);
            if (object.clientFilters != null) {
                if (typeof object.clientFilters !== "object")
                    throw TypeError(".lens.LensOverlayClientContext.clientFilters: object expected");
                message.clientFilters = $root.lens.AppliedFilters.fromObject(object.clientFilters);
            }
            if (object.renderingContext != null) {
                if (typeof object.renderingContext !== "object")
                    throw TypeError(".lens.LensOverlayClientContext.renderingContext: object expected");
                message.renderingContext = $root.lens.RenderingContext.fromObject(object.renderingContext);
            }
            if (object.clientLoggingData != null) {
                if (typeof object.clientLoggingData !== "object")
                    throw TypeError(".lens.LensOverlayClientContext.clientLoggingData: object expected");
                message.clientLoggingData = $root.lens.ClientLoggingData.fromObject(object.clientLoggingData);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayClientContext message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {lens.LensOverlayClientContext} message LensOverlayClientContext
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayClientContext.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.platform = options.enums === String ? "PLATFORM_UNSPECIFIED" : 0;
                object.surface = options.enums === String ? "SURFACE_UNSPECIFIED" : 0;
                object.localeContext = null;
                object.appId = "";
                object.clientFilters = null;
                object.renderingContext = null;
                object.clientLoggingData = null;
            }
            if (message.platform != null && message.hasOwnProperty("platform"))
                object.platform = options.enums === String ? $root.lens.Platform[message.platform] === undefined ? message.platform : $root.lens.Platform[message.platform] : message.platform;
            if (message.surface != null && message.hasOwnProperty("surface"))
                object.surface = options.enums === String ? $root.lens.Surface[message.surface] === undefined ? message.surface : $root.lens.Surface[message.surface] : message.surface;
            if (message.localeContext != null && message.hasOwnProperty("localeContext"))
                object.localeContext = $root.lens.LocaleContext.toObject(message.localeContext, options);
            if (message.appId != null && message.hasOwnProperty("appId"))
                object.appId = message.appId;
            if (message.clientFilters != null && message.hasOwnProperty("clientFilters"))
                object.clientFilters = $root.lens.AppliedFilters.toObject(message.clientFilters, options);
            if (message.renderingContext != null && message.hasOwnProperty("renderingContext"))
                object.renderingContext = $root.lens.RenderingContext.toObject(message.renderingContext, options);
            if (message.clientLoggingData != null && message.hasOwnProperty("clientLoggingData"))
                object.clientLoggingData = $root.lens.ClientLoggingData.toObject(message.clientLoggingData, options);
            return object;
        };

        /**
         * Converts this LensOverlayClientContext to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayClientContext
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayClientContext.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayClientContext
         * @function getTypeUrl
         * @memberof lens.LensOverlayClientContext
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayClientContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayClientContext";
        };

        return LensOverlayClientContext;
    })();

    lens.LocaleContext = (function() {

        /**
         * Properties of a LocaleContext.
         * @memberof lens
         * @interface ILocaleContext
         * @property {string|null} [language] LocaleContext language
         * @property {string|null} [region] LocaleContext region
         * @property {string|null} [timeZone] LocaleContext timeZone
         */

        /**
         * Constructs a new LocaleContext.
         * @memberof lens
         * @classdesc Represents a LocaleContext.
         * @implements ILocaleContext
         * @constructor
         * @param {lens.ILocaleContext=} [properties] Properties to set
         */
        function LocaleContext(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LocaleContext language.
         * @member {string} language
         * @memberof lens.LocaleContext
         * @instance
         */
        LocaleContext.prototype.language = "";

        /**
         * LocaleContext region.
         * @member {string} region
         * @memberof lens.LocaleContext
         * @instance
         */
        LocaleContext.prototype.region = "";

        /**
         * LocaleContext timeZone.
         * @member {string} timeZone
         * @memberof lens.LocaleContext
         * @instance
         */
        LocaleContext.prototype.timeZone = "";

        /**
         * Creates a new LocaleContext instance using the specified properties.
         * @function create
         * @memberof lens.LocaleContext
         * @static
         * @param {lens.ILocaleContext=} [properties] Properties to set
         * @returns {lens.LocaleContext} LocaleContext instance
         */
        LocaleContext.create = function create(properties) {
            return new LocaleContext(properties);
        };

        /**
         * Encodes the specified LocaleContext message. Does not implicitly {@link lens.LocaleContext.verify|verify} messages.
         * @function encode
         * @memberof lens.LocaleContext
         * @static
         * @param {lens.ILocaleContext} message LocaleContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocaleContext.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.language != null && Object.hasOwnProperty.call(message, "language"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.language);
            if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.region);
            if (message.timeZone != null && Object.hasOwnProperty.call(message, "timeZone"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.timeZone);
            return writer;
        };

        /**
         * Encodes the specified LocaleContext message, length delimited. Does not implicitly {@link lens.LocaleContext.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LocaleContext
         * @static
         * @param {lens.ILocaleContext} message LocaleContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LocaleContext.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LocaleContext message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LocaleContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LocaleContext} LocaleContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocaleContext.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LocaleContext();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.language = reader.string();
                        break;
                    }
                case 2: {
                        message.region = reader.string();
                        break;
                    }
                case 3: {
                        message.timeZone = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LocaleContext message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LocaleContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LocaleContext} LocaleContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LocaleContext.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LocaleContext message.
         * @function verify
         * @memberof lens.LocaleContext
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LocaleContext.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.language != null && message.hasOwnProperty("language"))
                if (!$util.isString(message.language))
                    return "language: string expected";
            if (message.region != null && message.hasOwnProperty("region"))
                if (!$util.isString(message.region))
                    return "region: string expected";
            if (message.timeZone != null && message.hasOwnProperty("timeZone"))
                if (!$util.isString(message.timeZone))
                    return "timeZone: string expected";
            return null;
        };

        /**
         * Creates a LocaleContext message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LocaleContext
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LocaleContext} LocaleContext
         */
        LocaleContext.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LocaleContext)
                return object;
            var message = new $root.lens.LocaleContext();
            if (object.language != null)
                message.language = String(object.language);
            if (object.region != null)
                message.region = String(object.region);
            if (object.timeZone != null)
                message.timeZone = String(object.timeZone);
            return message;
        };

        /**
         * Creates a plain object from a LocaleContext message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LocaleContext
         * @static
         * @param {lens.LocaleContext} message LocaleContext
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LocaleContext.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.language = "";
                object.region = "";
                object.timeZone = "";
            }
            if (message.language != null && message.hasOwnProperty("language"))
                object.language = message.language;
            if (message.region != null && message.hasOwnProperty("region"))
                object.region = message.region;
            if (message.timeZone != null && message.hasOwnProperty("timeZone"))
                object.timeZone = message.timeZone;
            return object;
        };

        /**
         * Converts this LocaleContext to JSON.
         * @function toJSON
         * @memberof lens.LocaleContext
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LocaleContext.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LocaleContext
         * @function getTypeUrl
         * @memberof lens.LocaleContext
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LocaleContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LocaleContext";
        };

        return LocaleContext;
    })();

    /**
     * LensRenderingEnvironment enum.
     * @name lens.LensRenderingEnvironment
     * @enum {number}
     * @property {number} RENDERING_ENV_UNSPECIFIED=0 RENDERING_ENV_UNSPECIFIED value
     * @property {number} RENDERING_ENV_LENS_OVERLAY=14 RENDERING_ENV_LENS_OVERLAY value
     */
    lens.LensRenderingEnvironment = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RENDERING_ENV_UNSPECIFIED"] = 0;
        values[valuesById[14] = "RENDERING_ENV_LENS_OVERLAY"] = 14;
        return values;
    })();

    lens.RenderingContext = (function() {

        /**
         * Properties of a RenderingContext.
         * @memberof lens
         * @interface IRenderingContext
         * @property {lens.LensRenderingEnvironment|null} [renderingEnvironment] RenderingContext renderingEnvironment
         */

        /**
         * Constructs a new RenderingContext.
         * @memberof lens
         * @classdesc Represents a RenderingContext.
         * @implements IRenderingContext
         * @constructor
         * @param {lens.IRenderingContext=} [properties] Properties to set
         */
        function RenderingContext(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RenderingContext renderingEnvironment.
         * @member {lens.LensRenderingEnvironment} renderingEnvironment
         * @memberof lens.RenderingContext
         * @instance
         */
        RenderingContext.prototype.renderingEnvironment = 0;

        /**
         * Creates a new RenderingContext instance using the specified properties.
         * @function create
         * @memberof lens.RenderingContext
         * @static
         * @param {lens.IRenderingContext=} [properties] Properties to set
         * @returns {lens.RenderingContext} RenderingContext instance
         */
        RenderingContext.create = function create(properties) {
            return new RenderingContext(properties);
        };

        /**
         * Encodes the specified RenderingContext message. Does not implicitly {@link lens.RenderingContext.verify|verify} messages.
         * @function encode
         * @memberof lens.RenderingContext
         * @static
         * @param {lens.IRenderingContext} message RenderingContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenderingContext.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.renderingEnvironment != null && Object.hasOwnProperty.call(message, "renderingEnvironment"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.renderingEnvironment);
            return writer;
        };

        /**
         * Encodes the specified RenderingContext message, length delimited. Does not implicitly {@link lens.RenderingContext.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.RenderingContext
         * @static
         * @param {lens.IRenderingContext} message RenderingContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        RenderingContext.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a RenderingContext message from the specified reader or buffer.
         * @function decode
         * @memberof lens.RenderingContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.RenderingContext} RenderingContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenderingContext.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.RenderingContext();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.renderingEnvironment = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a RenderingContext message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.RenderingContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.RenderingContext} RenderingContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        RenderingContext.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a RenderingContext message.
         * @function verify
         * @memberof lens.RenderingContext
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RenderingContext.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.renderingEnvironment != null && message.hasOwnProperty("renderingEnvironment"))
                switch (message.renderingEnvironment) {
                default:
                    return "renderingEnvironment: enum value expected";
                case 0:
                case 14:
                    break;
                }
            return null;
        };

        /**
         * Creates a RenderingContext message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.RenderingContext
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.RenderingContext} RenderingContext
         */
        RenderingContext.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.RenderingContext)
                return object;
            var message = new $root.lens.RenderingContext();
            switch (object.renderingEnvironment) {
            default:
                if (typeof object.renderingEnvironment === "number") {
                    message.renderingEnvironment = object.renderingEnvironment;
                    break;
                }
                break;
            case "RENDERING_ENV_UNSPECIFIED":
            case 0:
                message.renderingEnvironment = 0;
                break;
            case "RENDERING_ENV_LENS_OVERLAY":
            case 14:
                message.renderingEnvironment = 14;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a RenderingContext message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.RenderingContext
         * @static
         * @param {lens.RenderingContext} message RenderingContext
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RenderingContext.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.renderingEnvironment = options.enums === String ? "RENDERING_ENV_UNSPECIFIED" : 0;
            if (message.renderingEnvironment != null && message.hasOwnProperty("renderingEnvironment"))
                object.renderingEnvironment = options.enums === String ? $root.lens.LensRenderingEnvironment[message.renderingEnvironment] === undefined ? message.renderingEnvironment : $root.lens.LensRenderingEnvironment[message.renderingEnvironment] : message.renderingEnvironment;
            return object;
        };

        /**
         * Converts this RenderingContext to JSON.
         * @function toJSON
         * @memberof lens.RenderingContext
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RenderingContext.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for RenderingContext
         * @function getTypeUrl
         * @memberof lens.RenderingContext
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        RenderingContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.RenderingContext";
        };

        return RenderingContext;
    })();

    lens.ClientLoggingData = (function() {

        /**
         * Properties of a ClientLoggingData.
         * @memberof lens
         * @interface IClientLoggingData
         * @property {boolean|null} [isHistoryEligible] ClientLoggingData isHistoryEligible
         */

        /**
         * Constructs a new ClientLoggingData.
         * @memberof lens
         * @classdesc Represents a ClientLoggingData.
         * @implements IClientLoggingData
         * @constructor
         * @param {lens.IClientLoggingData=} [properties] Properties to set
         */
        function ClientLoggingData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientLoggingData isHistoryEligible.
         * @member {boolean} isHistoryEligible
         * @memberof lens.ClientLoggingData
         * @instance
         */
        ClientLoggingData.prototype.isHistoryEligible = false;

        /**
         * Creates a new ClientLoggingData instance using the specified properties.
         * @function create
         * @memberof lens.ClientLoggingData
         * @static
         * @param {lens.IClientLoggingData=} [properties] Properties to set
         * @returns {lens.ClientLoggingData} ClientLoggingData instance
         */
        ClientLoggingData.create = function create(properties) {
            return new ClientLoggingData(properties);
        };

        /**
         * Encodes the specified ClientLoggingData message. Does not implicitly {@link lens.ClientLoggingData.verify|verify} messages.
         * @function encode
         * @memberof lens.ClientLoggingData
         * @static
         * @param {lens.IClientLoggingData} message ClientLoggingData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLoggingData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.isHistoryEligible != null && Object.hasOwnProperty.call(message, "isHistoryEligible"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.isHistoryEligible);
            return writer;
        };

        /**
         * Encodes the specified ClientLoggingData message, length delimited. Does not implicitly {@link lens.ClientLoggingData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ClientLoggingData
         * @static
         * @param {lens.IClientLoggingData} message ClientLoggingData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientLoggingData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientLoggingData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ClientLoggingData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ClientLoggingData} ClientLoggingData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLoggingData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ClientLoggingData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.isHistoryEligible = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientLoggingData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ClientLoggingData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ClientLoggingData} ClientLoggingData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientLoggingData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientLoggingData message.
         * @function verify
         * @memberof lens.ClientLoggingData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientLoggingData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.isHistoryEligible != null && message.hasOwnProperty("isHistoryEligible"))
                if (typeof message.isHistoryEligible !== "boolean")
                    return "isHistoryEligible: boolean expected";
            return null;
        };

        /**
         * Creates a ClientLoggingData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ClientLoggingData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ClientLoggingData} ClientLoggingData
         */
        ClientLoggingData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ClientLoggingData)
                return object;
            var message = new $root.lens.ClientLoggingData();
            if (object.isHistoryEligible != null)
                message.isHistoryEligible = Boolean(object.isHistoryEligible);
            return message;
        };

        /**
         * Creates a plain object from a ClientLoggingData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ClientLoggingData
         * @static
         * @param {lens.ClientLoggingData} message ClientLoggingData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientLoggingData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.isHistoryEligible = false;
            if (message.isHistoryEligible != null && message.hasOwnProperty("isHistoryEligible"))
                object.isHistoryEligible = message.isHistoryEligible;
            return object;
        };

        /**
         * Converts this ClientLoggingData to JSON.
         * @function toJSON
         * @memberof lens.ClientLoggingData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientLoggingData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientLoggingData
         * @function getTypeUrl
         * @memberof lens.ClientLoggingData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientLoggingData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ClientLoggingData";
        };

        return ClientLoggingData;
    })();

    /**
     * LensOverlayFilterType enum.
     * @name lens.LensOverlayFilterType
     * @enum {number}
     * @property {number} UNKNOWN_FILTER_TYPE=0 UNKNOWN_FILTER_TYPE value
     * @property {number} TRANSLATE=2 TRANSLATE value
     * @property {number} AUTO_FILTER=7 AUTO_FILTER value
     */
    lens.LensOverlayFilterType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_FILTER_TYPE"] = 0;
        values[valuesById[2] = "TRANSLATE"] = 2;
        values[valuesById[7] = "AUTO_FILTER"] = 7;
        return values;
    })();

    lens.AppliedFilter = (function() {

        /**
         * Properties of an AppliedFilter.
         * @memberof lens
         * @interface IAppliedFilter
         * @property {lens.LensOverlayFilterType|null} [filterType] AppliedFilter filterType
         * @property {lens.AppliedFilter.ITranslate|null} [translate] AppliedFilter translate
         */

        /**
         * Constructs a new AppliedFilter.
         * @memberof lens
         * @classdesc Represents an AppliedFilter.
         * @implements IAppliedFilter
         * @constructor
         * @param {lens.IAppliedFilter=} [properties] Properties to set
         */
        function AppliedFilter(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AppliedFilter filterType.
         * @member {lens.LensOverlayFilterType} filterType
         * @memberof lens.AppliedFilter
         * @instance
         */
        AppliedFilter.prototype.filterType = 0;

        /**
         * AppliedFilter translate.
         * @member {lens.AppliedFilter.ITranslate|null|undefined} translate
         * @memberof lens.AppliedFilter
         * @instance
         */
        AppliedFilter.prototype.translate = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * AppliedFilter filterPayload.
         * @member {"translate"|undefined} filterPayload
         * @memberof lens.AppliedFilter
         * @instance
         */
        Object.defineProperty(AppliedFilter.prototype, "filterPayload", {
            get: $util.oneOfGetter($oneOfFields = ["translate"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new AppliedFilter instance using the specified properties.
         * @function create
         * @memberof lens.AppliedFilter
         * @static
         * @param {lens.IAppliedFilter=} [properties] Properties to set
         * @returns {lens.AppliedFilter} AppliedFilter instance
         */
        AppliedFilter.create = function create(properties) {
            return new AppliedFilter(properties);
        };

        /**
         * Encodes the specified AppliedFilter message. Does not implicitly {@link lens.AppliedFilter.verify|verify} messages.
         * @function encode
         * @memberof lens.AppliedFilter
         * @static
         * @param {lens.IAppliedFilter} message AppliedFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppliedFilter.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filterType != null && Object.hasOwnProperty.call(message, "filterType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.filterType);
            if (message.translate != null && Object.hasOwnProperty.call(message, "translate"))
                $root.lens.AppliedFilter.Translate.encode(message.translate, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AppliedFilter message, length delimited. Does not implicitly {@link lens.AppliedFilter.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.AppliedFilter
         * @static
         * @param {lens.IAppliedFilter} message AppliedFilter message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppliedFilter.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AppliedFilter message from the specified reader or buffer.
         * @function decode
         * @memberof lens.AppliedFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.AppliedFilter} AppliedFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppliedFilter.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.AppliedFilter();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.filterType = reader.int32();
                        break;
                    }
                case 3: {
                        message.translate = $root.lens.AppliedFilter.Translate.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AppliedFilter message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.AppliedFilter
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.AppliedFilter} AppliedFilter
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppliedFilter.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AppliedFilter message.
         * @function verify
         * @memberof lens.AppliedFilter
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppliedFilter.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.filterType != null && message.hasOwnProperty("filterType"))
                switch (message.filterType) {
                default:
                    return "filterType: enum value expected";
                case 0:
                case 2:
                case 7:
                    break;
                }
            if (message.translate != null && message.hasOwnProperty("translate")) {
                properties.filterPayload = 1;
                {
                    var error = $root.lens.AppliedFilter.Translate.verify(message.translate);
                    if (error)
                        return "translate." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AppliedFilter message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.AppliedFilter
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.AppliedFilter} AppliedFilter
         */
        AppliedFilter.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.AppliedFilter)
                return object;
            var message = new $root.lens.AppliedFilter();
            switch (object.filterType) {
            default:
                if (typeof object.filterType === "number") {
                    message.filterType = object.filterType;
                    break;
                }
                break;
            case "UNKNOWN_FILTER_TYPE":
            case 0:
                message.filterType = 0;
                break;
            case "TRANSLATE":
            case 2:
                message.filterType = 2;
                break;
            case "AUTO_FILTER":
            case 7:
                message.filterType = 7;
                break;
            }
            if (object.translate != null) {
                if (typeof object.translate !== "object")
                    throw TypeError(".lens.AppliedFilter.translate: object expected");
                message.translate = $root.lens.AppliedFilter.Translate.fromObject(object.translate);
            }
            return message;
        };

        /**
         * Creates a plain object from an AppliedFilter message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.AppliedFilter
         * @static
         * @param {lens.AppliedFilter} message AppliedFilter
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AppliedFilter.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.filterType = options.enums === String ? "UNKNOWN_FILTER_TYPE" : 0;
            if (message.filterType != null && message.hasOwnProperty("filterType"))
                object.filterType = options.enums === String ? $root.lens.LensOverlayFilterType[message.filterType] === undefined ? message.filterType : $root.lens.LensOverlayFilterType[message.filterType] : message.filterType;
            if (message.translate != null && message.hasOwnProperty("translate")) {
                object.translate = $root.lens.AppliedFilter.Translate.toObject(message.translate, options);
                if (options.oneofs)
                    object.filterPayload = "translate";
            }
            return object;
        };

        /**
         * Converts this AppliedFilter to JSON.
         * @function toJSON
         * @memberof lens.AppliedFilter
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AppliedFilter.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AppliedFilter
         * @function getTypeUrl
         * @memberof lens.AppliedFilter
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AppliedFilter.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.AppliedFilter";
        };

        AppliedFilter.Translate = (function() {

            /**
             * Properties of a Translate.
             * @memberof lens.AppliedFilter
             * @interface ITranslate
             * @property {string|null} [targetLanguage] Translate targetLanguage
             * @property {string|null} [sourceLanguage] Translate sourceLanguage
             */

            /**
             * Constructs a new Translate.
             * @memberof lens.AppliedFilter
             * @classdesc Represents a Translate.
             * @implements ITranslate
             * @constructor
             * @param {lens.AppliedFilter.ITranslate=} [properties] Properties to set
             */
            function Translate(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Translate targetLanguage.
             * @member {string} targetLanguage
             * @memberof lens.AppliedFilter.Translate
             * @instance
             */
            Translate.prototype.targetLanguage = "";

            /**
             * Translate sourceLanguage.
             * @member {string} sourceLanguage
             * @memberof lens.AppliedFilter.Translate
             * @instance
             */
            Translate.prototype.sourceLanguage = "";

            /**
             * Creates a new Translate instance using the specified properties.
             * @function create
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {lens.AppliedFilter.ITranslate=} [properties] Properties to set
             * @returns {lens.AppliedFilter.Translate} Translate instance
             */
            Translate.create = function create(properties) {
                return new Translate(properties);
            };

            /**
             * Encodes the specified Translate message. Does not implicitly {@link lens.AppliedFilter.Translate.verify|verify} messages.
             * @function encode
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {lens.AppliedFilter.ITranslate} message Translate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Translate.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.targetLanguage != null && Object.hasOwnProperty.call(message, "targetLanguage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.targetLanguage);
                if (message.sourceLanguage != null && Object.hasOwnProperty.call(message, "sourceLanguage"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceLanguage);
                return writer;
            };

            /**
             * Encodes the specified Translate message, length delimited. Does not implicitly {@link lens.AppliedFilter.Translate.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {lens.AppliedFilter.ITranslate} message Translate message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Translate.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Translate message from the specified reader or buffer.
             * @function decode
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.AppliedFilter.Translate} Translate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Translate.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.AppliedFilter.Translate();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.targetLanguage = reader.string();
                            break;
                        }
                    case 2: {
                            message.sourceLanguage = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Translate message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.AppliedFilter.Translate} Translate
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Translate.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Translate message.
             * @function verify
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Translate.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.targetLanguage != null && message.hasOwnProperty("targetLanguage"))
                    if (!$util.isString(message.targetLanguage))
                        return "targetLanguage: string expected";
                if (message.sourceLanguage != null && message.hasOwnProperty("sourceLanguage"))
                    if (!$util.isString(message.sourceLanguage))
                        return "sourceLanguage: string expected";
                return null;
            };

            /**
             * Creates a Translate message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.AppliedFilter.Translate} Translate
             */
            Translate.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.AppliedFilter.Translate)
                    return object;
                var message = new $root.lens.AppliedFilter.Translate();
                if (object.targetLanguage != null)
                    message.targetLanguage = String(object.targetLanguage);
                if (object.sourceLanguage != null)
                    message.sourceLanguage = String(object.sourceLanguage);
                return message;
            };

            /**
             * Creates a plain object from a Translate message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {lens.AppliedFilter.Translate} message Translate
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Translate.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.targetLanguage = "";
                    object.sourceLanguage = "";
                }
                if (message.targetLanguage != null && message.hasOwnProperty("targetLanguage"))
                    object.targetLanguage = message.targetLanguage;
                if (message.sourceLanguage != null && message.hasOwnProperty("sourceLanguage"))
                    object.sourceLanguage = message.sourceLanguage;
                return object;
            };

            /**
             * Converts this Translate to JSON.
             * @function toJSON
             * @memberof lens.AppliedFilter.Translate
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Translate.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Translate
             * @function getTypeUrl
             * @memberof lens.AppliedFilter.Translate
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Translate.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.AppliedFilter.Translate";
            };

            return Translate;
        })();

        return AppliedFilter;
    })();

    lens.AppliedFilters = (function() {

        /**
         * Properties of an AppliedFilters.
         * @memberof lens
         * @interface IAppliedFilters
         * @property {Array.<lens.IAppliedFilter>|null} [filter] AppliedFilters filter
         */

        /**
         * Constructs a new AppliedFilters.
         * @memberof lens
         * @classdesc Represents an AppliedFilters.
         * @implements IAppliedFilters
         * @constructor
         * @param {lens.IAppliedFilters=} [properties] Properties to set
         */
        function AppliedFilters(properties) {
            this.filter = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AppliedFilters filter.
         * @member {Array.<lens.IAppliedFilter>} filter
         * @memberof lens.AppliedFilters
         * @instance
         */
        AppliedFilters.prototype.filter = $util.emptyArray;

        /**
         * Creates a new AppliedFilters instance using the specified properties.
         * @function create
         * @memberof lens.AppliedFilters
         * @static
         * @param {lens.IAppliedFilters=} [properties] Properties to set
         * @returns {lens.AppliedFilters} AppliedFilters instance
         */
        AppliedFilters.create = function create(properties) {
            return new AppliedFilters(properties);
        };

        /**
         * Encodes the specified AppliedFilters message. Does not implicitly {@link lens.AppliedFilters.verify|verify} messages.
         * @function encode
         * @memberof lens.AppliedFilters
         * @static
         * @param {lens.IAppliedFilters} message AppliedFilters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppliedFilters.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filter != null && message.filter.length)
                for (var i = 0; i < message.filter.length; ++i)
                    $root.lens.AppliedFilter.encode(message.filter[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified AppliedFilters message, length delimited. Does not implicitly {@link lens.AppliedFilters.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.AppliedFilters
         * @static
         * @param {lens.IAppliedFilters} message AppliedFilters message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        AppliedFilters.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an AppliedFilters message from the specified reader or buffer.
         * @function decode
         * @memberof lens.AppliedFilters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.AppliedFilters} AppliedFilters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppliedFilters.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.AppliedFilters();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.filter && message.filter.length))
                            message.filter = [];
                        message.filter.push($root.lens.AppliedFilter.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an AppliedFilters message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.AppliedFilters
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.AppliedFilters} AppliedFilters
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        AppliedFilters.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an AppliedFilters message.
         * @function verify
         * @memberof lens.AppliedFilters
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AppliedFilters.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filter != null && message.hasOwnProperty("filter")) {
                if (!Array.isArray(message.filter))
                    return "filter: array expected";
                for (var i = 0; i < message.filter.length; ++i) {
                    var error = $root.lens.AppliedFilter.verify(message.filter[i]);
                    if (error)
                        return "filter." + error;
                }
            }
            return null;
        };

        /**
         * Creates an AppliedFilters message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.AppliedFilters
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.AppliedFilters} AppliedFilters
         */
        AppliedFilters.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.AppliedFilters)
                return object;
            var message = new $root.lens.AppliedFilters();
            if (object.filter) {
                if (!Array.isArray(object.filter))
                    throw TypeError(".lens.AppliedFilters.filter: array expected");
                message.filter = [];
                for (var i = 0; i < object.filter.length; ++i) {
                    if (typeof object.filter[i] !== "object")
                        throw TypeError(".lens.AppliedFilters.filter: object expected");
                    message.filter[i] = $root.lens.AppliedFilter.fromObject(object.filter[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an AppliedFilters message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.AppliedFilters
         * @static
         * @param {lens.AppliedFilters} message AppliedFilters
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AppliedFilters.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.filter = [];
            if (message.filter && message.filter.length) {
                object.filter = [];
                for (var j = 0; j < message.filter.length; ++j)
                    object.filter[j] = $root.lens.AppliedFilter.toObject(message.filter[j], options);
            }
            return object;
        };

        /**
         * Converts this AppliedFilters to JSON.
         * @function toJSON
         * @memberof lens.AppliedFilters
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AppliedFilters.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for AppliedFilters
         * @function getTypeUrl
         * @memberof lens.AppliedFilters
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        AppliedFilters.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.AppliedFilters";
        };

        return AppliedFilters;
    })();

    /**
     * Platform enum.
     * @name lens.Platform
     * @enum {number}
     * @property {number} PLATFORM_UNSPECIFIED=0 PLATFORM_UNSPECIFIED value
     * @property {number} PLATFORM_WEB=3 PLATFORM_WEB value
     * @property {number} PLATFORM_LENS_OVERLAY=6 PLATFORM_LENS_OVERLAY value
     */
    lens.Platform = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PLATFORM_UNSPECIFIED"] = 0;
        values[valuesById[3] = "PLATFORM_WEB"] = 3;
        values[valuesById[6] = "PLATFORM_LENS_OVERLAY"] = 6;
        return values;
    })();

    /**
     * Surface enum.
     * @name lens.Surface
     * @enum {number}
     * @property {number} SURFACE_UNSPECIFIED=0 SURFACE_UNSPECIFIED value
     * @property {number} SURFACE_CHROMIUM=4 SURFACE_CHROMIUM value
     * @property {number} SURFACE_LENS_OVERLAY=42 SURFACE_LENS_OVERLAY value
     */
    lens.Surface = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "SURFACE_UNSPECIFIED"] = 0;
        values[valuesById[4] = "SURFACE_CHROMIUM"] = 4;
        values[valuesById[42] = "SURFACE_LENS_OVERLAY"] = 42;
        return values;
    })();

    lens.LensOverlayClientLogs = (function() {

        /**
         * Properties of a LensOverlayClientLogs.
         * @memberof lens
         * @interface ILensOverlayClientLogs
         * @property {lens.ILensOverlayPhaseLatenciesMetadata|null} [phaseLatenciesMetadata] LensOverlayClientLogs phaseLatenciesMetadata
         * @property {lens.LensOverlayClientLogs.LensOverlayEntryPoint|null} [lensOverlayEntryPoint] LensOverlayClientLogs lensOverlayEntryPoint
         * @property {number|Long|null} [paellaId] LensOverlayClientLogs paellaId
         * @property {boolean|null} [metricsCollectionDisabled] LensOverlayClientLogs metricsCollectionDisabled
         */

        /**
         * Constructs a new LensOverlayClientLogs.
         * @memberof lens
         * @classdesc Represents a LensOverlayClientLogs.
         * @implements ILensOverlayClientLogs
         * @constructor
         * @param {lens.ILensOverlayClientLogs=} [properties] Properties to set
         */
        function LensOverlayClientLogs(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayClientLogs phaseLatenciesMetadata.
         * @member {lens.ILensOverlayPhaseLatenciesMetadata|null|undefined} phaseLatenciesMetadata
         * @memberof lens.LensOverlayClientLogs
         * @instance
         */
        LensOverlayClientLogs.prototype.phaseLatenciesMetadata = null;

        /**
         * LensOverlayClientLogs lensOverlayEntryPoint.
         * @member {lens.LensOverlayClientLogs.LensOverlayEntryPoint} lensOverlayEntryPoint
         * @memberof lens.LensOverlayClientLogs
         * @instance
         */
        LensOverlayClientLogs.prototype.lensOverlayEntryPoint = 0;

        /**
         * LensOverlayClientLogs paellaId.
         * @member {number|Long} paellaId
         * @memberof lens.LensOverlayClientLogs
         * @instance
         */
        LensOverlayClientLogs.prototype.paellaId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LensOverlayClientLogs metricsCollectionDisabled.
         * @member {boolean} metricsCollectionDisabled
         * @memberof lens.LensOverlayClientLogs
         * @instance
         */
        LensOverlayClientLogs.prototype.metricsCollectionDisabled = false;

        /**
         * Creates a new LensOverlayClientLogs instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {lens.ILensOverlayClientLogs=} [properties] Properties to set
         * @returns {lens.LensOverlayClientLogs} LensOverlayClientLogs instance
         */
        LensOverlayClientLogs.create = function create(properties) {
            return new LensOverlayClientLogs(properties);
        };

        /**
         * Encodes the specified LensOverlayClientLogs message. Does not implicitly {@link lens.LensOverlayClientLogs.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {lens.ILensOverlayClientLogs} message LensOverlayClientLogs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayClientLogs.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phaseLatenciesMetadata != null && Object.hasOwnProperty.call(message, "phaseLatenciesMetadata"))
                $root.lens.LensOverlayPhaseLatenciesMetadata.encode(message.phaseLatenciesMetadata, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.lensOverlayEntryPoint != null && Object.hasOwnProperty.call(message, "lensOverlayEntryPoint"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.lensOverlayEntryPoint);
            if (message.paellaId != null && Object.hasOwnProperty.call(message, "paellaId"))
                writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.paellaId);
            if (message.metricsCollectionDisabled != null && Object.hasOwnProperty.call(message, "metricsCollectionDisabled"))
                writer.uint32(/* id 5, wireType 0 =*/40).bool(message.metricsCollectionDisabled);
            return writer;
        };

        /**
         * Encodes the specified LensOverlayClientLogs message, length delimited. Does not implicitly {@link lens.LensOverlayClientLogs.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {lens.ILensOverlayClientLogs} message LensOverlayClientLogs message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayClientLogs.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayClientLogs message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayClientLogs} LensOverlayClientLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayClientLogs.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayClientLogs();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.phaseLatenciesMetadata = $root.lens.LensOverlayPhaseLatenciesMetadata.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.lensOverlayEntryPoint = reader.int32();
                        break;
                    }
                case 3: {
                        message.paellaId = reader.uint64();
                        break;
                    }
                case 5: {
                        message.metricsCollectionDisabled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayClientLogs message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayClientLogs} LensOverlayClientLogs
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayClientLogs.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayClientLogs message.
         * @function verify
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayClientLogs.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phaseLatenciesMetadata != null && message.hasOwnProperty("phaseLatenciesMetadata")) {
                var error = $root.lens.LensOverlayPhaseLatenciesMetadata.verify(message.phaseLatenciesMetadata);
                if (error)
                    return "phaseLatenciesMetadata." + error;
            }
            if (message.lensOverlayEntryPoint != null && message.hasOwnProperty("lensOverlayEntryPoint"))
                switch (message.lensOverlayEntryPoint) {
                default:
                    return "lensOverlayEntryPoint: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                    break;
                }
            if (message.paellaId != null && message.hasOwnProperty("paellaId"))
                if (!$util.isInteger(message.paellaId) && !(message.paellaId && $util.isInteger(message.paellaId.low) && $util.isInteger(message.paellaId.high)))
                    return "paellaId: integer|Long expected";
            if (message.metricsCollectionDisabled != null && message.hasOwnProperty("metricsCollectionDisabled"))
                if (typeof message.metricsCollectionDisabled !== "boolean")
                    return "metricsCollectionDisabled: boolean expected";
            return null;
        };

        /**
         * Creates a LensOverlayClientLogs message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayClientLogs} LensOverlayClientLogs
         */
        LensOverlayClientLogs.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayClientLogs)
                return object;
            var message = new $root.lens.LensOverlayClientLogs();
            if (object.phaseLatenciesMetadata != null) {
                if (typeof object.phaseLatenciesMetadata !== "object")
                    throw TypeError(".lens.LensOverlayClientLogs.phaseLatenciesMetadata: object expected");
                message.phaseLatenciesMetadata = $root.lens.LensOverlayPhaseLatenciesMetadata.fromObject(object.phaseLatenciesMetadata);
            }
            switch (object.lensOverlayEntryPoint) {
            default:
                if (typeof object.lensOverlayEntryPoint === "number") {
                    message.lensOverlayEntryPoint = object.lensOverlayEntryPoint;
                    break;
                }
                break;
            case "UNKNOWN_ENTRY_POINT":
            case 0:
                message.lensOverlayEntryPoint = 0;
                break;
            case "APP_MENU":
            case 1:
                message.lensOverlayEntryPoint = 1;
                break;
            case "PAGE_CONTEXT_MENU":
            case 2:
                message.lensOverlayEntryPoint = 2;
                break;
            case "IMAGE_CONTEXT_MENU":
            case 3:
                message.lensOverlayEntryPoint = 3;
                break;
            case "OMNIBOX_BUTTON":
            case 4:
                message.lensOverlayEntryPoint = 4;
                break;
            case "TOOLBAR_BUTTON":
            case 5:
                message.lensOverlayEntryPoint = 5;
                break;
            case "FIND_IN_PAGE":
            case 6:
                message.lensOverlayEntryPoint = 6;
                break;
            }
            if (object.paellaId != null)
                if ($util.Long)
                    (message.paellaId = $util.Long.fromValue(object.paellaId)).unsigned = true;
                else if (typeof object.paellaId === "string")
                    message.paellaId = parseInt(object.paellaId, 10);
                else if (typeof object.paellaId === "number")
                    message.paellaId = object.paellaId;
                else if (typeof object.paellaId === "object")
                    message.paellaId = new $util.LongBits(object.paellaId.low >>> 0, object.paellaId.high >>> 0).toNumber(true);
            if (object.metricsCollectionDisabled != null)
                message.metricsCollectionDisabled = Boolean(object.metricsCollectionDisabled);
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayClientLogs message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {lens.LensOverlayClientLogs} message LensOverlayClientLogs
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayClientLogs.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.phaseLatenciesMetadata = null;
                object.lensOverlayEntryPoint = options.enums === String ? "UNKNOWN_ENTRY_POINT" : 0;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.paellaId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.paellaId = options.longs === String ? "0" : 0;
                object.metricsCollectionDisabled = false;
            }
            if (message.phaseLatenciesMetadata != null && message.hasOwnProperty("phaseLatenciesMetadata"))
                object.phaseLatenciesMetadata = $root.lens.LensOverlayPhaseLatenciesMetadata.toObject(message.phaseLatenciesMetadata, options);
            if (message.lensOverlayEntryPoint != null && message.hasOwnProperty("lensOverlayEntryPoint"))
                object.lensOverlayEntryPoint = options.enums === String ? $root.lens.LensOverlayClientLogs.LensOverlayEntryPoint[message.lensOverlayEntryPoint] === undefined ? message.lensOverlayEntryPoint : $root.lens.LensOverlayClientLogs.LensOverlayEntryPoint[message.lensOverlayEntryPoint] : message.lensOverlayEntryPoint;
            if (message.paellaId != null && message.hasOwnProperty("paellaId"))
                if (typeof message.paellaId === "number")
                    object.paellaId = options.longs === String ? String(message.paellaId) : message.paellaId;
                else
                    object.paellaId = options.longs === String ? $util.Long.prototype.toString.call(message.paellaId) : options.longs === Number ? new $util.LongBits(message.paellaId.low >>> 0, message.paellaId.high >>> 0).toNumber(true) : message.paellaId;
            if (message.metricsCollectionDisabled != null && message.hasOwnProperty("metricsCollectionDisabled"))
                object.metricsCollectionDisabled = message.metricsCollectionDisabled;
            return object;
        };

        /**
         * Converts this LensOverlayClientLogs to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayClientLogs
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayClientLogs.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayClientLogs
         * @function getTypeUrl
         * @memberof lens.LensOverlayClientLogs
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayClientLogs.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayClientLogs";
        };

        /**
         * LensOverlayEntryPoint enum.
         * @name lens.LensOverlayClientLogs.LensOverlayEntryPoint
         * @enum {number}
         * @property {number} UNKNOWN_ENTRY_POINT=0 UNKNOWN_ENTRY_POINT value
         * @property {number} APP_MENU=1 APP_MENU value
         * @property {number} PAGE_CONTEXT_MENU=2 PAGE_CONTEXT_MENU value
         * @property {number} IMAGE_CONTEXT_MENU=3 IMAGE_CONTEXT_MENU value
         * @property {number} OMNIBOX_BUTTON=4 OMNIBOX_BUTTON value
         * @property {number} TOOLBAR_BUTTON=5 TOOLBAR_BUTTON value
         * @property {number} FIND_IN_PAGE=6 FIND_IN_PAGE value
         */
        LensOverlayClientLogs.LensOverlayEntryPoint = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_ENTRY_POINT"] = 0;
            values[valuesById[1] = "APP_MENU"] = 1;
            values[valuesById[2] = "PAGE_CONTEXT_MENU"] = 2;
            values[valuesById[3] = "IMAGE_CONTEXT_MENU"] = 3;
            values[valuesById[4] = "OMNIBOX_BUTTON"] = 4;
            values[valuesById[5] = "TOOLBAR_BUTTON"] = 5;
            values[valuesById[6] = "FIND_IN_PAGE"] = 6;
            return values;
        })();

        return LensOverlayClientLogs;
    })();

    lens.LensOverlayPhaseLatenciesMetadata = (function() {

        /**
         * Properties of a LensOverlayPhaseLatenciesMetadata.
         * @memberof lens
         * @interface ILensOverlayPhaseLatenciesMetadata
         * @property {Array.<lens.LensOverlayPhaseLatenciesMetadata.IPhase>|null} [phase] LensOverlayPhaseLatenciesMetadata phase
         */

        /**
         * Constructs a new LensOverlayPhaseLatenciesMetadata.
         * @memberof lens
         * @classdesc Represents a LensOverlayPhaseLatenciesMetadata.
         * @implements ILensOverlayPhaseLatenciesMetadata
         * @constructor
         * @param {lens.ILensOverlayPhaseLatenciesMetadata=} [properties] Properties to set
         */
        function LensOverlayPhaseLatenciesMetadata(properties) {
            this.phase = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayPhaseLatenciesMetadata phase.
         * @member {Array.<lens.LensOverlayPhaseLatenciesMetadata.IPhase>} phase
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @instance
         */
        LensOverlayPhaseLatenciesMetadata.prototype.phase = $util.emptyArray;

        /**
         * Creates a new LensOverlayPhaseLatenciesMetadata instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {lens.ILensOverlayPhaseLatenciesMetadata=} [properties] Properties to set
         * @returns {lens.LensOverlayPhaseLatenciesMetadata} LensOverlayPhaseLatenciesMetadata instance
         */
        LensOverlayPhaseLatenciesMetadata.create = function create(properties) {
            return new LensOverlayPhaseLatenciesMetadata(properties);
        };

        /**
         * Encodes the specified LensOverlayPhaseLatenciesMetadata message. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {lens.ILensOverlayPhaseLatenciesMetadata} message LensOverlayPhaseLatenciesMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayPhaseLatenciesMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.phase != null && message.phase.length)
                for (var i = 0; i < message.phase.length; ++i)
                    $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.encode(message.phase[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayPhaseLatenciesMetadata message, length delimited. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {lens.ILensOverlayPhaseLatenciesMetadata} message LensOverlayPhaseLatenciesMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayPhaseLatenciesMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayPhaseLatenciesMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayPhaseLatenciesMetadata} LensOverlayPhaseLatenciesMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayPhaseLatenciesMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayPhaseLatenciesMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.phase && message.phase.length))
                            message.phase = [];
                        message.phase.push($root.lens.LensOverlayPhaseLatenciesMetadata.Phase.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayPhaseLatenciesMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayPhaseLatenciesMetadata} LensOverlayPhaseLatenciesMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayPhaseLatenciesMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayPhaseLatenciesMetadata message.
         * @function verify
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayPhaseLatenciesMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.phase != null && message.hasOwnProperty("phase")) {
                if (!Array.isArray(message.phase))
                    return "phase: array expected";
                for (var i = 0; i < message.phase.length; ++i) {
                    var error = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.verify(message.phase[i]);
                    if (error)
                        return "phase." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LensOverlayPhaseLatenciesMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayPhaseLatenciesMetadata} LensOverlayPhaseLatenciesMetadata
         */
        LensOverlayPhaseLatenciesMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayPhaseLatenciesMetadata)
                return object;
            var message = new $root.lens.LensOverlayPhaseLatenciesMetadata();
            if (object.phase) {
                if (!Array.isArray(object.phase))
                    throw TypeError(".lens.LensOverlayPhaseLatenciesMetadata.phase: array expected");
                message.phase = [];
                for (var i = 0; i < object.phase.length; ++i) {
                    if (typeof object.phase[i] !== "object")
                        throw TypeError(".lens.LensOverlayPhaseLatenciesMetadata.phase: object expected");
                    message.phase[i] = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.fromObject(object.phase[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayPhaseLatenciesMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {lens.LensOverlayPhaseLatenciesMetadata} message LensOverlayPhaseLatenciesMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayPhaseLatenciesMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.phase = [];
            if (message.phase && message.phase.length) {
                object.phase = [];
                for (var j = 0; j < message.phase.length; ++j)
                    object.phase[j] = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.toObject(message.phase[j], options);
            }
            return object;
        };

        /**
         * Converts this LensOverlayPhaseLatenciesMetadata to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayPhaseLatenciesMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayPhaseLatenciesMetadata
         * @function getTypeUrl
         * @memberof lens.LensOverlayPhaseLatenciesMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayPhaseLatenciesMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayPhaseLatenciesMetadata";
        };

        /**
         * ImageType enum.
         * @name lens.LensOverlayPhaseLatenciesMetadata.ImageType
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} JPEG=1 JPEG value
         * @property {number} PNG=2 PNG value
         * @property {number} WEBP=3 WEBP value
         */
        LensOverlayPhaseLatenciesMetadata.ImageType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "JPEG"] = 1;
            values[valuesById[2] = "PNG"] = 2;
            values[valuesById[3] = "WEBP"] = 3;
            return values;
        })();

        LensOverlayPhaseLatenciesMetadata.Phase = (function() {

            /**
             * Properties of a Phase.
             * @memberof lens.LensOverlayPhaseLatenciesMetadata
             * @interface IPhase
             * @property {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageDownscaleData|null} [imageDownscaleData] Phase imageDownscaleData
             * @property {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageEncodeData|null} [imageEncodeData] Phase imageEncodeData
             */

            /**
             * Constructs a new Phase.
             * @memberof lens.LensOverlayPhaseLatenciesMetadata
             * @classdesc Represents a Phase.
             * @implements IPhase
             * @constructor
             * @param {lens.LensOverlayPhaseLatenciesMetadata.IPhase=} [properties] Properties to set
             */
            function Phase(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Phase imageDownscaleData.
             * @member {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageDownscaleData|null|undefined} imageDownscaleData
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @instance
             */
            Phase.prototype.imageDownscaleData = null;

            /**
             * Phase imageEncodeData.
             * @member {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageEncodeData|null|undefined} imageEncodeData
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @instance
             */
            Phase.prototype.imageEncodeData = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Phase phaseData.
             * @member {"imageDownscaleData"|"imageEncodeData"|undefined} phaseData
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @instance
             */
            Object.defineProperty(Phase.prototype, "phaseData", {
                get: $util.oneOfGetter($oneOfFields = ["imageDownscaleData", "imageEncodeData"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Phase instance using the specified properties.
             * @function create
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {lens.LensOverlayPhaseLatenciesMetadata.IPhase=} [properties] Properties to set
             * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase} Phase instance
             */
            Phase.create = function create(properties) {
                return new Phase(properties);
            };

            /**
             * Encodes the specified Phase message. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.Phase.verify|verify} messages.
             * @function encode
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {lens.LensOverlayPhaseLatenciesMetadata.IPhase} message Phase message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Phase.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.imageDownscaleData != null && Object.hasOwnProperty.call(message, "imageDownscaleData"))
                    $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData.encode(message.imageDownscaleData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.imageEncodeData != null && Object.hasOwnProperty.call(message, "imageEncodeData"))
                    $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData.encode(message.imageEncodeData, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Phase message, length delimited. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.Phase.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {lens.LensOverlayPhaseLatenciesMetadata.IPhase} message Phase message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Phase.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Phase message from the specified reader or buffer.
             * @function decode
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase} Phase
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Phase.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayPhaseLatenciesMetadata.Phase();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 3: {
                            message.imageDownscaleData = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.imageEncodeData = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Phase message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase} Phase
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Phase.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Phase message.
             * @function verify
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Phase.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.imageDownscaleData != null && message.hasOwnProperty("imageDownscaleData")) {
                    properties.phaseData = 1;
                    {
                        var error = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData.verify(message.imageDownscaleData);
                        if (error)
                            return "imageDownscaleData." + error;
                    }
                }
                if (message.imageEncodeData != null && message.hasOwnProperty("imageEncodeData")) {
                    if (properties.phaseData === 1)
                        return "phaseData: multiple values";
                    properties.phaseData = 1;
                    {
                        var error = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData.verify(message.imageEncodeData);
                        if (error)
                            return "imageEncodeData." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Phase message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase} Phase
             */
            Phase.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.LensOverlayPhaseLatenciesMetadata.Phase)
                    return object;
                var message = new $root.lens.LensOverlayPhaseLatenciesMetadata.Phase();
                if (object.imageDownscaleData != null) {
                    if (typeof object.imageDownscaleData !== "object")
                        throw TypeError(".lens.LensOverlayPhaseLatenciesMetadata.Phase.imageDownscaleData: object expected");
                    message.imageDownscaleData = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData.fromObject(object.imageDownscaleData);
                }
                if (object.imageEncodeData != null) {
                    if (typeof object.imageEncodeData !== "object")
                        throw TypeError(".lens.LensOverlayPhaseLatenciesMetadata.Phase.imageEncodeData: object expected");
                    message.imageEncodeData = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData.fromObject(object.imageEncodeData);
                }
                return message;
            };

            /**
             * Creates a plain object from a Phase message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase} message Phase
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Phase.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.imageDownscaleData != null && message.hasOwnProperty("imageDownscaleData")) {
                    object.imageDownscaleData = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData.toObject(message.imageDownscaleData, options);
                    if (options.oneofs)
                        object.phaseData = "imageDownscaleData";
                }
                if (message.imageEncodeData != null && message.hasOwnProperty("imageEncodeData")) {
                    object.imageEncodeData = $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData.toObject(message.imageEncodeData, options);
                    if (options.oneofs)
                        object.phaseData = "imageEncodeData";
                }
                return object;
            };

            /**
             * Converts this Phase to JSON.
             * @function toJSON
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Phase.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Phase
             * @function getTypeUrl
             * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Phase.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.LensOverlayPhaseLatenciesMetadata.Phase";
            };

            Phase.ImageDownscaleData = (function() {

                /**
                 * Properties of an ImageDownscaleData.
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
                 * @interface IImageDownscaleData
                 * @property {number|Long|null} [originalImageSize] ImageDownscaleData originalImageSize
                 * @property {number|Long|null} [downscaledImageSize] ImageDownscaleData downscaledImageSize
                 */

                /**
                 * Constructs a new ImageDownscaleData.
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
                 * @classdesc Represents an ImageDownscaleData.
                 * @implements IImageDownscaleData
                 * @constructor
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageDownscaleData=} [properties] Properties to set
                 */
                function ImageDownscaleData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ImageDownscaleData originalImageSize.
                 * @member {number|Long} originalImageSize
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @instance
                 */
                ImageDownscaleData.prototype.originalImageSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * ImageDownscaleData downscaledImageSize.
                 * @member {number|Long} downscaledImageSize
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @instance
                 */
                ImageDownscaleData.prototype.downscaledImageSize = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ImageDownscaleData instance using the specified properties.
                 * @function create
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageDownscaleData=} [properties] Properties to set
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData} ImageDownscaleData instance
                 */
                ImageDownscaleData.create = function create(properties) {
                    return new ImageDownscaleData(properties);
                };

                /**
                 * Encodes the specified ImageDownscaleData message. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData.verify|verify} messages.
                 * @function encode
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageDownscaleData} message ImageDownscaleData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageDownscaleData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.originalImageSize != null && Object.hasOwnProperty.call(message, "originalImageSize"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int64(message.originalImageSize);
                    if (message.downscaledImageSize != null && Object.hasOwnProperty.call(message, "downscaledImageSize"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.downscaledImageSize);
                    return writer;
                };

                /**
                 * Encodes the specified ImageDownscaleData message, length delimited. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageDownscaleData} message ImageDownscaleData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageDownscaleData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ImageDownscaleData message from the specified reader or buffer.
                 * @function decode
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData} ImageDownscaleData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageDownscaleData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.originalImageSize = reader.int64();
                                break;
                            }
                        case 2: {
                                message.downscaledImageSize = reader.int64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ImageDownscaleData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData} ImageDownscaleData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageDownscaleData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ImageDownscaleData message.
                 * @function verify
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ImageDownscaleData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.originalImageSize != null && message.hasOwnProperty("originalImageSize"))
                        if (!$util.isInteger(message.originalImageSize) && !(message.originalImageSize && $util.isInteger(message.originalImageSize.low) && $util.isInteger(message.originalImageSize.high)))
                            return "originalImageSize: integer|Long expected";
                    if (message.downscaledImageSize != null && message.hasOwnProperty("downscaledImageSize"))
                        if (!$util.isInteger(message.downscaledImageSize) && !(message.downscaledImageSize && $util.isInteger(message.downscaledImageSize.low) && $util.isInteger(message.downscaledImageSize.high)))
                            return "downscaledImageSize: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an ImageDownscaleData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData} ImageDownscaleData
                 */
                ImageDownscaleData.fromObject = function fromObject(object) {
                    if (object instanceof $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData)
                        return object;
                    var message = new $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData();
                    if (object.originalImageSize != null)
                        if ($util.Long)
                            (message.originalImageSize = $util.Long.fromValue(object.originalImageSize)).unsigned = false;
                        else if (typeof object.originalImageSize === "string")
                            message.originalImageSize = parseInt(object.originalImageSize, 10);
                        else if (typeof object.originalImageSize === "number")
                            message.originalImageSize = object.originalImageSize;
                        else if (typeof object.originalImageSize === "object")
                            message.originalImageSize = new $util.LongBits(object.originalImageSize.low >>> 0, object.originalImageSize.high >>> 0).toNumber();
                    if (object.downscaledImageSize != null)
                        if ($util.Long)
                            (message.downscaledImageSize = $util.Long.fromValue(object.downscaledImageSize)).unsigned = false;
                        else if (typeof object.downscaledImageSize === "string")
                            message.downscaledImageSize = parseInt(object.downscaledImageSize, 10);
                        else if (typeof object.downscaledImageSize === "number")
                            message.downscaledImageSize = object.downscaledImageSize;
                        else if (typeof object.downscaledImageSize === "object")
                            message.downscaledImageSize = new $util.LongBits(object.downscaledImageSize.low >>> 0, object.downscaledImageSize.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from an ImageDownscaleData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData} message ImageDownscaleData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ImageDownscaleData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.originalImageSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.originalImageSize = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.downscaledImageSize = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.downscaledImageSize = options.longs === String ? "0" : 0;
                    }
                    if (message.originalImageSize != null && message.hasOwnProperty("originalImageSize"))
                        if (typeof message.originalImageSize === "number")
                            object.originalImageSize = options.longs === String ? String(message.originalImageSize) : message.originalImageSize;
                        else
                            object.originalImageSize = options.longs === String ? $util.Long.prototype.toString.call(message.originalImageSize) : options.longs === Number ? new $util.LongBits(message.originalImageSize.low >>> 0, message.originalImageSize.high >>> 0).toNumber() : message.originalImageSize;
                    if (message.downscaledImageSize != null && message.hasOwnProperty("downscaledImageSize"))
                        if (typeof message.downscaledImageSize === "number")
                            object.downscaledImageSize = options.longs === String ? String(message.downscaledImageSize) : message.downscaledImageSize;
                        else
                            object.downscaledImageSize = options.longs === String ? $util.Long.prototype.toString.call(message.downscaledImageSize) : options.longs === Number ? new $util.LongBits(message.downscaledImageSize.low >>> 0, message.downscaledImageSize.high >>> 0).toNumber() : message.downscaledImageSize;
                    return object;
                };

                /**
                 * Converts this ImageDownscaleData to JSON.
                 * @function toJSON
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ImageDownscaleData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ImageDownscaleData
                 * @function getTypeUrl
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ImageDownscaleData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageDownscaleData";
                };

                return ImageDownscaleData;
            })();

            Phase.ImageEncodeData = (function() {

                /**
                 * Properties of an ImageEncodeData.
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
                 * @interface IImageEncodeData
                 * @property {lens.LensOverlayPhaseLatenciesMetadata.ImageType|null} [originalImageType] ImageEncodeData originalImageType
                 * @property {number|Long|null} [encodedImageSizeBytes] ImageEncodeData encodedImageSizeBytes
                 */

                /**
                 * Constructs a new ImageEncodeData.
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase
                 * @classdesc Represents an ImageEncodeData.
                 * @implements IImageEncodeData
                 * @constructor
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageEncodeData=} [properties] Properties to set
                 */
                function ImageEncodeData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ImageEncodeData originalImageType.
                 * @member {lens.LensOverlayPhaseLatenciesMetadata.ImageType} originalImageType
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @instance
                 */
                ImageEncodeData.prototype.originalImageType = 0;

                /**
                 * ImageEncodeData encodedImageSizeBytes.
                 * @member {number|Long} encodedImageSizeBytes
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @instance
                 */
                ImageEncodeData.prototype.encodedImageSizeBytes = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Creates a new ImageEncodeData instance using the specified properties.
                 * @function create
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageEncodeData=} [properties] Properties to set
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData} ImageEncodeData instance
                 */
                ImageEncodeData.create = function create(properties) {
                    return new ImageEncodeData(properties);
                };

                /**
                 * Encodes the specified ImageEncodeData message. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData.verify|verify} messages.
                 * @function encode
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageEncodeData} message ImageEncodeData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageEncodeData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.originalImageType != null && Object.hasOwnProperty.call(message, "originalImageType"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.originalImageType);
                    if (message.encodedImageSizeBytes != null && Object.hasOwnProperty.call(message, "encodedImageSizeBytes"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int64(message.encodedImageSizeBytes);
                    return writer;
                };

                /**
                 * Encodes the specified ImageEncodeData message, length delimited. Does not implicitly {@link lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.IImageEncodeData} message ImageEncodeData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ImageEncodeData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ImageEncodeData message from the specified reader or buffer.
                 * @function decode
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData} ImageEncodeData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageEncodeData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.originalImageType = reader.int32();
                                break;
                            }
                        case 2: {
                                message.encodedImageSizeBytes = reader.int64();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ImageEncodeData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData} ImageEncodeData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ImageEncodeData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ImageEncodeData message.
                 * @function verify
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ImageEncodeData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.originalImageType != null && message.hasOwnProperty("originalImageType"))
                        switch (message.originalImageType) {
                        default:
                            return "originalImageType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    if (message.encodedImageSizeBytes != null && message.hasOwnProperty("encodedImageSizeBytes"))
                        if (!$util.isInteger(message.encodedImageSizeBytes) && !(message.encodedImageSizeBytes && $util.isInteger(message.encodedImageSizeBytes.low) && $util.isInteger(message.encodedImageSizeBytes.high)))
                            return "encodedImageSizeBytes: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an ImageEncodeData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData} ImageEncodeData
                 */
                ImageEncodeData.fromObject = function fromObject(object) {
                    if (object instanceof $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData)
                        return object;
                    var message = new $root.lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData();
                    switch (object.originalImageType) {
                    default:
                        if (typeof object.originalImageType === "number") {
                            message.originalImageType = object.originalImageType;
                            break;
                        }
                        break;
                    case "UNKNOWN":
                    case 0:
                        message.originalImageType = 0;
                        break;
                    case "JPEG":
                    case 1:
                        message.originalImageType = 1;
                        break;
                    case "PNG":
                    case 2:
                        message.originalImageType = 2;
                        break;
                    case "WEBP":
                    case 3:
                        message.originalImageType = 3;
                        break;
                    }
                    if (object.encodedImageSizeBytes != null)
                        if ($util.Long)
                            (message.encodedImageSizeBytes = $util.Long.fromValue(object.encodedImageSizeBytes)).unsigned = false;
                        else if (typeof object.encodedImageSizeBytes === "string")
                            message.encodedImageSizeBytes = parseInt(object.encodedImageSizeBytes, 10);
                        else if (typeof object.encodedImageSizeBytes === "number")
                            message.encodedImageSizeBytes = object.encodedImageSizeBytes;
                        else if (typeof object.encodedImageSizeBytes === "object")
                            message.encodedImageSizeBytes = new $util.LongBits(object.encodedImageSizeBytes.low >>> 0, object.encodedImageSizeBytes.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from an ImageEncodeData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData} message ImageEncodeData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ImageEncodeData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.originalImageType = options.enums === String ? "UNKNOWN" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.encodedImageSizeBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.encodedImageSizeBytes = options.longs === String ? "0" : 0;
                    }
                    if (message.originalImageType != null && message.hasOwnProperty("originalImageType"))
                        object.originalImageType = options.enums === String ? $root.lens.LensOverlayPhaseLatenciesMetadata.ImageType[message.originalImageType] === undefined ? message.originalImageType : $root.lens.LensOverlayPhaseLatenciesMetadata.ImageType[message.originalImageType] : message.originalImageType;
                    if (message.encodedImageSizeBytes != null && message.hasOwnProperty("encodedImageSizeBytes"))
                        if (typeof message.encodedImageSizeBytes === "number")
                            object.encodedImageSizeBytes = options.longs === String ? String(message.encodedImageSizeBytes) : message.encodedImageSizeBytes;
                        else
                            object.encodedImageSizeBytes = options.longs === String ? $util.Long.prototype.toString.call(message.encodedImageSizeBytes) : options.longs === Number ? new $util.LongBits(message.encodedImageSizeBytes.low >>> 0, message.encodedImageSizeBytes.high >>> 0).toNumber() : message.encodedImageSizeBytes;
                    return object;
                };

                /**
                 * Converts this ImageEncodeData to JSON.
                 * @function toJSON
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ImageEncodeData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for ImageEncodeData
                 * @function getTypeUrl
                 * @memberof lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                ImageEncodeData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/lens.LensOverlayPhaseLatenciesMetadata.Phase.ImageEncodeData";
                };

                return ImageEncodeData;
            })();

            return Phase;
        })();

        return LensOverlayPhaseLatenciesMetadata;
    })();

    /**
     * ClientPlatform enum.
     * @name lens.ClientPlatform
     * @enum {number}
     * @property {number} CLIENT_PLATFORM_UNSPECIFIED=0 CLIENT_PLATFORM_UNSPECIFIED value
     * @property {number} CLIENT_PLATFORM_LENS_OVERLAY=2 CLIENT_PLATFORM_LENS_OVERLAY value
     */
    lens.ClientPlatform = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "CLIENT_PLATFORM_UNSPECIFIED"] = 0;
        values[valuesById[2] = "CLIENT_PLATFORM_LENS_OVERLAY"] = 2;
        return values;
    })();

    lens.LensOverlayClusterInfo = (function() {

        /**
         * Properties of a LensOverlayClusterInfo.
         * @memberof lens
         * @interface ILensOverlayClusterInfo
         * @property {string|null} [serverSessionId] LensOverlayClusterInfo serverSessionId
         * @property {string|null} [searchSessionId] LensOverlayClusterInfo searchSessionId
         * @property {lens.ILensOverlayRoutingInfo|null} [routingInfo] LensOverlayClusterInfo routingInfo
         */

        /**
         * Constructs a new LensOverlayClusterInfo.
         * @memberof lens
         * @classdesc Represents a LensOverlayClusterInfo.
         * @implements ILensOverlayClusterInfo
         * @constructor
         * @param {lens.ILensOverlayClusterInfo=} [properties] Properties to set
         */
        function LensOverlayClusterInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayClusterInfo serverSessionId.
         * @member {string} serverSessionId
         * @memberof lens.LensOverlayClusterInfo
         * @instance
         */
        LensOverlayClusterInfo.prototype.serverSessionId = "";

        /**
         * LensOverlayClusterInfo searchSessionId.
         * @member {string} searchSessionId
         * @memberof lens.LensOverlayClusterInfo
         * @instance
         */
        LensOverlayClusterInfo.prototype.searchSessionId = "";

        /**
         * LensOverlayClusterInfo routingInfo.
         * @member {lens.ILensOverlayRoutingInfo|null|undefined} routingInfo
         * @memberof lens.LensOverlayClusterInfo
         * @instance
         */
        LensOverlayClusterInfo.prototype.routingInfo = null;

        /**
         * Creates a new LensOverlayClusterInfo instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {lens.ILensOverlayClusterInfo=} [properties] Properties to set
         * @returns {lens.LensOverlayClusterInfo} LensOverlayClusterInfo instance
         */
        LensOverlayClusterInfo.create = function create(properties) {
            return new LensOverlayClusterInfo(properties);
        };

        /**
         * Encodes the specified LensOverlayClusterInfo message. Does not implicitly {@link lens.LensOverlayClusterInfo.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {lens.ILensOverlayClusterInfo} message LensOverlayClusterInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayClusterInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverSessionId != null && Object.hasOwnProperty.call(message, "serverSessionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverSessionId);
            if (message.searchSessionId != null && Object.hasOwnProperty.call(message, "searchSessionId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.searchSessionId);
            if (message.routingInfo != null && Object.hasOwnProperty.call(message, "routingInfo"))
                $root.lens.LensOverlayRoutingInfo.encode(message.routingInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayClusterInfo message, length delimited. Does not implicitly {@link lens.LensOverlayClusterInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {lens.ILensOverlayClusterInfo} message LensOverlayClusterInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayClusterInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayClusterInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayClusterInfo} LensOverlayClusterInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayClusterInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayClusterInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.serverSessionId = reader.string();
                        break;
                    }
                case 2: {
                        message.searchSessionId = reader.string();
                        break;
                    }
                case 6: {
                        message.routingInfo = $root.lens.LensOverlayRoutingInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayClusterInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayClusterInfo} LensOverlayClusterInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayClusterInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayClusterInfo message.
         * @function verify
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayClusterInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverSessionId != null && message.hasOwnProperty("serverSessionId"))
                if (!$util.isString(message.serverSessionId))
                    return "serverSessionId: string expected";
            if (message.searchSessionId != null && message.hasOwnProperty("searchSessionId"))
                if (!$util.isString(message.searchSessionId))
                    return "searchSessionId: string expected";
            if (message.routingInfo != null && message.hasOwnProperty("routingInfo")) {
                var error = $root.lens.LensOverlayRoutingInfo.verify(message.routingInfo);
                if (error)
                    return "routingInfo." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayClusterInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayClusterInfo} LensOverlayClusterInfo
         */
        LensOverlayClusterInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayClusterInfo)
                return object;
            var message = new $root.lens.LensOverlayClusterInfo();
            if (object.serverSessionId != null)
                message.serverSessionId = String(object.serverSessionId);
            if (object.searchSessionId != null)
                message.searchSessionId = String(object.searchSessionId);
            if (object.routingInfo != null) {
                if (typeof object.routingInfo !== "object")
                    throw TypeError(".lens.LensOverlayClusterInfo.routingInfo: object expected");
                message.routingInfo = $root.lens.LensOverlayRoutingInfo.fromObject(object.routingInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayClusterInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {lens.LensOverlayClusterInfo} message LensOverlayClusterInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayClusterInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverSessionId = "";
                object.searchSessionId = "";
                object.routingInfo = null;
            }
            if (message.serverSessionId != null && message.hasOwnProperty("serverSessionId"))
                object.serverSessionId = message.serverSessionId;
            if (message.searchSessionId != null && message.hasOwnProperty("searchSessionId"))
                object.searchSessionId = message.searchSessionId;
            if (message.routingInfo != null && message.hasOwnProperty("routingInfo"))
                object.routingInfo = $root.lens.LensOverlayRoutingInfo.toObject(message.routingInfo, options);
            return object;
        };

        /**
         * Converts this LensOverlayClusterInfo to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayClusterInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayClusterInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayClusterInfo
         * @function getTypeUrl
         * @memberof lens.LensOverlayClusterInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayClusterInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayClusterInfo";
        };

        return LensOverlayClusterInfo;
    })();

    lens.LensOverlayRoutingInfo = (function() {

        /**
         * Properties of a LensOverlayRoutingInfo.
         * @memberof lens
         * @interface ILensOverlayRoutingInfo
         * @property {string|null} [serverAddress] LensOverlayRoutingInfo serverAddress
         * @property {string|null} [cellAddress] LensOverlayRoutingInfo cellAddress
         * @property {string|null} [bladeTarget] LensOverlayRoutingInfo bladeTarget
         */

        /**
         * Constructs a new LensOverlayRoutingInfo.
         * @memberof lens
         * @classdesc Represents a LensOverlayRoutingInfo.
         * @implements ILensOverlayRoutingInfo
         * @constructor
         * @param {lens.ILensOverlayRoutingInfo=} [properties] Properties to set
         */
        function LensOverlayRoutingInfo(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayRoutingInfo serverAddress.
         * @member {string} serverAddress
         * @memberof lens.LensOverlayRoutingInfo
         * @instance
         */
        LensOverlayRoutingInfo.prototype.serverAddress = "";

        /**
         * LensOverlayRoutingInfo cellAddress.
         * @member {string} cellAddress
         * @memberof lens.LensOverlayRoutingInfo
         * @instance
         */
        LensOverlayRoutingInfo.prototype.cellAddress = "";

        /**
         * LensOverlayRoutingInfo bladeTarget.
         * @member {string} bladeTarget
         * @memberof lens.LensOverlayRoutingInfo
         * @instance
         */
        LensOverlayRoutingInfo.prototype.bladeTarget = "";

        /**
         * Creates a new LensOverlayRoutingInfo instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {lens.ILensOverlayRoutingInfo=} [properties] Properties to set
         * @returns {lens.LensOverlayRoutingInfo} LensOverlayRoutingInfo instance
         */
        LensOverlayRoutingInfo.create = function create(properties) {
            return new LensOverlayRoutingInfo(properties);
        };

        /**
         * Encodes the specified LensOverlayRoutingInfo message. Does not implicitly {@link lens.LensOverlayRoutingInfo.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {lens.ILensOverlayRoutingInfo} message LensOverlayRoutingInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayRoutingInfo.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverAddress != null && Object.hasOwnProperty.call(message, "serverAddress"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverAddress);
            if (message.bladeTarget != null && Object.hasOwnProperty.call(message, "bladeTarget"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.bladeTarget);
            if (message.cellAddress != null && Object.hasOwnProperty.call(message, "cellAddress"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.cellAddress);
            return writer;
        };

        /**
         * Encodes the specified LensOverlayRoutingInfo message, length delimited. Does not implicitly {@link lens.LensOverlayRoutingInfo.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {lens.ILensOverlayRoutingInfo} message LensOverlayRoutingInfo message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayRoutingInfo.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayRoutingInfo message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayRoutingInfo} LensOverlayRoutingInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayRoutingInfo.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayRoutingInfo();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.serverAddress = reader.string();
                        break;
                    }
                case 3: {
                        message.cellAddress = reader.string();
                        break;
                    }
                case 2: {
                        message.bladeTarget = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayRoutingInfo message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayRoutingInfo} LensOverlayRoutingInfo
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayRoutingInfo.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayRoutingInfo message.
         * @function verify
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayRoutingInfo.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverAddress != null && message.hasOwnProperty("serverAddress"))
                if (!$util.isString(message.serverAddress))
                    return "serverAddress: string expected";
            if (message.cellAddress != null && message.hasOwnProperty("cellAddress"))
                if (!$util.isString(message.cellAddress))
                    return "cellAddress: string expected";
            if (message.bladeTarget != null && message.hasOwnProperty("bladeTarget"))
                if (!$util.isString(message.bladeTarget))
                    return "bladeTarget: string expected";
            return null;
        };

        /**
         * Creates a LensOverlayRoutingInfo message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayRoutingInfo} LensOverlayRoutingInfo
         */
        LensOverlayRoutingInfo.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayRoutingInfo)
                return object;
            var message = new $root.lens.LensOverlayRoutingInfo();
            if (object.serverAddress != null)
                message.serverAddress = String(object.serverAddress);
            if (object.cellAddress != null)
                message.cellAddress = String(object.cellAddress);
            if (object.bladeTarget != null)
                message.bladeTarget = String(object.bladeTarget);
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayRoutingInfo message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {lens.LensOverlayRoutingInfo} message LensOverlayRoutingInfo
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayRoutingInfo.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverAddress = "";
                object.bladeTarget = "";
                object.cellAddress = "";
            }
            if (message.serverAddress != null && message.hasOwnProperty("serverAddress"))
                object.serverAddress = message.serverAddress;
            if (message.bladeTarget != null && message.hasOwnProperty("bladeTarget"))
                object.bladeTarget = message.bladeTarget;
            if (message.cellAddress != null && message.hasOwnProperty("cellAddress"))
                object.cellAddress = message.cellAddress;
            return object;
        };

        /**
         * Converts this LensOverlayRoutingInfo to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayRoutingInfo
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayRoutingInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayRoutingInfo
         * @function getTypeUrl
         * @memberof lens.LensOverlayRoutingInfo
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayRoutingInfo.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayRoutingInfo";
        };

        return LensOverlayRoutingInfo;
    })();

    lens.DeepGleamData = (function() {

        /**
         * Properties of a DeepGleamData.
         * @memberof lens
         * @interface IDeepGleamData
         * @property {lens.ITranslationData|null} [translation] DeepGleamData translation
         * @property {Array.<string>|null} [visualObjectId] DeepGleamData visualObjectId
         */

        /**
         * Constructs a new DeepGleamData.
         * @memberof lens
         * @classdesc Represents a DeepGleamData.
         * @implements IDeepGleamData
         * @constructor
         * @param {lens.IDeepGleamData=} [properties] Properties to set
         */
        function DeepGleamData(properties) {
            this.visualObjectId = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DeepGleamData translation.
         * @member {lens.ITranslationData|null|undefined} translation
         * @memberof lens.DeepGleamData
         * @instance
         */
        DeepGleamData.prototype.translation = null;

        /**
         * DeepGleamData visualObjectId.
         * @member {Array.<string>} visualObjectId
         * @memberof lens.DeepGleamData
         * @instance
         */
        DeepGleamData.prototype.visualObjectId = $util.emptyArray;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * DeepGleamData renderingOneof.
         * @member {"translation"|undefined} renderingOneof
         * @memberof lens.DeepGleamData
         * @instance
         */
        Object.defineProperty(DeepGleamData.prototype, "renderingOneof", {
            get: $util.oneOfGetter($oneOfFields = ["translation"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new DeepGleamData instance using the specified properties.
         * @function create
         * @memberof lens.DeepGleamData
         * @static
         * @param {lens.IDeepGleamData=} [properties] Properties to set
         * @returns {lens.DeepGleamData} DeepGleamData instance
         */
        DeepGleamData.create = function create(properties) {
            return new DeepGleamData(properties);
        };

        /**
         * Encodes the specified DeepGleamData message. Does not implicitly {@link lens.DeepGleamData.verify|verify} messages.
         * @function encode
         * @memberof lens.DeepGleamData
         * @static
         * @param {lens.IDeepGleamData} message DeepGleamData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeepGleamData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.translation != null && Object.hasOwnProperty.call(message, "translation"))
                $root.lens.TranslationData.encode(message.translation, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            if (message.visualObjectId != null && message.visualObjectId.length)
                for (var i = 0; i < message.visualObjectId.length; ++i)
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.visualObjectId[i]);
            return writer;
        };

        /**
         * Encodes the specified DeepGleamData message, length delimited. Does not implicitly {@link lens.DeepGleamData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.DeepGleamData
         * @static
         * @param {lens.IDeepGleamData} message DeepGleamData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        DeepGleamData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a DeepGleamData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.DeepGleamData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.DeepGleamData} DeepGleamData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeepGleamData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.DeepGleamData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 10: {
                        message.translation = $root.lens.TranslationData.decode(reader, reader.uint32());
                        break;
                    }
                case 11: {
                        if (!(message.visualObjectId && message.visualObjectId.length))
                            message.visualObjectId = [];
                        message.visualObjectId.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a DeepGleamData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.DeepGleamData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.DeepGleamData} DeepGleamData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        DeepGleamData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a DeepGleamData message.
         * @function verify
         * @memberof lens.DeepGleamData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DeepGleamData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.translation != null && message.hasOwnProperty("translation")) {
                properties.renderingOneof = 1;
                {
                    var error = $root.lens.TranslationData.verify(message.translation);
                    if (error)
                        return "translation." + error;
                }
            }
            if (message.visualObjectId != null && message.hasOwnProperty("visualObjectId")) {
                if (!Array.isArray(message.visualObjectId))
                    return "visualObjectId: array expected";
                for (var i = 0; i < message.visualObjectId.length; ++i)
                    if (!$util.isString(message.visualObjectId[i]))
                        return "visualObjectId: string[] expected";
            }
            return null;
        };

        /**
         * Creates a DeepGleamData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.DeepGleamData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.DeepGleamData} DeepGleamData
         */
        DeepGleamData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.DeepGleamData)
                return object;
            var message = new $root.lens.DeepGleamData();
            if (object.translation != null) {
                if (typeof object.translation !== "object")
                    throw TypeError(".lens.DeepGleamData.translation: object expected");
                message.translation = $root.lens.TranslationData.fromObject(object.translation);
            }
            if (object.visualObjectId) {
                if (!Array.isArray(object.visualObjectId))
                    throw TypeError(".lens.DeepGleamData.visualObjectId: array expected");
                message.visualObjectId = [];
                for (var i = 0; i < object.visualObjectId.length; ++i)
                    message.visualObjectId[i] = String(object.visualObjectId[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a DeepGleamData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.DeepGleamData
         * @static
         * @param {lens.DeepGleamData} message DeepGleamData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DeepGleamData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.visualObjectId = [];
            if (message.translation != null && message.hasOwnProperty("translation")) {
                object.translation = $root.lens.TranslationData.toObject(message.translation, options);
                if (options.oneofs)
                    object.renderingOneof = "translation";
            }
            if (message.visualObjectId && message.visualObjectId.length) {
                object.visualObjectId = [];
                for (var j = 0; j < message.visualObjectId.length; ++j)
                    object.visualObjectId[j] = message.visualObjectId[j];
            }
            return object;
        };

        /**
         * Converts this DeepGleamData to JSON.
         * @function toJSON
         * @memberof lens.DeepGleamData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DeepGleamData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for DeepGleamData
         * @function getTypeUrl
         * @memberof lens.DeepGleamData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        DeepGleamData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.DeepGleamData";
        };

        return DeepGleamData;
    })();

    lens.TranslationData = (function() {

        /**
         * Properties of a TranslationData.
         * @memberof lens
         * @interface ITranslationData
         * @property {lens.TranslationData.IStatus|null} [status] TranslationData status
         * @property {string|null} [targetLanguage] TranslationData targetLanguage
         * @property {string|null} [sourceLanguage] TranslationData sourceLanguage
         * @property {string|null} [translation] TranslationData translation
         * @property {Array.<lens.TranslationData.ILine>|null} [line] TranslationData line
         * @property {lens.WritingDirection|null} [writingDirection] TranslationData writingDirection
         * @property {lens.Alignment|null} [alignment] TranslationData alignment
         * @property {boolean|null} [justified] TranslationData justified
         */

        /**
         * Constructs a new TranslationData.
         * @memberof lens
         * @classdesc Represents a TranslationData.
         * @implements ITranslationData
         * @constructor
         * @param {lens.ITranslationData=} [properties] Properties to set
         */
        function TranslationData(properties) {
            this.line = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TranslationData status.
         * @member {lens.TranslationData.IStatus|null|undefined} status
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.status = null;

        /**
         * TranslationData targetLanguage.
         * @member {string} targetLanguage
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.targetLanguage = "";

        /**
         * TranslationData sourceLanguage.
         * @member {string} sourceLanguage
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.sourceLanguage = "";

        /**
         * TranslationData translation.
         * @member {string} translation
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.translation = "";

        /**
         * TranslationData line.
         * @member {Array.<lens.TranslationData.ILine>} line
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.line = $util.emptyArray;

        /**
         * TranslationData writingDirection.
         * @member {lens.WritingDirection} writingDirection
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.writingDirection = 0;

        /**
         * TranslationData alignment.
         * @member {lens.Alignment} alignment
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.alignment = 0;

        /**
         * TranslationData justified.
         * @member {boolean} justified
         * @memberof lens.TranslationData
         * @instance
         */
        TranslationData.prototype.justified = false;

        /**
         * Creates a new TranslationData instance using the specified properties.
         * @function create
         * @memberof lens.TranslationData
         * @static
         * @param {lens.ITranslationData=} [properties] Properties to set
         * @returns {lens.TranslationData} TranslationData instance
         */
        TranslationData.create = function create(properties) {
            return new TranslationData(properties);
        };

        /**
         * Encodes the specified TranslationData message. Does not implicitly {@link lens.TranslationData.verify|verify} messages.
         * @function encode
         * @memberof lens.TranslationData
         * @static
         * @param {lens.ITranslationData} message TranslationData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TranslationData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                $root.lens.TranslationData.Status.encode(message.status, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.targetLanguage != null && Object.hasOwnProperty.call(message, "targetLanguage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.targetLanguage);
            if (message.sourceLanguage != null && Object.hasOwnProperty.call(message, "sourceLanguage"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.sourceLanguage);
            if (message.translation != null && Object.hasOwnProperty.call(message, "translation"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.translation);
            if (message.line != null && message.line.length)
                for (var i = 0; i < message.line.length; ++i)
                    $root.lens.TranslationData.Line.encode(message.line[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.writingDirection != null && Object.hasOwnProperty.call(message, "writingDirection"))
                writer.uint32(/* id 7, wireType 0 =*/56).int32(message.writingDirection);
            if (message.alignment != null && Object.hasOwnProperty.call(message, "alignment"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.alignment);
            if (message.justified != null && Object.hasOwnProperty.call(message, "justified"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.justified);
            return writer;
        };

        /**
         * Encodes the specified TranslationData message, length delimited. Does not implicitly {@link lens.TranslationData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.TranslationData
         * @static
         * @param {lens.ITranslationData} message TranslationData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TranslationData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TranslationData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.TranslationData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.TranslationData} TranslationData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TranslationData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TranslationData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.status = $root.lens.TranslationData.Status.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.targetLanguage = reader.string();
                        break;
                    }
                case 3: {
                        message.sourceLanguage = reader.string();
                        break;
                    }
                case 4: {
                        message.translation = reader.string();
                        break;
                    }
                case 5: {
                        if (!(message.line && message.line.length))
                            message.line = [];
                        message.line.push($root.lens.TranslationData.Line.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.writingDirection = reader.int32();
                        break;
                    }
                case 8: {
                        message.alignment = reader.int32();
                        break;
                    }
                case 9: {
                        message.justified = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TranslationData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.TranslationData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.TranslationData} TranslationData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TranslationData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TranslationData message.
         * @function verify
         * @memberof lens.TranslationData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TranslationData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.status != null && message.hasOwnProperty("status")) {
                var error = $root.lens.TranslationData.Status.verify(message.status);
                if (error)
                    return "status." + error;
            }
            if (message.targetLanguage != null && message.hasOwnProperty("targetLanguage"))
                if (!$util.isString(message.targetLanguage))
                    return "targetLanguage: string expected";
            if (message.sourceLanguage != null && message.hasOwnProperty("sourceLanguage"))
                if (!$util.isString(message.sourceLanguage))
                    return "sourceLanguage: string expected";
            if (message.translation != null && message.hasOwnProperty("translation"))
                if (!$util.isString(message.translation))
                    return "translation: string expected";
            if (message.line != null && message.hasOwnProperty("line")) {
                if (!Array.isArray(message.line))
                    return "line: array expected";
                for (var i = 0; i < message.line.length; ++i) {
                    var error = $root.lens.TranslationData.Line.verify(message.line[i]);
                    if (error)
                        return "line." + error;
                }
            }
            if (message.writingDirection != null && message.hasOwnProperty("writingDirection"))
                switch (message.writingDirection) {
                default:
                    return "writingDirection: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.alignment != null && message.hasOwnProperty("alignment"))
                switch (message.alignment) {
                default:
                    return "alignment: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.justified != null && message.hasOwnProperty("justified"))
                if (typeof message.justified !== "boolean")
                    return "justified: boolean expected";
            return null;
        };

        /**
         * Creates a TranslationData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.TranslationData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.TranslationData} TranslationData
         */
        TranslationData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.TranslationData)
                return object;
            var message = new $root.lens.TranslationData();
            if (object.status != null) {
                if (typeof object.status !== "object")
                    throw TypeError(".lens.TranslationData.status: object expected");
                message.status = $root.lens.TranslationData.Status.fromObject(object.status);
            }
            if (object.targetLanguage != null)
                message.targetLanguage = String(object.targetLanguage);
            if (object.sourceLanguage != null)
                message.sourceLanguage = String(object.sourceLanguage);
            if (object.translation != null)
                message.translation = String(object.translation);
            if (object.line) {
                if (!Array.isArray(object.line))
                    throw TypeError(".lens.TranslationData.line: array expected");
                message.line = [];
                for (var i = 0; i < object.line.length; ++i) {
                    if (typeof object.line[i] !== "object")
                        throw TypeError(".lens.TranslationData.line: object expected");
                    message.line[i] = $root.lens.TranslationData.Line.fromObject(object.line[i]);
                }
            }
            switch (object.writingDirection) {
            default:
                if (typeof object.writingDirection === "number") {
                    message.writingDirection = object.writingDirection;
                    break;
                }
                break;
            case "DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT":
            case 0:
                message.writingDirection = 0;
                break;
            case "WRITING_DIRECTION_RIGHT_TO_LEFT":
            case 1:
                message.writingDirection = 1;
                break;
            case "WRITING_DIRECTION_TOP_TO_BOTTOM":
            case 2:
                message.writingDirection = 2;
                break;
            }
            switch (object.alignment) {
            default:
                if (typeof object.alignment === "number") {
                    message.alignment = object.alignment;
                    break;
                }
                break;
            case "DEFAULT_LEFT_ALIGNED":
            case 0:
                message.alignment = 0;
                break;
            case "RIGHT_ALIGNED":
            case 1:
                message.alignment = 1;
                break;
            case "CENTER_ALIGNED":
            case 2:
                message.alignment = 2;
                break;
            }
            if (object.justified != null)
                message.justified = Boolean(object.justified);
            return message;
        };

        /**
         * Creates a plain object from a TranslationData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.TranslationData
         * @static
         * @param {lens.TranslationData} message TranslationData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TranslationData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.line = [];
            if (options.defaults) {
                object.status = null;
                object.targetLanguage = "";
                object.sourceLanguage = "";
                object.translation = "";
                object.writingDirection = options.enums === String ? "DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT" : 0;
                object.alignment = options.enums === String ? "DEFAULT_LEFT_ALIGNED" : 0;
                object.justified = false;
            }
            if (message.status != null && message.hasOwnProperty("status"))
                object.status = $root.lens.TranslationData.Status.toObject(message.status, options);
            if (message.targetLanguage != null && message.hasOwnProperty("targetLanguage"))
                object.targetLanguage = message.targetLanguage;
            if (message.sourceLanguage != null && message.hasOwnProperty("sourceLanguage"))
                object.sourceLanguage = message.sourceLanguage;
            if (message.translation != null && message.hasOwnProperty("translation"))
                object.translation = message.translation;
            if (message.line && message.line.length) {
                object.line = [];
                for (var j = 0; j < message.line.length; ++j)
                    object.line[j] = $root.lens.TranslationData.Line.toObject(message.line[j], options);
            }
            if (message.writingDirection != null && message.hasOwnProperty("writingDirection"))
                object.writingDirection = options.enums === String ? $root.lens.WritingDirection[message.writingDirection] === undefined ? message.writingDirection : $root.lens.WritingDirection[message.writingDirection] : message.writingDirection;
            if (message.alignment != null && message.hasOwnProperty("alignment"))
                object.alignment = options.enums === String ? $root.lens.Alignment[message.alignment] === undefined ? message.alignment : $root.lens.Alignment[message.alignment] : message.alignment;
            if (message.justified != null && message.hasOwnProperty("justified"))
                object.justified = message.justified;
            return object;
        };

        /**
         * Converts this TranslationData to JSON.
         * @function toJSON
         * @memberof lens.TranslationData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TranslationData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TranslationData
         * @function getTypeUrl
         * @memberof lens.TranslationData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TranslationData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.TranslationData";
        };

        TranslationData.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof lens.TranslationData
             * @interface IStatus
             * @property {lens.TranslationData.Status.Code|null} [code] Status code
             */

            /**
             * Constructs a new Status.
             * @memberof lens.TranslationData
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {lens.TranslationData.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {lens.TranslationData.Status.Code} code
             * @memberof lens.TranslationData.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Creates a new Status instance using the specified properties.
             * @function create
             * @memberof lens.TranslationData.Status
             * @static
             * @param {lens.TranslationData.IStatus=} [properties] Properties to set
             * @returns {lens.TranslationData.Status} Status instance
             */
            Status.create = function create(properties) {
                return new Status(properties);
            };

            /**
             * Encodes the specified Status message. Does not implicitly {@link lens.TranslationData.Status.verify|verify} messages.
             * @function encode
             * @memberof lens.TranslationData.Status
             * @static
             * @param {lens.TranslationData.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                return writer;
            };

            /**
             * Encodes the specified Status message, length delimited. Does not implicitly {@link lens.TranslationData.Status.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.TranslationData.Status
             * @static
             * @param {lens.TranslationData.IStatus} message Status message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Status.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Status message from the specified reader or buffer.
             * @function decode
             * @memberof lens.TranslationData.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.TranslationData.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TranslationData.Status();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.code = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Status message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.TranslationData.Status
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.TranslationData.Status} Status
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Status.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof lens.TranslationData.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    switch (message.code) {
                    default:
                        return "code: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.TranslationData.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.TranslationData.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.TranslationData.Status)
                    return object;
                var message = new $root.lens.TranslationData.Status();
                switch (object.code) {
                default:
                    if (typeof object.code === "number") {
                        message.code = object.code;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.code = 0;
                    break;
                case "SUCCESS":
                case 1:
                    message.code = 1;
                    break;
                case "SERVER_ERROR":
                case 2:
                    message.code = 2;
                    break;
                case "UNSUPPORTED_LANGUAGE_PAIR":
                case 3:
                    message.code = 3;
                    break;
                case "SAME_LANGUAGE":
                case 4:
                    message.code = 4;
                    break;
                case "UNKNOWN_SOURCE_LANGUAGE":
                case 5:
                    message.code = 5;
                    break;
                case "INVALID_REQUEST":
                case 6:
                    message.code = 6;
                    break;
                case "DEADLINE_EXCEEDED":
                case 7:
                    message.code = 7;
                    break;
                case "EMPTY_TRANSLATION":
                case 8:
                    message.code = 8;
                    break;
                case "NO_OP_TRANSLATION":
                case 9:
                    message.code = 9;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.TranslationData.Status
             * @static
             * @param {lens.TranslationData.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.code = options.enums === String ? "UNKNOWN" : 0;
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = options.enums === String ? $root.lens.TranslationData.Status.Code[message.code] === undefined ? message.code : $root.lens.TranslationData.Status.Code[message.code] : message.code;
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof lens.TranslationData.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Status
             * @function getTypeUrl
             * @memberof lens.TranslationData.Status
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Status.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.TranslationData.Status";
            };

            /**
             * Code enum.
             * @name lens.TranslationData.Status.Code
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} SUCCESS=1 SUCCESS value
             * @property {number} SERVER_ERROR=2 SERVER_ERROR value
             * @property {number} UNSUPPORTED_LANGUAGE_PAIR=3 UNSUPPORTED_LANGUAGE_PAIR value
             * @property {number} SAME_LANGUAGE=4 SAME_LANGUAGE value
             * @property {number} UNKNOWN_SOURCE_LANGUAGE=5 UNKNOWN_SOURCE_LANGUAGE value
             * @property {number} INVALID_REQUEST=6 INVALID_REQUEST value
             * @property {number} DEADLINE_EXCEEDED=7 DEADLINE_EXCEEDED value
             * @property {number} EMPTY_TRANSLATION=8 EMPTY_TRANSLATION value
             * @property {number} NO_OP_TRANSLATION=9 NO_OP_TRANSLATION value
             */
            Status.Code = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "SUCCESS"] = 1;
                values[valuesById[2] = "SERVER_ERROR"] = 2;
                values[valuesById[3] = "UNSUPPORTED_LANGUAGE_PAIR"] = 3;
                values[valuesById[4] = "SAME_LANGUAGE"] = 4;
                values[valuesById[5] = "UNKNOWN_SOURCE_LANGUAGE"] = 5;
                values[valuesById[6] = "INVALID_REQUEST"] = 6;
                values[valuesById[7] = "DEADLINE_EXCEEDED"] = 7;
                values[valuesById[8] = "EMPTY_TRANSLATION"] = 8;
                values[valuesById[9] = "NO_OP_TRANSLATION"] = 9;
                return values;
            })();

            return Status;
        })();

        TranslationData.TextStyle = (function() {

            /**
             * Properties of a TextStyle.
             * @memberof lens.TranslationData
             * @interface ITextStyle
             * @property {number|null} [textColor] TextStyle textColor
             * @property {number|null} [backgroundPrimaryColor] TextStyle backgroundPrimaryColor
             */

            /**
             * Constructs a new TextStyle.
             * @memberof lens.TranslationData
             * @classdesc Represents a TextStyle.
             * @implements ITextStyle
             * @constructor
             * @param {lens.TranslationData.ITextStyle=} [properties] Properties to set
             */
            function TextStyle(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TextStyle textColor.
             * @member {number} textColor
             * @memberof lens.TranslationData.TextStyle
             * @instance
             */
            TextStyle.prototype.textColor = 0;

            /**
             * TextStyle backgroundPrimaryColor.
             * @member {number} backgroundPrimaryColor
             * @memberof lens.TranslationData.TextStyle
             * @instance
             */
            TextStyle.prototype.backgroundPrimaryColor = 0;

            /**
             * Creates a new TextStyle instance using the specified properties.
             * @function create
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {lens.TranslationData.ITextStyle=} [properties] Properties to set
             * @returns {lens.TranslationData.TextStyle} TextStyle instance
             */
            TextStyle.create = function create(properties) {
                return new TextStyle(properties);
            };

            /**
             * Encodes the specified TextStyle message. Does not implicitly {@link lens.TranslationData.TextStyle.verify|verify} messages.
             * @function encode
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {lens.TranslationData.ITextStyle} message TextStyle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextStyle.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.textColor != null && Object.hasOwnProperty.call(message, "textColor"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.textColor);
                if (message.backgroundPrimaryColor != null && Object.hasOwnProperty.call(message, "backgroundPrimaryColor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.backgroundPrimaryColor);
                return writer;
            };

            /**
             * Encodes the specified TextStyle message, length delimited. Does not implicitly {@link lens.TranslationData.TextStyle.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {lens.TranslationData.ITextStyle} message TextStyle message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TextStyle.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TextStyle message from the specified reader or buffer.
             * @function decode
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.TranslationData.TextStyle} TextStyle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextStyle.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TranslationData.TextStyle();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.textColor = reader.uint32();
                            break;
                        }
                    case 2: {
                            message.backgroundPrimaryColor = reader.uint32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TextStyle message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.TranslationData.TextStyle} TextStyle
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TextStyle.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TextStyle message.
             * @function verify
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TextStyle.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.textColor != null && message.hasOwnProperty("textColor"))
                    if (!$util.isInteger(message.textColor))
                        return "textColor: integer expected";
                if (message.backgroundPrimaryColor != null && message.hasOwnProperty("backgroundPrimaryColor"))
                    if (!$util.isInteger(message.backgroundPrimaryColor))
                        return "backgroundPrimaryColor: integer expected";
                return null;
            };

            /**
             * Creates a TextStyle message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.TranslationData.TextStyle} TextStyle
             */
            TextStyle.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.TranslationData.TextStyle)
                    return object;
                var message = new $root.lens.TranslationData.TextStyle();
                if (object.textColor != null)
                    message.textColor = object.textColor >>> 0;
                if (object.backgroundPrimaryColor != null)
                    message.backgroundPrimaryColor = object.backgroundPrimaryColor >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a TextStyle message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {lens.TranslationData.TextStyle} message TextStyle
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TextStyle.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.textColor = 0;
                    object.backgroundPrimaryColor = 0;
                }
                if (message.textColor != null && message.hasOwnProperty("textColor"))
                    object.textColor = message.textColor;
                if (message.backgroundPrimaryColor != null && message.hasOwnProperty("backgroundPrimaryColor"))
                    object.backgroundPrimaryColor = message.backgroundPrimaryColor;
                return object;
            };

            /**
             * Converts this TextStyle to JSON.
             * @function toJSON
             * @memberof lens.TranslationData.TextStyle
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TextStyle.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for TextStyle
             * @function getTypeUrl
             * @memberof lens.TranslationData.TextStyle
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            TextStyle.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.TranslationData.TextStyle";
            };

            return TextStyle;
        })();

        TranslationData.BackgroundImageData = (function() {

            /**
             * Properties of a BackgroundImageData.
             * @memberof lens.TranslationData
             * @interface IBackgroundImageData
             * @property {Uint8Array|null} [backgroundImage] BackgroundImageData backgroundImage
             * @property {number|null} [imageWidth] BackgroundImageData imageWidth
             * @property {number|null} [imageHeight] BackgroundImageData imageHeight
             * @property {number|null} [verticalPadding] BackgroundImageData verticalPadding
             * @property {number|null} [horizontalPadding] BackgroundImageData horizontalPadding
             * @property {lens.TranslationData.BackgroundImageData.FileFormat|null} [fileFormat] BackgroundImageData fileFormat
             * @property {Uint8Array|null} [textMask] BackgroundImageData textMask
             */

            /**
             * Constructs a new BackgroundImageData.
             * @memberof lens.TranslationData
             * @classdesc Represents a BackgroundImageData.
             * @implements IBackgroundImageData
             * @constructor
             * @param {lens.TranslationData.IBackgroundImageData=} [properties] Properties to set
             */
            function BackgroundImageData(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BackgroundImageData backgroundImage.
             * @member {Uint8Array} backgroundImage
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             */
            BackgroundImageData.prototype.backgroundImage = $util.newBuffer([]);

            /**
             * BackgroundImageData imageWidth.
             * @member {number} imageWidth
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             */
            BackgroundImageData.prototype.imageWidth = 0;

            /**
             * BackgroundImageData imageHeight.
             * @member {number} imageHeight
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             */
            BackgroundImageData.prototype.imageHeight = 0;

            /**
             * BackgroundImageData verticalPadding.
             * @member {number} verticalPadding
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             */
            BackgroundImageData.prototype.verticalPadding = 0;

            /**
             * BackgroundImageData horizontalPadding.
             * @member {number} horizontalPadding
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             */
            BackgroundImageData.prototype.horizontalPadding = 0;

            /**
             * BackgroundImageData fileFormat.
             * @member {lens.TranslationData.BackgroundImageData.FileFormat} fileFormat
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             */
            BackgroundImageData.prototype.fileFormat = 0;

            /**
             * BackgroundImageData textMask.
             * @member {Uint8Array} textMask
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             */
            BackgroundImageData.prototype.textMask = $util.newBuffer([]);

            /**
             * Creates a new BackgroundImageData instance using the specified properties.
             * @function create
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {lens.TranslationData.IBackgroundImageData=} [properties] Properties to set
             * @returns {lens.TranslationData.BackgroundImageData} BackgroundImageData instance
             */
            BackgroundImageData.create = function create(properties) {
                return new BackgroundImageData(properties);
            };

            /**
             * Encodes the specified BackgroundImageData message. Does not implicitly {@link lens.TranslationData.BackgroundImageData.verify|verify} messages.
             * @function encode
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {lens.TranslationData.IBackgroundImageData} message BackgroundImageData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BackgroundImageData.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.backgroundImage != null && Object.hasOwnProperty.call(message, "backgroundImage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.backgroundImage);
                if (message.imageWidth != null && Object.hasOwnProperty.call(message, "imageWidth"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.imageWidth);
                if (message.imageHeight != null && Object.hasOwnProperty.call(message, "imageHeight"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.imageHeight);
                if (message.verticalPadding != null && Object.hasOwnProperty.call(message, "verticalPadding"))
                    writer.uint32(/* id 4, wireType 5 =*/37).float(message.verticalPadding);
                if (message.horizontalPadding != null && Object.hasOwnProperty.call(message, "horizontalPadding"))
                    writer.uint32(/* id 5, wireType 5 =*/45).float(message.horizontalPadding);
                if (message.fileFormat != null && Object.hasOwnProperty.call(message, "fileFormat"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.fileFormat);
                if (message.textMask != null && Object.hasOwnProperty.call(message, "textMask"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.textMask);
                return writer;
            };

            /**
             * Encodes the specified BackgroundImageData message, length delimited. Does not implicitly {@link lens.TranslationData.BackgroundImageData.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {lens.TranslationData.IBackgroundImageData} message BackgroundImageData message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            BackgroundImageData.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a BackgroundImageData message from the specified reader or buffer.
             * @function decode
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.TranslationData.BackgroundImageData} BackgroundImageData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BackgroundImageData.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TranslationData.BackgroundImageData();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.backgroundImage = reader.bytes();
                            break;
                        }
                    case 2: {
                            message.imageWidth = reader.int32();
                            break;
                        }
                    case 3: {
                            message.imageHeight = reader.int32();
                            break;
                        }
                    case 4: {
                            message.verticalPadding = reader.float();
                            break;
                        }
                    case 5: {
                            message.horizontalPadding = reader.float();
                            break;
                        }
                    case 6: {
                            message.fileFormat = reader.int32();
                            break;
                        }
                    case 7: {
                            message.textMask = reader.bytes();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a BackgroundImageData message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.TranslationData.BackgroundImageData} BackgroundImageData
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            BackgroundImageData.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a BackgroundImageData message.
             * @function verify
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BackgroundImageData.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.backgroundImage != null && message.hasOwnProperty("backgroundImage"))
                    if (!(message.backgroundImage && typeof message.backgroundImage.length === "number" || $util.isString(message.backgroundImage)))
                        return "backgroundImage: buffer expected";
                if (message.imageWidth != null && message.hasOwnProperty("imageWidth"))
                    if (!$util.isInteger(message.imageWidth))
                        return "imageWidth: integer expected";
                if (message.imageHeight != null && message.hasOwnProperty("imageHeight"))
                    if (!$util.isInteger(message.imageHeight))
                        return "imageHeight: integer expected";
                if (message.verticalPadding != null && message.hasOwnProperty("verticalPadding"))
                    if (typeof message.verticalPadding !== "number")
                        return "verticalPadding: number expected";
                if (message.horizontalPadding != null && message.hasOwnProperty("horizontalPadding"))
                    if (typeof message.horizontalPadding !== "number")
                        return "horizontalPadding: number expected";
                if (message.fileFormat != null && message.hasOwnProperty("fileFormat"))
                    switch (message.fileFormat) {
                    default:
                        return "fileFormat: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                        break;
                    }
                if (message.textMask != null && message.hasOwnProperty("textMask"))
                    if (!(message.textMask && typeof message.textMask.length === "number" || $util.isString(message.textMask)))
                        return "textMask: buffer expected";
                return null;
            };

            /**
             * Creates a BackgroundImageData message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.TranslationData.BackgroundImageData} BackgroundImageData
             */
            BackgroundImageData.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.TranslationData.BackgroundImageData)
                    return object;
                var message = new $root.lens.TranslationData.BackgroundImageData();
                if (object.backgroundImage != null)
                    if (typeof object.backgroundImage === "string")
                        $util.base64.decode(object.backgroundImage, message.backgroundImage = $util.newBuffer($util.base64.length(object.backgroundImage)), 0);
                    else if (object.backgroundImage.length >= 0)
                        message.backgroundImage = object.backgroundImage;
                if (object.imageWidth != null)
                    message.imageWidth = object.imageWidth | 0;
                if (object.imageHeight != null)
                    message.imageHeight = object.imageHeight | 0;
                if (object.verticalPadding != null)
                    message.verticalPadding = Number(object.verticalPadding);
                if (object.horizontalPadding != null)
                    message.horizontalPadding = Number(object.horizontalPadding);
                switch (object.fileFormat) {
                default:
                    if (typeof object.fileFormat === "number") {
                        message.fileFormat = object.fileFormat;
                        break;
                    }
                    break;
                case "UNKNOWN":
                case 0:
                    message.fileFormat = 0;
                    break;
                case "RAW_BYTES_RGBA":
                case 1:
                    message.fileFormat = 1;
                    break;
                case "PNG_RGBA":
                case 2:
                    message.fileFormat = 2;
                    break;
                case "WEBP_RGBA":
                case 3:
                    message.fileFormat = 3;
                    break;
                case "JPEG_RGB_PNG_MASK":
                case 4:
                    message.fileFormat = 4;
                    break;
                }
                if (object.textMask != null)
                    if (typeof object.textMask === "string")
                        $util.base64.decode(object.textMask, message.textMask = $util.newBuffer($util.base64.length(object.textMask)), 0);
                    else if (object.textMask.length >= 0)
                        message.textMask = object.textMask;
                return message;
            };

            /**
             * Creates a plain object from a BackgroundImageData message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {lens.TranslationData.BackgroundImageData} message BackgroundImageData
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BackgroundImageData.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.backgroundImage = "";
                    else {
                        object.backgroundImage = [];
                        if (options.bytes !== Array)
                            object.backgroundImage = $util.newBuffer(object.backgroundImage);
                    }
                    object.imageWidth = 0;
                    object.imageHeight = 0;
                    object.verticalPadding = 0;
                    object.horizontalPadding = 0;
                    object.fileFormat = options.enums === String ? "UNKNOWN" : 0;
                    if (options.bytes === String)
                        object.textMask = "";
                    else {
                        object.textMask = [];
                        if (options.bytes !== Array)
                            object.textMask = $util.newBuffer(object.textMask);
                    }
                }
                if (message.backgroundImage != null && message.hasOwnProperty("backgroundImage"))
                    object.backgroundImage = options.bytes === String ? $util.base64.encode(message.backgroundImage, 0, message.backgroundImage.length) : options.bytes === Array ? Array.prototype.slice.call(message.backgroundImage) : message.backgroundImage;
                if (message.imageWidth != null && message.hasOwnProperty("imageWidth"))
                    object.imageWidth = message.imageWidth;
                if (message.imageHeight != null && message.hasOwnProperty("imageHeight"))
                    object.imageHeight = message.imageHeight;
                if (message.verticalPadding != null && message.hasOwnProperty("verticalPadding"))
                    object.verticalPadding = options.json && !isFinite(message.verticalPadding) ? String(message.verticalPadding) : message.verticalPadding;
                if (message.horizontalPadding != null && message.hasOwnProperty("horizontalPadding"))
                    object.horizontalPadding = options.json && !isFinite(message.horizontalPadding) ? String(message.horizontalPadding) : message.horizontalPadding;
                if (message.fileFormat != null && message.hasOwnProperty("fileFormat"))
                    object.fileFormat = options.enums === String ? $root.lens.TranslationData.BackgroundImageData.FileFormat[message.fileFormat] === undefined ? message.fileFormat : $root.lens.TranslationData.BackgroundImageData.FileFormat[message.fileFormat] : message.fileFormat;
                if (message.textMask != null && message.hasOwnProperty("textMask"))
                    object.textMask = options.bytes === String ? $util.base64.encode(message.textMask, 0, message.textMask.length) : options.bytes === Array ? Array.prototype.slice.call(message.textMask) : message.textMask;
                return object;
            };

            /**
             * Converts this BackgroundImageData to JSON.
             * @function toJSON
             * @memberof lens.TranslationData.BackgroundImageData
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BackgroundImageData.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for BackgroundImageData
             * @function getTypeUrl
             * @memberof lens.TranslationData.BackgroundImageData
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            BackgroundImageData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.TranslationData.BackgroundImageData";
            };

            /**
             * FileFormat enum.
             * @name lens.TranslationData.BackgroundImageData.FileFormat
             * @enum {number}
             * @property {number} UNKNOWN=0 UNKNOWN value
             * @property {number} RAW_BYTES_RGBA=1 RAW_BYTES_RGBA value
             * @property {number} PNG_RGBA=2 PNG_RGBA value
             * @property {number} WEBP_RGBA=3 WEBP_RGBA value
             * @property {number} JPEG_RGB_PNG_MASK=4 JPEG_RGB_PNG_MASK value
             */
            BackgroundImageData.FileFormat = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNKNOWN"] = 0;
                values[valuesById[1] = "RAW_BYTES_RGBA"] = 1;
                values[valuesById[2] = "PNG_RGBA"] = 2;
                values[valuesById[3] = "WEBP_RGBA"] = 3;
                values[valuesById[4] = "JPEG_RGB_PNG_MASK"] = 4;
                return values;
            })();

            return BackgroundImageData;
        })();

        TranslationData.Line = (function() {

            /**
             * Properties of a Line.
             * @memberof lens.TranslationData
             * @interface ILine
             * @property {number|null} [start] Line start
             * @property {number|null} [end] Line end
             * @property {lens.TranslationData.ITextStyle|null} [style] Line style
             * @property {Array.<lens.TranslationData.Line.IWord>|null} [word] Line word
             * @property {lens.TranslationData.IBackgroundImageData|null} [backgroundImageData] Line backgroundImageData
             */

            /**
             * Constructs a new Line.
             * @memberof lens.TranslationData
             * @classdesc Represents a Line.
             * @implements ILine
             * @constructor
             * @param {lens.TranslationData.ILine=} [properties] Properties to set
             */
            function Line(properties) {
                this.word = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Line start.
             * @member {number} start
             * @memberof lens.TranslationData.Line
             * @instance
             */
            Line.prototype.start = 0;

            /**
             * Line end.
             * @member {number} end
             * @memberof lens.TranslationData.Line
             * @instance
             */
            Line.prototype.end = 0;

            /**
             * Line style.
             * @member {lens.TranslationData.ITextStyle|null|undefined} style
             * @memberof lens.TranslationData.Line
             * @instance
             */
            Line.prototype.style = null;

            /**
             * Line word.
             * @member {Array.<lens.TranslationData.Line.IWord>} word
             * @memberof lens.TranslationData.Line
             * @instance
             */
            Line.prototype.word = $util.emptyArray;

            /**
             * Line backgroundImageData.
             * @member {lens.TranslationData.IBackgroundImageData|null|undefined} backgroundImageData
             * @memberof lens.TranslationData.Line
             * @instance
             */
            Line.prototype.backgroundImageData = null;

            /**
             * Creates a new Line instance using the specified properties.
             * @function create
             * @memberof lens.TranslationData.Line
             * @static
             * @param {lens.TranslationData.ILine=} [properties] Properties to set
             * @returns {lens.TranslationData.Line} Line instance
             */
            Line.create = function create(properties) {
                return new Line(properties);
            };

            /**
             * Encodes the specified Line message. Does not implicitly {@link lens.TranslationData.Line.verify|verify} messages.
             * @function encode
             * @memberof lens.TranslationData.Line
             * @static
             * @param {lens.TranslationData.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                if (message.style != null && Object.hasOwnProperty.call(message, "style"))
                    $root.lens.TranslationData.TextStyle.encode(message.style, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.word != null && message.word.length)
                    for (var i = 0; i < message.word.length; ++i)
                        $root.lens.TranslationData.Line.Word.encode(message.word[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.backgroundImageData != null && Object.hasOwnProperty.call(message, "backgroundImageData"))
                    $root.lens.TranslationData.BackgroundImageData.encode(message.backgroundImageData, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Line message, length delimited. Does not implicitly {@link lens.TranslationData.Line.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.TranslationData.Line
             * @static
             * @param {lens.TranslationData.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Line message from the specified reader or buffer.
             * @function decode
             * @memberof lens.TranslationData.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.TranslationData.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TranslationData.Line();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.start = reader.int32();
                            break;
                        }
                    case 2: {
                            message.end = reader.int32();
                            break;
                        }
                    case 3: {
                            message.style = $root.lens.TranslationData.TextStyle.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            if (!(message.word && message.word.length))
                                message.word = [];
                            message.word.push($root.lens.TranslationData.Line.Word.decode(reader, reader.uint32()));
                            break;
                        }
                    case 9: {
                            message.backgroundImageData = $root.lens.TranslationData.BackgroundImageData.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Line message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.TranslationData.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.TranslationData.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Line message.
             * @function verify
             * @memberof lens.TranslationData.Line
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Line.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.start != null && message.hasOwnProperty("start"))
                    if (!$util.isInteger(message.start))
                        return "start: integer expected";
                if (message.end != null && message.hasOwnProperty("end"))
                    if (!$util.isInteger(message.end))
                        return "end: integer expected";
                if (message.style != null && message.hasOwnProperty("style")) {
                    var error = $root.lens.TranslationData.TextStyle.verify(message.style);
                    if (error)
                        return "style." + error;
                }
                if (message.word != null && message.hasOwnProperty("word")) {
                    if (!Array.isArray(message.word))
                        return "word: array expected";
                    for (var i = 0; i < message.word.length; ++i) {
                        var error = $root.lens.TranslationData.Line.Word.verify(message.word[i]);
                        if (error)
                            return "word." + error;
                    }
                }
                if (message.backgroundImageData != null && message.hasOwnProperty("backgroundImageData")) {
                    var error = $root.lens.TranslationData.BackgroundImageData.verify(message.backgroundImageData);
                    if (error)
                        return "backgroundImageData." + error;
                }
                return null;
            };

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.TranslationData.Line
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.TranslationData.Line} Line
             */
            Line.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.TranslationData.Line)
                    return object;
                var message = new $root.lens.TranslationData.Line();
                if (object.start != null)
                    message.start = object.start | 0;
                if (object.end != null)
                    message.end = object.end | 0;
                if (object.style != null) {
                    if (typeof object.style !== "object")
                        throw TypeError(".lens.TranslationData.Line.style: object expected");
                    message.style = $root.lens.TranslationData.TextStyle.fromObject(object.style);
                }
                if (object.word) {
                    if (!Array.isArray(object.word))
                        throw TypeError(".lens.TranslationData.Line.word: array expected");
                    message.word = [];
                    for (var i = 0; i < object.word.length; ++i) {
                        if (typeof object.word[i] !== "object")
                            throw TypeError(".lens.TranslationData.Line.word: object expected");
                        message.word[i] = $root.lens.TranslationData.Line.Word.fromObject(object.word[i]);
                    }
                }
                if (object.backgroundImageData != null) {
                    if (typeof object.backgroundImageData !== "object")
                        throw TypeError(".lens.TranslationData.Line.backgroundImageData: object expected");
                    message.backgroundImageData = $root.lens.TranslationData.BackgroundImageData.fromObject(object.backgroundImageData);
                }
                return message;
            };

            /**
             * Creates a plain object from a Line message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.TranslationData.Line
             * @static
             * @param {lens.TranslationData.Line} message Line
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Line.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.word = [];
                if (options.defaults) {
                    object.start = 0;
                    object.end = 0;
                    object.style = null;
                    object.backgroundImageData = null;
                }
                if (message.start != null && message.hasOwnProperty("start"))
                    object.start = message.start;
                if (message.end != null && message.hasOwnProperty("end"))
                    object.end = message.end;
                if (message.style != null && message.hasOwnProperty("style"))
                    object.style = $root.lens.TranslationData.TextStyle.toObject(message.style, options);
                if (message.word && message.word.length) {
                    object.word = [];
                    for (var j = 0; j < message.word.length; ++j)
                        object.word[j] = $root.lens.TranslationData.Line.Word.toObject(message.word[j], options);
                }
                if (message.backgroundImageData != null && message.hasOwnProperty("backgroundImageData"))
                    object.backgroundImageData = $root.lens.TranslationData.BackgroundImageData.toObject(message.backgroundImageData, options);
                return object;
            };

            /**
             * Converts this Line to JSON.
             * @function toJSON
             * @memberof lens.TranslationData.Line
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Line.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Line
             * @function getTypeUrl
             * @memberof lens.TranslationData.Line
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Line.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.TranslationData.Line";
            };

            Line.Word = (function() {

                /**
                 * Properties of a Word.
                 * @memberof lens.TranslationData.Line
                 * @interface IWord
                 * @property {number|null} [start] Word start
                 * @property {number|null} [end] Word end
                 */

                /**
                 * Constructs a new Word.
                 * @memberof lens.TranslationData.Line
                 * @classdesc Represents a Word.
                 * @implements IWord
                 * @constructor
                 * @param {lens.TranslationData.Line.IWord=} [properties] Properties to set
                 */
                function Word(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Word start.
                 * @member {number} start
                 * @memberof lens.TranslationData.Line.Word
                 * @instance
                 */
                Word.prototype.start = 0;

                /**
                 * Word end.
                 * @member {number} end
                 * @memberof lens.TranslationData.Line.Word
                 * @instance
                 */
                Word.prototype.end = 0;

                /**
                 * Creates a new Word instance using the specified properties.
                 * @function create
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {lens.TranslationData.Line.IWord=} [properties] Properties to set
                 * @returns {lens.TranslationData.Line.Word} Word instance
                 */
                Word.create = function create(properties) {
                    return new Word(properties);
                };

                /**
                 * Encodes the specified Word message. Does not implicitly {@link lens.TranslationData.Line.Word.verify|verify} messages.
                 * @function encode
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {lens.TranslationData.Line.IWord} message Word message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Word.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Word message, length delimited. Does not implicitly {@link lens.TranslationData.Line.Word.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {lens.TranslationData.Line.IWord} message Word message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Word.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Word message from the specified reader or buffer.
                 * @function decode
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lens.TranslationData.Line.Word} Word
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Word.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TranslationData.Line.Word();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.start = reader.int32();
                                break;
                            }
                        case 2: {
                                message.end = reader.int32();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Word message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lens.TranslationData.Line.Word} Word
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Word.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Word message.
                 * @function verify
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Word.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a Word message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lens.TranslationData.Line.Word} Word
                 */
                Word.fromObject = function fromObject(object) {
                    if (object instanceof $root.lens.TranslationData.Line.Word)
                        return object;
                    var message = new $root.lens.TranslationData.Line.Word();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Word message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {lens.TranslationData.Line.Word} message Word
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Word.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Word to JSON.
                 * @function toJSON
                 * @memberof lens.TranslationData.Line.Word
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Word.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Word
                 * @function getTypeUrl
                 * @memberof lens.TranslationData.Line.Word
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Word.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/lens.TranslationData.Line.Word";
                };

                return Word;
            })();

            return Line;
        })();

        return TranslationData;
    })();

    /**
     * WritingDirection enum.
     * @name lens.WritingDirection
     * @enum {number}
     * @property {number} DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT=0 DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT value
     * @property {number} WRITING_DIRECTION_RIGHT_TO_LEFT=1 WRITING_DIRECTION_RIGHT_TO_LEFT value
     * @property {number} WRITING_DIRECTION_TOP_TO_BOTTOM=2 WRITING_DIRECTION_TOP_TO_BOTTOM value
     */
    lens.WritingDirection = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT"] = 0;
        values[valuesById[1] = "WRITING_DIRECTION_RIGHT_TO_LEFT"] = 1;
        values[valuesById[2] = "WRITING_DIRECTION_TOP_TO_BOTTOM"] = 2;
        return values;
    })();

    /**
     * Alignment enum.
     * @name lens.Alignment
     * @enum {number}
     * @property {number} DEFAULT_LEFT_ALIGNED=0 DEFAULT_LEFT_ALIGNED value
     * @property {number} RIGHT_ALIGNED=1 RIGHT_ALIGNED value
     * @property {number} CENTER_ALIGNED=2 CENTER_ALIGNED value
     */
    lens.Alignment = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "DEFAULT_LEFT_ALIGNED"] = 0;
        values[valuesById[1] = "RIGHT_ALIGNED"] = 1;
        values[valuesById[2] = "CENTER_ALIGNED"] = 2;
        return values;
    })();

    lens.Text = (function() {

        /**
         * Properties of a Text.
         * @memberof lens
         * @interface IText
         * @property {lens.ITextLayout|null} [textLayout] Text textLayout
         * @property {string|null} [contentLanguage] Text contentLanguage
         */

        /**
         * Constructs a new Text.
         * @memberof lens
         * @classdesc Represents a Text.
         * @implements IText
         * @constructor
         * @param {lens.IText=} [properties] Properties to set
         */
        function Text(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Text textLayout.
         * @member {lens.ITextLayout|null|undefined} textLayout
         * @memberof lens.Text
         * @instance
         */
        Text.prototype.textLayout = null;

        /**
         * Text contentLanguage.
         * @member {string} contentLanguage
         * @memberof lens.Text
         * @instance
         */
        Text.prototype.contentLanguage = "";

        /**
         * Creates a new Text instance using the specified properties.
         * @function create
         * @memberof lens.Text
         * @static
         * @param {lens.IText=} [properties] Properties to set
         * @returns {lens.Text} Text instance
         */
        Text.create = function create(properties) {
            return new Text(properties);
        };

        /**
         * Encodes the specified Text message. Does not implicitly {@link lens.Text.verify|verify} messages.
         * @function encode
         * @memberof lens.Text
         * @static
         * @param {lens.IText} message Text message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Text.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.textLayout != null && Object.hasOwnProperty.call(message, "textLayout"))
                $root.lens.TextLayout.encode(message.textLayout, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.contentLanguage != null && Object.hasOwnProperty.call(message, "contentLanguage"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.contentLanguage);
            return writer;
        };

        /**
         * Encodes the specified Text message, length delimited. Does not implicitly {@link lens.Text.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Text
         * @static
         * @param {lens.IText} message Text message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Text.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Text message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Text
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Text} Text
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Text.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Text();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.textLayout = $root.lens.TextLayout.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.contentLanguage = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Text message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Text
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Text} Text
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Text.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Text message.
         * @function verify
         * @memberof lens.Text
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Text.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.textLayout != null && message.hasOwnProperty("textLayout")) {
                var error = $root.lens.TextLayout.verify(message.textLayout);
                if (error)
                    return "textLayout." + error;
            }
            if (message.contentLanguage != null && message.hasOwnProperty("contentLanguage"))
                if (!$util.isString(message.contentLanguage))
                    return "contentLanguage: string expected";
            return null;
        };

        /**
         * Creates a Text message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Text
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Text} Text
         */
        Text.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Text)
                return object;
            var message = new $root.lens.Text();
            if (object.textLayout != null) {
                if (typeof object.textLayout !== "object")
                    throw TypeError(".lens.Text.textLayout: object expected");
                message.textLayout = $root.lens.TextLayout.fromObject(object.textLayout);
            }
            if (object.contentLanguage != null)
                message.contentLanguage = String(object.contentLanguage);
            return message;
        };

        /**
         * Creates a plain object from a Text message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Text
         * @static
         * @param {lens.Text} message Text
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Text.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.textLayout = null;
                object.contentLanguage = "";
            }
            if (message.textLayout != null && message.hasOwnProperty("textLayout"))
                object.textLayout = $root.lens.TextLayout.toObject(message.textLayout, options);
            if (message.contentLanguage != null && message.hasOwnProperty("contentLanguage"))
                object.contentLanguage = message.contentLanguage;
            return object;
        };

        /**
         * Converts this Text to JSON.
         * @function toJSON
         * @memberof lens.Text
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Text.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Text
         * @function getTypeUrl
         * @memberof lens.Text
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Text.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Text";
        };

        return Text;
    })();

    lens.TextLayout = (function() {

        /**
         * Properties of a TextLayout.
         * @memberof lens
         * @interface ITextLayout
         * @property {Array.<lens.TextLayout.IParagraph>|null} [paragraphs] TextLayout paragraphs
         */

        /**
         * Constructs a new TextLayout.
         * @memberof lens
         * @classdesc Represents a TextLayout.
         * @implements ITextLayout
         * @constructor
         * @param {lens.ITextLayout=} [properties] Properties to set
         */
        function TextLayout(properties) {
            this.paragraphs = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TextLayout paragraphs.
         * @member {Array.<lens.TextLayout.IParagraph>} paragraphs
         * @memberof lens.TextLayout
         * @instance
         */
        TextLayout.prototype.paragraphs = $util.emptyArray;

        /**
         * Creates a new TextLayout instance using the specified properties.
         * @function create
         * @memberof lens.TextLayout
         * @static
         * @param {lens.ITextLayout=} [properties] Properties to set
         * @returns {lens.TextLayout} TextLayout instance
         */
        TextLayout.create = function create(properties) {
            return new TextLayout(properties);
        };

        /**
         * Encodes the specified TextLayout message. Does not implicitly {@link lens.TextLayout.verify|verify} messages.
         * @function encode
         * @memberof lens.TextLayout
         * @static
         * @param {lens.ITextLayout} message TextLayout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextLayout.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.paragraphs != null && message.paragraphs.length)
                for (var i = 0; i < message.paragraphs.length; ++i)
                    $root.lens.TextLayout.Paragraph.encode(message.paragraphs[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified TextLayout message, length delimited. Does not implicitly {@link lens.TextLayout.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.TextLayout
         * @static
         * @param {lens.ITextLayout} message TextLayout message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextLayout.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextLayout message from the specified reader or buffer.
         * @function decode
         * @memberof lens.TextLayout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.TextLayout} TextLayout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextLayout.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TextLayout();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.paragraphs && message.paragraphs.length))
                            message.paragraphs = [];
                        message.paragraphs.push($root.lens.TextLayout.Paragraph.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextLayout message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.TextLayout
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.TextLayout} TextLayout
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextLayout.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TextLayout message.
         * @function verify
         * @memberof lens.TextLayout
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TextLayout.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.paragraphs != null && message.hasOwnProperty("paragraphs")) {
                if (!Array.isArray(message.paragraphs))
                    return "paragraphs: array expected";
                for (var i = 0; i < message.paragraphs.length; ++i) {
                    var error = $root.lens.TextLayout.Paragraph.verify(message.paragraphs[i]);
                    if (error)
                        return "paragraphs." + error;
                }
            }
            return null;
        };

        /**
         * Creates a TextLayout message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.TextLayout
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.TextLayout} TextLayout
         */
        TextLayout.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.TextLayout)
                return object;
            var message = new $root.lens.TextLayout();
            if (object.paragraphs) {
                if (!Array.isArray(object.paragraphs))
                    throw TypeError(".lens.TextLayout.paragraphs: array expected");
                message.paragraphs = [];
                for (var i = 0; i < object.paragraphs.length; ++i) {
                    if (typeof object.paragraphs[i] !== "object")
                        throw TypeError(".lens.TextLayout.paragraphs: object expected");
                    message.paragraphs[i] = $root.lens.TextLayout.Paragraph.fromObject(object.paragraphs[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a TextLayout message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.TextLayout
         * @static
         * @param {lens.TextLayout} message TextLayout
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TextLayout.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.paragraphs = [];
            if (message.paragraphs && message.paragraphs.length) {
                object.paragraphs = [];
                for (var j = 0; j < message.paragraphs.length; ++j)
                    object.paragraphs[j] = $root.lens.TextLayout.Paragraph.toObject(message.paragraphs[j], options);
            }
            return object;
        };

        /**
         * Converts this TextLayout to JSON.
         * @function toJSON
         * @memberof lens.TextLayout
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TextLayout.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TextLayout
         * @function getTypeUrl
         * @memberof lens.TextLayout
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TextLayout.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.TextLayout";
        };

        TextLayout.Word = (function() {

            /**
             * Properties of a Word.
             * @memberof lens.TextLayout
             * @interface IWord
             * @property {lens.ITextEntityIdentifier|null} [id] Word id
             * @property {string|null} [plainText] Word plainText
             * @property {string|null} [textSeparator] Word textSeparator
             * @property {lens.IGeometry|null} [geometry] Word geometry
             * @property {lens.TextLayout.Word.Type|null} [type] Word type
             * @property {lens.TextLayout.Word.IFormulaMetadata|null} [formulaMetadata] Word formulaMetadata
             */

            /**
             * Constructs a new Word.
             * @memberof lens.TextLayout
             * @classdesc Represents a Word.
             * @implements IWord
             * @constructor
             * @param {lens.TextLayout.IWord=} [properties] Properties to set
             */
            function Word(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Word id.
             * @member {lens.ITextEntityIdentifier|null|undefined} id
             * @memberof lens.TextLayout.Word
             * @instance
             */
            Word.prototype.id = null;

            /**
             * Word plainText.
             * @member {string} plainText
             * @memberof lens.TextLayout.Word
             * @instance
             */
            Word.prototype.plainText = "";

            /**
             * Word textSeparator.
             * @member {string|null|undefined} textSeparator
             * @memberof lens.TextLayout.Word
             * @instance
             */
            Word.prototype.textSeparator = null;

            /**
             * Word geometry.
             * @member {lens.IGeometry|null|undefined} geometry
             * @memberof lens.TextLayout.Word
             * @instance
             */
            Word.prototype.geometry = null;

            /**
             * Word type.
             * @member {lens.TextLayout.Word.Type} type
             * @memberof lens.TextLayout.Word
             * @instance
             */
            Word.prototype.type = 0;

            /**
             * Word formulaMetadata.
             * @member {lens.TextLayout.Word.IFormulaMetadata|null|undefined} formulaMetadata
             * @memberof lens.TextLayout.Word
             * @instance
             */
            Word.prototype.formulaMetadata = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            // Virtual OneOf for proto3 optional field
            Object.defineProperty(Word.prototype, "_textSeparator", {
                get: $util.oneOfGetter($oneOfFields = ["textSeparator"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Word instance using the specified properties.
             * @function create
             * @memberof lens.TextLayout.Word
             * @static
             * @param {lens.TextLayout.IWord=} [properties] Properties to set
             * @returns {lens.TextLayout.Word} Word instance
             */
            Word.create = function create(properties) {
                return new Word(properties);
            };

            /**
             * Encodes the specified Word message. Does not implicitly {@link lens.TextLayout.Word.verify|verify} messages.
             * @function encode
             * @memberof lens.TextLayout.Word
             * @static
             * @param {lens.TextLayout.IWord} message Word message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Word.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    $root.lens.TextEntityIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.plainText != null && Object.hasOwnProperty.call(message, "plainText"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.plainText);
                if (message.textSeparator != null && Object.hasOwnProperty.call(message, "textSeparator"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.textSeparator);
                if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                    $root.lens.Geometry.encode(message.geometry, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.formulaMetadata != null && Object.hasOwnProperty.call(message, "formulaMetadata"))
                    $root.lens.TextLayout.Word.FormulaMetadata.encode(message.formulaMetadata, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Word message, length delimited. Does not implicitly {@link lens.TextLayout.Word.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.TextLayout.Word
             * @static
             * @param {lens.TextLayout.IWord} message Word message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Word.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Word message from the specified reader or buffer.
             * @function decode
             * @memberof lens.TextLayout.Word
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.TextLayout.Word} Word
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Word.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TextLayout.Word();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = $root.lens.TextEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.plainText = reader.string();
                            break;
                        }
                    case 3: {
                            message.textSeparator = reader.string();
                            break;
                        }
                    case 4: {
                            message.geometry = $root.lens.Geometry.decode(reader, reader.uint32());
                            break;
                        }
                    case 5: {
                            message.type = reader.int32();
                            break;
                        }
                    case 6: {
                            message.formulaMetadata = $root.lens.TextLayout.Word.FormulaMetadata.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Word message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.TextLayout.Word
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.TextLayout.Word} Word
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Word.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Word message.
             * @function verify
             * @memberof lens.TextLayout.Word
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Word.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.id != null && message.hasOwnProperty("id")) {
                    var error = $root.lens.TextEntityIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.plainText != null && message.hasOwnProperty("plainText"))
                    if (!$util.isString(message.plainText))
                        return "plainText: string expected";
                if (message.textSeparator != null && message.hasOwnProperty("textSeparator")) {
                    properties._textSeparator = 1;
                    if (!$util.isString(message.textSeparator))
                        return "textSeparator: string expected";
                }
                if (message.geometry != null && message.hasOwnProperty("geometry")) {
                    var error = $root.lens.Geometry.verify(message.geometry);
                    if (error)
                        return "geometry." + error;
                }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                if (message.formulaMetadata != null && message.hasOwnProperty("formulaMetadata")) {
                    var error = $root.lens.TextLayout.Word.FormulaMetadata.verify(message.formulaMetadata);
                    if (error)
                        return "formulaMetadata." + error;
                }
                return null;
            };

            /**
             * Creates a Word message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.TextLayout.Word
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.TextLayout.Word} Word
             */
            Word.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.TextLayout.Word)
                    return object;
                var message = new $root.lens.TextLayout.Word();
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".lens.TextLayout.Word.id: object expected");
                    message.id = $root.lens.TextEntityIdentifier.fromObject(object.id);
                }
                if (object.plainText != null)
                    message.plainText = String(object.plainText);
                if (object.textSeparator != null)
                    message.textSeparator = String(object.textSeparator);
                if (object.geometry != null) {
                    if (typeof object.geometry !== "object")
                        throw TypeError(".lens.TextLayout.Word.geometry: object expected");
                    message.geometry = $root.lens.Geometry.fromObject(object.geometry);
                }
                switch (object.type) {
                default:
                    if (typeof object.type === "number") {
                        message.type = object.type;
                        break;
                    }
                    break;
                case "TEXT":
                case 0:
                    message.type = 0;
                    break;
                case "FORMULA":
                case 1:
                    message.type = 1;
                    break;
                }
                if (object.formulaMetadata != null) {
                    if (typeof object.formulaMetadata !== "object")
                        throw TypeError(".lens.TextLayout.Word.formulaMetadata: object expected");
                    message.formulaMetadata = $root.lens.TextLayout.Word.FormulaMetadata.fromObject(object.formulaMetadata);
                }
                return message;
            };

            /**
             * Creates a plain object from a Word message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.TextLayout.Word
             * @static
             * @param {lens.TextLayout.Word} message Word
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Word.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.id = null;
                    object.plainText = "";
                    object.geometry = null;
                    object.type = options.enums === String ? "TEXT" : 0;
                    object.formulaMetadata = null;
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = $root.lens.TextEntityIdentifier.toObject(message.id, options);
                if (message.plainText != null && message.hasOwnProperty("plainText"))
                    object.plainText = message.plainText;
                if (message.textSeparator != null && message.hasOwnProperty("textSeparator")) {
                    object.textSeparator = message.textSeparator;
                    if (options.oneofs)
                        object._textSeparator = "textSeparator";
                }
                if (message.geometry != null && message.hasOwnProperty("geometry"))
                    object.geometry = $root.lens.Geometry.toObject(message.geometry, options);
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.lens.TextLayout.Word.Type[message.type] === undefined ? message.type : $root.lens.TextLayout.Word.Type[message.type] : message.type;
                if (message.formulaMetadata != null && message.hasOwnProperty("formulaMetadata"))
                    object.formulaMetadata = $root.lens.TextLayout.Word.FormulaMetadata.toObject(message.formulaMetadata, options);
                return object;
            };

            /**
             * Converts this Word to JSON.
             * @function toJSON
             * @memberof lens.TextLayout.Word
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Word.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Word
             * @function getTypeUrl
             * @memberof lens.TextLayout.Word
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Word.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.TextLayout.Word";
            };

            /**
             * Type enum.
             * @name lens.TextLayout.Word.Type
             * @enum {number}
             * @property {number} TEXT=0 TEXT value
             * @property {number} FORMULA=1 FORMULA value
             */
            Word.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "TEXT"] = 0;
                values[valuesById[1] = "FORMULA"] = 1;
                return values;
            })();

            Word.FormulaMetadata = (function() {

                /**
                 * Properties of a FormulaMetadata.
                 * @memberof lens.TextLayout.Word
                 * @interface IFormulaMetadata
                 * @property {string|null} [latex] FormulaMetadata latex
                 */

                /**
                 * Constructs a new FormulaMetadata.
                 * @memberof lens.TextLayout.Word
                 * @classdesc Represents a FormulaMetadata.
                 * @implements IFormulaMetadata
                 * @constructor
                 * @param {lens.TextLayout.Word.IFormulaMetadata=} [properties] Properties to set
                 */
                function FormulaMetadata(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FormulaMetadata latex.
                 * @member {string} latex
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @instance
                 */
                FormulaMetadata.prototype.latex = "";

                /**
                 * Creates a new FormulaMetadata instance using the specified properties.
                 * @function create
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {lens.TextLayout.Word.IFormulaMetadata=} [properties] Properties to set
                 * @returns {lens.TextLayout.Word.FormulaMetadata} FormulaMetadata instance
                 */
                FormulaMetadata.create = function create(properties) {
                    return new FormulaMetadata(properties);
                };

                /**
                 * Encodes the specified FormulaMetadata message. Does not implicitly {@link lens.TextLayout.Word.FormulaMetadata.verify|verify} messages.
                 * @function encode
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {lens.TextLayout.Word.IFormulaMetadata} message FormulaMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FormulaMetadata.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.latex != null && Object.hasOwnProperty.call(message, "latex"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.latex);
                    return writer;
                };

                /**
                 * Encodes the specified FormulaMetadata message, length delimited. Does not implicitly {@link lens.TextLayout.Word.FormulaMetadata.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {lens.TextLayout.Word.IFormulaMetadata} message FormulaMetadata message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FormulaMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FormulaMetadata message from the specified reader or buffer.
                 * @function decode
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lens.TextLayout.Word.FormulaMetadata} FormulaMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FormulaMetadata.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TextLayout.Word.FormulaMetadata();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.latex = reader.string();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FormulaMetadata message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lens.TextLayout.Word.FormulaMetadata} FormulaMetadata
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FormulaMetadata.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FormulaMetadata message.
                 * @function verify
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FormulaMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.latex != null && message.hasOwnProperty("latex"))
                        if (!$util.isString(message.latex))
                            return "latex: string expected";
                    return null;
                };

                /**
                 * Creates a FormulaMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lens.TextLayout.Word.FormulaMetadata} FormulaMetadata
                 */
                FormulaMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.lens.TextLayout.Word.FormulaMetadata)
                        return object;
                    var message = new $root.lens.TextLayout.Word.FormulaMetadata();
                    if (object.latex != null)
                        message.latex = String(object.latex);
                    return message;
                };

                /**
                 * Creates a plain object from a FormulaMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {lens.TextLayout.Word.FormulaMetadata} message FormulaMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FormulaMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.latex = "";
                    if (message.latex != null && message.hasOwnProperty("latex"))
                        object.latex = message.latex;
                    return object;
                };

                /**
                 * Converts this FormulaMetadata to JSON.
                 * @function toJSON
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FormulaMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for FormulaMetadata
                 * @function getTypeUrl
                 * @memberof lens.TextLayout.Word.FormulaMetadata
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                FormulaMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/lens.TextLayout.Word.FormulaMetadata";
                };

                return FormulaMetadata;
            })();

            return Word;
        })();

        TextLayout.Line = (function() {

            /**
             * Properties of a Line.
             * @memberof lens.TextLayout
             * @interface ILine
             * @property {Array.<lens.TextLayout.IWord>|null} [words] Line words
             * @property {lens.IGeometry|null} [geometry] Line geometry
             */

            /**
             * Constructs a new Line.
             * @memberof lens.TextLayout
             * @classdesc Represents a Line.
             * @implements ILine
             * @constructor
             * @param {lens.TextLayout.ILine=} [properties] Properties to set
             */
            function Line(properties) {
                this.words = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Line words.
             * @member {Array.<lens.TextLayout.IWord>} words
             * @memberof lens.TextLayout.Line
             * @instance
             */
            Line.prototype.words = $util.emptyArray;

            /**
             * Line geometry.
             * @member {lens.IGeometry|null|undefined} geometry
             * @memberof lens.TextLayout.Line
             * @instance
             */
            Line.prototype.geometry = null;

            /**
             * Creates a new Line instance using the specified properties.
             * @function create
             * @memberof lens.TextLayout.Line
             * @static
             * @param {lens.TextLayout.ILine=} [properties] Properties to set
             * @returns {lens.TextLayout.Line} Line instance
             */
            Line.create = function create(properties) {
                return new Line(properties);
            };

            /**
             * Encodes the specified Line message. Does not implicitly {@link lens.TextLayout.Line.verify|verify} messages.
             * @function encode
             * @memberof lens.TextLayout.Line
             * @static
             * @param {lens.TextLayout.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.words != null && message.words.length)
                    for (var i = 0; i < message.words.length; ++i)
                        $root.lens.TextLayout.Word.encode(message.words[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                    $root.lens.Geometry.encode(message.geometry, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Line message, length delimited. Does not implicitly {@link lens.TextLayout.Line.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.TextLayout.Line
             * @static
             * @param {lens.TextLayout.ILine} message Line message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Line.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Line message from the specified reader or buffer.
             * @function decode
             * @memberof lens.TextLayout.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.TextLayout.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TextLayout.Line();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            if (!(message.words && message.words.length))
                                message.words = [];
                            message.words.push($root.lens.TextLayout.Word.decode(reader, reader.uint32()));
                            break;
                        }
                    case 2: {
                            message.geometry = $root.lens.Geometry.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Line message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.TextLayout.Line
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.TextLayout.Line} Line
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Line.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Line message.
             * @function verify
             * @memberof lens.TextLayout.Line
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Line.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.words != null && message.hasOwnProperty("words")) {
                    if (!Array.isArray(message.words))
                        return "words: array expected";
                    for (var i = 0; i < message.words.length; ++i) {
                        var error = $root.lens.TextLayout.Word.verify(message.words[i]);
                        if (error)
                            return "words." + error;
                    }
                }
                if (message.geometry != null && message.hasOwnProperty("geometry")) {
                    var error = $root.lens.Geometry.verify(message.geometry);
                    if (error)
                        return "geometry." + error;
                }
                return null;
            };

            /**
             * Creates a Line message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.TextLayout.Line
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.TextLayout.Line} Line
             */
            Line.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.TextLayout.Line)
                    return object;
                var message = new $root.lens.TextLayout.Line();
                if (object.words) {
                    if (!Array.isArray(object.words))
                        throw TypeError(".lens.TextLayout.Line.words: array expected");
                    message.words = [];
                    for (var i = 0; i < object.words.length; ++i) {
                        if (typeof object.words[i] !== "object")
                            throw TypeError(".lens.TextLayout.Line.words: object expected");
                        message.words[i] = $root.lens.TextLayout.Word.fromObject(object.words[i]);
                    }
                }
                if (object.geometry != null) {
                    if (typeof object.geometry !== "object")
                        throw TypeError(".lens.TextLayout.Line.geometry: object expected");
                    message.geometry = $root.lens.Geometry.fromObject(object.geometry);
                }
                return message;
            };

            /**
             * Creates a plain object from a Line message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.TextLayout.Line
             * @static
             * @param {lens.TextLayout.Line} message Line
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Line.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.words = [];
                if (options.defaults)
                    object.geometry = null;
                if (message.words && message.words.length) {
                    object.words = [];
                    for (var j = 0; j < message.words.length; ++j)
                        object.words[j] = $root.lens.TextLayout.Word.toObject(message.words[j], options);
                }
                if (message.geometry != null && message.hasOwnProperty("geometry"))
                    object.geometry = $root.lens.Geometry.toObject(message.geometry, options);
                return object;
            };

            /**
             * Converts this Line to JSON.
             * @function toJSON
             * @memberof lens.TextLayout.Line
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Line.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Line
             * @function getTypeUrl
             * @memberof lens.TextLayout.Line
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Line.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.TextLayout.Line";
            };

            return Line;
        })();

        TextLayout.Paragraph = (function() {

            /**
             * Properties of a Paragraph.
             * @memberof lens.TextLayout
             * @interface IParagraph
             * @property {lens.ITextEntityIdentifier|null} [id] Paragraph id
             * @property {Array.<lens.TextLayout.ILine>|null} [lines] Paragraph lines
             * @property {lens.IGeometry|null} [geometry] Paragraph geometry
             * @property {lens.WritingDirection|null} [writingDirection] Paragraph writingDirection
             * @property {string|null} [contentLanguage] Paragraph contentLanguage
             */

            /**
             * Constructs a new Paragraph.
             * @memberof lens.TextLayout
             * @classdesc Represents a Paragraph.
             * @implements IParagraph
             * @constructor
             * @param {lens.TextLayout.IParagraph=} [properties] Properties to set
             */
            function Paragraph(properties) {
                this.lines = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Paragraph id.
             * @member {lens.ITextEntityIdentifier|null|undefined} id
             * @memberof lens.TextLayout.Paragraph
             * @instance
             */
            Paragraph.prototype.id = null;

            /**
             * Paragraph lines.
             * @member {Array.<lens.TextLayout.ILine>} lines
             * @memberof lens.TextLayout.Paragraph
             * @instance
             */
            Paragraph.prototype.lines = $util.emptyArray;

            /**
             * Paragraph geometry.
             * @member {lens.IGeometry|null|undefined} geometry
             * @memberof lens.TextLayout.Paragraph
             * @instance
             */
            Paragraph.prototype.geometry = null;

            /**
             * Paragraph writingDirection.
             * @member {lens.WritingDirection} writingDirection
             * @memberof lens.TextLayout.Paragraph
             * @instance
             */
            Paragraph.prototype.writingDirection = 0;

            /**
             * Paragraph contentLanguage.
             * @member {string} contentLanguage
             * @memberof lens.TextLayout.Paragraph
             * @instance
             */
            Paragraph.prototype.contentLanguage = "";

            /**
             * Creates a new Paragraph instance using the specified properties.
             * @function create
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {lens.TextLayout.IParagraph=} [properties] Properties to set
             * @returns {lens.TextLayout.Paragraph} Paragraph instance
             */
            Paragraph.create = function create(properties) {
                return new Paragraph(properties);
            };

            /**
             * Encodes the specified Paragraph message. Does not implicitly {@link lens.TextLayout.Paragraph.verify|verify} messages.
             * @function encode
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {lens.TextLayout.IParagraph} message Paragraph message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Paragraph.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    $root.lens.TextEntityIdentifier.encode(message.id, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.lines != null && message.lines.length)
                    for (var i = 0; i < message.lines.length; ++i)
                        $root.lens.TextLayout.Line.encode(message.lines[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                    $root.lens.Geometry.encode(message.geometry, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.writingDirection != null && Object.hasOwnProperty.call(message, "writingDirection"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.writingDirection);
                if (message.contentLanguage != null && Object.hasOwnProperty.call(message, "contentLanguage"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.contentLanguage);
                return writer;
            };

            /**
             * Encodes the specified Paragraph message, length delimited. Does not implicitly {@link lens.TextLayout.Paragraph.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {lens.TextLayout.IParagraph} message Paragraph message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Paragraph.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Paragraph message from the specified reader or buffer.
             * @function decode
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.TextLayout.Paragraph} Paragraph
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Paragraph.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TextLayout.Paragraph();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.id = $root.lens.TextEntityIdentifier.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            if (!(message.lines && message.lines.length))
                                message.lines = [];
                            message.lines.push($root.lens.TextLayout.Line.decode(reader, reader.uint32()));
                            break;
                        }
                    case 3: {
                            message.geometry = $root.lens.Geometry.decode(reader, reader.uint32());
                            break;
                        }
                    case 4: {
                            message.writingDirection = reader.int32();
                            break;
                        }
                    case 5: {
                            message.contentLanguage = reader.string();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Paragraph message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.TextLayout.Paragraph} Paragraph
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Paragraph.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Paragraph message.
             * @function verify
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Paragraph.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id")) {
                    var error = $root.lens.TextEntityIdentifier.verify(message.id);
                    if (error)
                        return "id." + error;
                }
                if (message.lines != null && message.hasOwnProperty("lines")) {
                    if (!Array.isArray(message.lines))
                        return "lines: array expected";
                    for (var i = 0; i < message.lines.length; ++i) {
                        var error = $root.lens.TextLayout.Line.verify(message.lines[i]);
                        if (error)
                            return "lines." + error;
                    }
                }
                if (message.geometry != null && message.hasOwnProperty("geometry")) {
                    var error = $root.lens.Geometry.verify(message.geometry);
                    if (error)
                        return "geometry." + error;
                }
                if (message.writingDirection != null && message.hasOwnProperty("writingDirection"))
                    switch (message.writingDirection) {
                    default:
                        return "writingDirection: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.contentLanguage != null && message.hasOwnProperty("contentLanguage"))
                    if (!$util.isString(message.contentLanguage))
                        return "contentLanguage: string expected";
                return null;
            };

            /**
             * Creates a Paragraph message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.TextLayout.Paragraph} Paragraph
             */
            Paragraph.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.TextLayout.Paragraph)
                    return object;
                var message = new $root.lens.TextLayout.Paragraph();
                if (object.id != null) {
                    if (typeof object.id !== "object")
                        throw TypeError(".lens.TextLayout.Paragraph.id: object expected");
                    message.id = $root.lens.TextEntityIdentifier.fromObject(object.id);
                }
                if (object.lines) {
                    if (!Array.isArray(object.lines))
                        throw TypeError(".lens.TextLayout.Paragraph.lines: array expected");
                    message.lines = [];
                    for (var i = 0; i < object.lines.length; ++i) {
                        if (typeof object.lines[i] !== "object")
                            throw TypeError(".lens.TextLayout.Paragraph.lines: object expected");
                        message.lines[i] = $root.lens.TextLayout.Line.fromObject(object.lines[i]);
                    }
                }
                if (object.geometry != null) {
                    if (typeof object.geometry !== "object")
                        throw TypeError(".lens.TextLayout.Paragraph.geometry: object expected");
                    message.geometry = $root.lens.Geometry.fromObject(object.geometry);
                }
                switch (object.writingDirection) {
                default:
                    if (typeof object.writingDirection === "number") {
                        message.writingDirection = object.writingDirection;
                        break;
                    }
                    break;
                case "DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT":
                case 0:
                    message.writingDirection = 0;
                    break;
                case "WRITING_DIRECTION_RIGHT_TO_LEFT":
                case 1:
                    message.writingDirection = 1;
                    break;
                case "WRITING_DIRECTION_TOP_TO_BOTTOM":
                case 2:
                    message.writingDirection = 2;
                    break;
                }
                if (object.contentLanguage != null)
                    message.contentLanguage = String(object.contentLanguage);
                return message;
            };

            /**
             * Creates a plain object from a Paragraph message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {lens.TextLayout.Paragraph} message Paragraph
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Paragraph.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.lines = [];
                if (options.defaults) {
                    object.id = null;
                    object.geometry = null;
                    object.writingDirection = options.enums === String ? "DEFAULT_WRITING_DIRECTION_LEFT_TO_RIGHT" : 0;
                    object.contentLanguage = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = $root.lens.TextEntityIdentifier.toObject(message.id, options);
                if (message.lines && message.lines.length) {
                    object.lines = [];
                    for (var j = 0; j < message.lines.length; ++j)
                        object.lines[j] = $root.lens.TextLayout.Line.toObject(message.lines[j], options);
                }
                if (message.geometry != null && message.hasOwnProperty("geometry"))
                    object.geometry = $root.lens.Geometry.toObject(message.geometry, options);
                if (message.writingDirection != null && message.hasOwnProperty("writingDirection"))
                    object.writingDirection = options.enums === String ? $root.lens.WritingDirection[message.writingDirection] === undefined ? message.writingDirection : $root.lens.WritingDirection[message.writingDirection] : message.writingDirection;
                if (message.contentLanguage != null && message.hasOwnProperty("contentLanguage"))
                    object.contentLanguage = message.contentLanguage;
                return object;
            };

            /**
             * Converts this Paragraph to JSON.
             * @function toJSON
             * @memberof lens.TextLayout.Paragraph
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Paragraph.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Paragraph
             * @function getTypeUrl
             * @memberof lens.TextLayout.Paragraph
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Paragraph.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.TextLayout.Paragraph";
            };

            return Paragraph;
        })();

        return TextLayout;
    })();

    lens.TextEntityIdentifier = (function() {

        /**
         * Properties of a TextEntityIdentifier.
         * @memberof lens
         * @interface ITextEntityIdentifier
         * @property {number|Long|null} [id] TextEntityIdentifier id
         */

        /**
         * Constructs a new TextEntityIdentifier.
         * @memberof lens
         * @classdesc Represents a TextEntityIdentifier.
         * @implements ITextEntityIdentifier
         * @constructor
         * @param {lens.ITextEntityIdentifier=} [properties] Properties to set
         */
        function TextEntityIdentifier(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TextEntityIdentifier id.
         * @member {number|Long} id
         * @memberof lens.TextEntityIdentifier
         * @instance
         */
        TextEntityIdentifier.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new TextEntityIdentifier instance using the specified properties.
         * @function create
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {lens.ITextEntityIdentifier=} [properties] Properties to set
         * @returns {lens.TextEntityIdentifier} TextEntityIdentifier instance
         */
        TextEntityIdentifier.create = function create(properties) {
            return new TextEntityIdentifier(properties);
        };

        /**
         * Encodes the specified TextEntityIdentifier message. Does not implicitly {@link lens.TextEntityIdentifier.verify|verify} messages.
         * @function encode
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {lens.ITextEntityIdentifier} message TextEntityIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextEntityIdentifier.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.id);
            return writer;
        };

        /**
         * Encodes the specified TextEntityIdentifier message, length delimited. Does not implicitly {@link lens.TextEntityIdentifier.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {lens.ITextEntityIdentifier} message TextEntityIdentifier message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextEntityIdentifier.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextEntityIdentifier message from the specified reader or buffer.
         * @function decode
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.TextEntityIdentifier} TextEntityIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextEntityIdentifier.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TextEntityIdentifier();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextEntityIdentifier message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.TextEntityIdentifier} TextEntityIdentifier
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextEntityIdentifier.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TextEntityIdentifier message.
         * @function verify
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TextEntityIdentifier.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                    return "id: integer|Long expected";
            return null;
        };

        /**
         * Creates a TextEntityIdentifier message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.TextEntityIdentifier} TextEntityIdentifier
         */
        TextEntityIdentifier.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.TextEntityIdentifier)
                return object;
            var message = new $root.lens.TextEntityIdentifier();
            if (object.id != null)
                if ($util.Long)
                    (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                else if (typeof object.id === "string")
                    message.id = parseInt(object.id, 10);
                else if (typeof object.id === "number")
                    message.id = object.id;
                else if (typeof object.id === "object")
                    message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a TextEntityIdentifier message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {lens.TextEntityIdentifier} message TextEntityIdentifier
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TextEntityIdentifier.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.id = options.longs === String ? "0" : 0;
            if (message.id != null && message.hasOwnProperty("id"))
                if (typeof message.id === "number")
                    object.id = options.longs === String ? String(message.id) : message.id;
                else
                    object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
            return object;
        };

        /**
         * Converts this TextEntityIdentifier to JSON.
         * @function toJSON
         * @memberof lens.TextEntityIdentifier
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TextEntityIdentifier.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TextEntityIdentifier
         * @function getTypeUrl
         * @memberof lens.TextEntityIdentifier
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TextEntityIdentifier.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.TextEntityIdentifier";
        };

        return TextEntityIdentifier;
    })();

    lens.CenterRotatedBox = (function() {

        /**
         * Properties of a CenterRotatedBox.
         * @memberof lens
         * @interface ICenterRotatedBox
         * @property {number|null} [centerX] CenterRotatedBox centerX
         * @property {number|null} [centerY] CenterRotatedBox centerY
         * @property {number|null} [width] CenterRotatedBox width
         * @property {number|null} [height] CenterRotatedBox height
         * @property {number|null} [rotationZ] CenterRotatedBox rotationZ
         * @property {lens.CoordinateType|null} [coordinateType] CenterRotatedBox coordinateType
         */

        /**
         * Constructs a new CenterRotatedBox.
         * @memberof lens
         * @classdesc Represents a CenterRotatedBox.
         * @implements ICenterRotatedBox
         * @constructor
         * @param {lens.ICenterRotatedBox=} [properties] Properties to set
         */
        function CenterRotatedBox(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * CenterRotatedBox centerX.
         * @member {number} centerX
         * @memberof lens.CenterRotatedBox
         * @instance
         */
        CenterRotatedBox.prototype.centerX = 0;

        /**
         * CenterRotatedBox centerY.
         * @member {number} centerY
         * @memberof lens.CenterRotatedBox
         * @instance
         */
        CenterRotatedBox.prototype.centerY = 0;

        /**
         * CenterRotatedBox width.
         * @member {number} width
         * @memberof lens.CenterRotatedBox
         * @instance
         */
        CenterRotatedBox.prototype.width = 0;

        /**
         * CenterRotatedBox height.
         * @member {number} height
         * @memberof lens.CenterRotatedBox
         * @instance
         */
        CenterRotatedBox.prototype.height = 0;

        /**
         * CenterRotatedBox rotationZ.
         * @member {number} rotationZ
         * @memberof lens.CenterRotatedBox
         * @instance
         */
        CenterRotatedBox.prototype.rotationZ = 0;

        /**
         * CenterRotatedBox coordinateType.
         * @member {lens.CoordinateType} coordinateType
         * @memberof lens.CenterRotatedBox
         * @instance
         */
        CenterRotatedBox.prototype.coordinateType = 0;

        /**
         * Creates a new CenterRotatedBox instance using the specified properties.
         * @function create
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {lens.ICenterRotatedBox=} [properties] Properties to set
         * @returns {lens.CenterRotatedBox} CenterRotatedBox instance
         */
        CenterRotatedBox.create = function create(properties) {
            return new CenterRotatedBox(properties);
        };

        /**
         * Encodes the specified CenterRotatedBox message. Does not implicitly {@link lens.CenterRotatedBox.verify|verify} messages.
         * @function encode
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {lens.ICenterRotatedBox} message CenterRotatedBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CenterRotatedBox.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.centerX != null && Object.hasOwnProperty.call(message, "centerX"))
                writer.uint32(/* id 1, wireType 5 =*/13).float(message.centerX);
            if (message.centerY != null && Object.hasOwnProperty.call(message, "centerY"))
                writer.uint32(/* id 2, wireType 5 =*/21).float(message.centerY);
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 3, wireType 5 =*/29).float(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.height);
            if (message.rotationZ != null && Object.hasOwnProperty.call(message, "rotationZ"))
                writer.uint32(/* id 5, wireType 5 =*/45).float(message.rotationZ);
            if (message.coordinateType != null && Object.hasOwnProperty.call(message, "coordinateType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.coordinateType);
            return writer;
        };

        /**
         * Encodes the specified CenterRotatedBox message, length delimited. Does not implicitly {@link lens.CenterRotatedBox.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {lens.ICenterRotatedBox} message CenterRotatedBox message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        CenterRotatedBox.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a CenterRotatedBox message from the specified reader or buffer.
         * @function decode
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.CenterRotatedBox} CenterRotatedBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CenterRotatedBox.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.CenterRotatedBox();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.centerX = reader.float();
                        break;
                    }
                case 2: {
                        message.centerY = reader.float();
                        break;
                    }
                case 3: {
                        message.width = reader.float();
                        break;
                    }
                case 4: {
                        message.height = reader.float();
                        break;
                    }
                case 5: {
                        message.rotationZ = reader.float();
                        break;
                    }
                case 6: {
                        message.coordinateType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a CenterRotatedBox message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.CenterRotatedBox} CenterRotatedBox
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        CenterRotatedBox.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a CenterRotatedBox message.
         * @function verify
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        CenterRotatedBox.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.centerX != null && message.hasOwnProperty("centerX"))
                if (typeof message.centerX !== "number")
                    return "centerX: number expected";
            if (message.centerY != null && message.hasOwnProperty("centerY"))
                if (typeof message.centerY !== "number")
                    return "centerY: number expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (typeof message.width !== "number")
                    return "width: number expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (typeof message.height !== "number")
                    return "height: number expected";
            if (message.rotationZ != null && message.hasOwnProperty("rotationZ"))
                if (typeof message.rotationZ !== "number")
                    return "rotationZ: number expected";
            if (message.coordinateType != null && message.hasOwnProperty("coordinateType"))
                switch (message.coordinateType) {
                default:
                    return "coordinateType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a CenterRotatedBox message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.CenterRotatedBox} CenterRotatedBox
         */
        CenterRotatedBox.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.CenterRotatedBox)
                return object;
            var message = new $root.lens.CenterRotatedBox();
            if (object.centerX != null)
                message.centerX = Number(object.centerX);
            if (object.centerY != null)
                message.centerY = Number(object.centerY);
            if (object.width != null)
                message.width = Number(object.width);
            if (object.height != null)
                message.height = Number(object.height);
            if (object.rotationZ != null)
                message.rotationZ = Number(object.rotationZ);
            switch (object.coordinateType) {
            default:
                if (typeof object.coordinateType === "number") {
                    message.coordinateType = object.coordinateType;
                    break;
                }
                break;
            case "COORDINATE_TYPE_UNSPECIFIED":
            case 0:
                message.coordinateType = 0;
                break;
            case "NORMALIZED":
            case 1:
                message.coordinateType = 1;
                break;
            case "IMAGE":
            case 2:
                message.coordinateType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a CenterRotatedBox message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {lens.CenterRotatedBox} message CenterRotatedBox
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        CenterRotatedBox.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.centerX = 0;
                object.centerY = 0;
                object.width = 0;
                object.height = 0;
                object.rotationZ = 0;
                object.coordinateType = options.enums === String ? "COORDINATE_TYPE_UNSPECIFIED" : 0;
            }
            if (message.centerX != null && message.hasOwnProperty("centerX"))
                object.centerX = options.json && !isFinite(message.centerX) ? String(message.centerX) : message.centerX;
            if (message.centerY != null && message.hasOwnProperty("centerY"))
                object.centerY = options.json && !isFinite(message.centerY) ? String(message.centerY) : message.centerY;
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = options.json && !isFinite(message.width) ? String(message.width) : message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = options.json && !isFinite(message.height) ? String(message.height) : message.height;
            if (message.rotationZ != null && message.hasOwnProperty("rotationZ"))
                object.rotationZ = options.json && !isFinite(message.rotationZ) ? String(message.rotationZ) : message.rotationZ;
            if (message.coordinateType != null && message.hasOwnProperty("coordinateType"))
                object.coordinateType = options.enums === String ? $root.lens.CoordinateType[message.coordinateType] === undefined ? message.coordinateType : $root.lens.CoordinateType[message.coordinateType] : message.coordinateType;
            return object;
        };

        /**
         * Converts this CenterRotatedBox to JSON.
         * @function toJSON
         * @memberof lens.CenterRotatedBox
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        CenterRotatedBox.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for CenterRotatedBox
         * @function getTypeUrl
         * @memberof lens.CenterRotatedBox
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        CenterRotatedBox.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.CenterRotatedBox";
        };

        return CenterRotatedBox;
    })();

    lens.Geometry = (function() {

        /**
         * Properties of a Geometry.
         * @memberof lens
         * @interface IGeometry
         * @property {lens.ICenterRotatedBox|null} [boundingBox] Geometry boundingBox
         * @property {Array.<lens.IPolygon>|null} [segmentationPolygon] Geometry segmentationPolygon
         */

        /**
         * Constructs a new Geometry.
         * @memberof lens
         * @classdesc Represents a Geometry.
         * @implements IGeometry
         * @constructor
         * @param {lens.IGeometry=} [properties] Properties to set
         */
        function Geometry(properties) {
            this.segmentationPolygon = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Geometry boundingBox.
         * @member {lens.ICenterRotatedBox|null|undefined} boundingBox
         * @memberof lens.Geometry
         * @instance
         */
        Geometry.prototype.boundingBox = null;

        /**
         * Geometry segmentationPolygon.
         * @member {Array.<lens.IPolygon>} segmentationPolygon
         * @memberof lens.Geometry
         * @instance
         */
        Geometry.prototype.segmentationPolygon = $util.emptyArray;

        /**
         * Creates a new Geometry instance using the specified properties.
         * @function create
         * @memberof lens.Geometry
         * @static
         * @param {lens.IGeometry=} [properties] Properties to set
         * @returns {lens.Geometry} Geometry instance
         */
        Geometry.create = function create(properties) {
            return new Geometry(properties);
        };

        /**
         * Encodes the specified Geometry message. Does not implicitly {@link lens.Geometry.verify|verify} messages.
         * @function encode
         * @memberof lens.Geometry
         * @static
         * @param {lens.IGeometry} message Geometry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Geometry.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.boundingBox != null && Object.hasOwnProperty.call(message, "boundingBox"))
                $root.lens.CenterRotatedBox.encode(message.boundingBox, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.segmentationPolygon != null && message.segmentationPolygon.length)
                for (var i = 0; i < message.segmentationPolygon.length; ++i)
                    $root.lens.Polygon.encode(message.segmentationPolygon[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Geometry message, length delimited. Does not implicitly {@link lens.Geometry.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Geometry
         * @static
         * @param {lens.IGeometry} message Geometry message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Geometry.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Geometry message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Geometry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Geometry} Geometry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Geometry.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Geometry();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.boundingBox = $root.lens.CenterRotatedBox.decode(reader, reader.uint32());
                        break;
                    }
                case 5: {
                        if (!(message.segmentationPolygon && message.segmentationPolygon.length))
                            message.segmentationPolygon = [];
                        message.segmentationPolygon.push($root.lens.Polygon.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Geometry message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Geometry
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Geometry} Geometry
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Geometry.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Geometry message.
         * @function verify
         * @memberof lens.Geometry
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Geometry.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.boundingBox != null && message.hasOwnProperty("boundingBox")) {
                var error = $root.lens.CenterRotatedBox.verify(message.boundingBox);
                if (error)
                    return "boundingBox." + error;
            }
            if (message.segmentationPolygon != null && message.hasOwnProperty("segmentationPolygon")) {
                if (!Array.isArray(message.segmentationPolygon))
                    return "segmentationPolygon: array expected";
                for (var i = 0; i < message.segmentationPolygon.length; ++i) {
                    var error = $root.lens.Polygon.verify(message.segmentationPolygon[i]);
                    if (error)
                        return "segmentationPolygon." + error;
                }
            }
            return null;
        };

        /**
         * Creates a Geometry message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Geometry
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Geometry} Geometry
         */
        Geometry.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Geometry)
                return object;
            var message = new $root.lens.Geometry();
            if (object.boundingBox != null) {
                if (typeof object.boundingBox !== "object")
                    throw TypeError(".lens.Geometry.boundingBox: object expected");
                message.boundingBox = $root.lens.CenterRotatedBox.fromObject(object.boundingBox);
            }
            if (object.segmentationPolygon) {
                if (!Array.isArray(object.segmentationPolygon))
                    throw TypeError(".lens.Geometry.segmentationPolygon: array expected");
                message.segmentationPolygon = [];
                for (var i = 0; i < object.segmentationPolygon.length; ++i) {
                    if (typeof object.segmentationPolygon[i] !== "object")
                        throw TypeError(".lens.Geometry.segmentationPolygon: object expected");
                    message.segmentationPolygon[i] = $root.lens.Polygon.fromObject(object.segmentationPolygon[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a Geometry message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Geometry
         * @static
         * @param {lens.Geometry} message Geometry
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Geometry.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.segmentationPolygon = [];
            if (options.defaults)
                object.boundingBox = null;
            if (message.boundingBox != null && message.hasOwnProperty("boundingBox"))
                object.boundingBox = $root.lens.CenterRotatedBox.toObject(message.boundingBox, options);
            if (message.segmentationPolygon && message.segmentationPolygon.length) {
                object.segmentationPolygon = [];
                for (var j = 0; j < message.segmentationPolygon.length; ++j)
                    object.segmentationPolygon[j] = $root.lens.Polygon.toObject(message.segmentationPolygon[j], options);
            }
            return object;
        };

        /**
         * Converts this Geometry to JSON.
         * @function toJSON
         * @memberof lens.Geometry
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Geometry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Geometry
         * @function getTypeUrl
         * @memberof lens.Geometry
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Geometry.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Geometry";
        };

        return Geometry;
    })();

    lens.ZoomedCrop = (function() {

        /**
         * Properties of a ZoomedCrop.
         * @memberof lens
         * @interface IZoomedCrop
         * @property {lens.ICenterRotatedBox|null} [crop] ZoomedCrop crop
         * @property {number|null} [parentWidth] ZoomedCrop parentWidth
         * @property {number|null} [parentHeight] ZoomedCrop parentHeight
         * @property {number|null} [zoom] ZoomedCrop zoom
         */

        /**
         * Constructs a new ZoomedCrop.
         * @memberof lens
         * @classdesc Represents a ZoomedCrop.
         * @implements IZoomedCrop
         * @constructor
         * @param {lens.IZoomedCrop=} [properties] Properties to set
         */
        function ZoomedCrop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ZoomedCrop crop.
         * @member {lens.ICenterRotatedBox|null|undefined} crop
         * @memberof lens.ZoomedCrop
         * @instance
         */
        ZoomedCrop.prototype.crop = null;

        /**
         * ZoomedCrop parentWidth.
         * @member {number} parentWidth
         * @memberof lens.ZoomedCrop
         * @instance
         */
        ZoomedCrop.prototype.parentWidth = 0;

        /**
         * ZoomedCrop parentHeight.
         * @member {number} parentHeight
         * @memberof lens.ZoomedCrop
         * @instance
         */
        ZoomedCrop.prototype.parentHeight = 0;

        /**
         * ZoomedCrop zoom.
         * @member {number} zoom
         * @memberof lens.ZoomedCrop
         * @instance
         */
        ZoomedCrop.prototype.zoom = 0;

        /**
         * Creates a new ZoomedCrop instance using the specified properties.
         * @function create
         * @memberof lens.ZoomedCrop
         * @static
         * @param {lens.IZoomedCrop=} [properties] Properties to set
         * @returns {lens.ZoomedCrop} ZoomedCrop instance
         */
        ZoomedCrop.create = function create(properties) {
            return new ZoomedCrop(properties);
        };

        /**
         * Encodes the specified ZoomedCrop message. Does not implicitly {@link lens.ZoomedCrop.verify|verify} messages.
         * @function encode
         * @memberof lens.ZoomedCrop
         * @static
         * @param {lens.IZoomedCrop} message ZoomedCrop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZoomedCrop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.crop != null && Object.hasOwnProperty.call(message, "crop"))
                $root.lens.CenterRotatedBox.encode(message.crop, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.parentWidth != null && Object.hasOwnProperty.call(message, "parentWidth"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.parentWidth);
            if (message.parentHeight != null && Object.hasOwnProperty.call(message, "parentHeight"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.parentHeight);
            if (message.zoom != null && Object.hasOwnProperty.call(message, "zoom"))
                writer.uint32(/* id 4, wireType 5 =*/37).float(message.zoom);
            return writer;
        };

        /**
         * Encodes the specified ZoomedCrop message, length delimited. Does not implicitly {@link lens.ZoomedCrop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ZoomedCrop
         * @static
         * @param {lens.IZoomedCrop} message ZoomedCrop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ZoomedCrop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ZoomedCrop message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ZoomedCrop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ZoomedCrop} ZoomedCrop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZoomedCrop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ZoomedCrop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.crop = $root.lens.CenterRotatedBox.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.parentWidth = reader.int32();
                        break;
                    }
                case 3: {
                        message.parentHeight = reader.int32();
                        break;
                    }
                case 4: {
                        message.zoom = reader.float();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ZoomedCrop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ZoomedCrop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ZoomedCrop} ZoomedCrop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ZoomedCrop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ZoomedCrop message.
         * @function verify
         * @memberof lens.ZoomedCrop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ZoomedCrop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.crop != null && message.hasOwnProperty("crop")) {
                var error = $root.lens.CenterRotatedBox.verify(message.crop);
                if (error)
                    return "crop." + error;
            }
            if (message.parentWidth != null && message.hasOwnProperty("parentWidth"))
                if (!$util.isInteger(message.parentWidth))
                    return "parentWidth: integer expected";
            if (message.parentHeight != null && message.hasOwnProperty("parentHeight"))
                if (!$util.isInteger(message.parentHeight))
                    return "parentHeight: integer expected";
            if (message.zoom != null && message.hasOwnProperty("zoom"))
                if (typeof message.zoom !== "number")
                    return "zoom: number expected";
            return null;
        };

        /**
         * Creates a ZoomedCrop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ZoomedCrop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ZoomedCrop} ZoomedCrop
         */
        ZoomedCrop.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ZoomedCrop)
                return object;
            var message = new $root.lens.ZoomedCrop();
            if (object.crop != null) {
                if (typeof object.crop !== "object")
                    throw TypeError(".lens.ZoomedCrop.crop: object expected");
                message.crop = $root.lens.CenterRotatedBox.fromObject(object.crop);
            }
            if (object.parentWidth != null)
                message.parentWidth = object.parentWidth | 0;
            if (object.parentHeight != null)
                message.parentHeight = object.parentHeight | 0;
            if (object.zoom != null)
                message.zoom = Number(object.zoom);
            return message;
        };

        /**
         * Creates a plain object from a ZoomedCrop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ZoomedCrop
         * @static
         * @param {lens.ZoomedCrop} message ZoomedCrop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ZoomedCrop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.crop = null;
                object.parentWidth = 0;
                object.parentHeight = 0;
                object.zoom = 0;
            }
            if (message.crop != null && message.hasOwnProperty("crop"))
                object.crop = $root.lens.CenterRotatedBox.toObject(message.crop, options);
            if (message.parentWidth != null && message.hasOwnProperty("parentWidth"))
                object.parentWidth = message.parentWidth;
            if (message.parentHeight != null && message.hasOwnProperty("parentHeight"))
                object.parentHeight = message.parentHeight;
            if (message.zoom != null && message.hasOwnProperty("zoom"))
                object.zoom = options.json && !isFinite(message.zoom) ? String(message.zoom) : message.zoom;
            return object;
        };

        /**
         * Converts this ZoomedCrop to JSON.
         * @function toJSON
         * @memberof lens.ZoomedCrop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ZoomedCrop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ZoomedCrop
         * @function getTypeUrl
         * @memberof lens.ZoomedCrop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ZoomedCrop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ZoomedCrop";
        };

        return ZoomedCrop;
    })();

    /**
     * CoordinateType enum.
     * @name lens.CoordinateType
     * @enum {number}
     * @property {number} COORDINATE_TYPE_UNSPECIFIED=0 COORDINATE_TYPE_UNSPECIFIED value
     * @property {number} NORMALIZED=1 NORMALIZED value
     * @property {number} IMAGE=2 IMAGE value
     */
    lens.CoordinateType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "COORDINATE_TYPE_UNSPECIFIED"] = 0;
        values[valuesById[1] = "NORMALIZED"] = 1;
        values[valuesById[2] = "IMAGE"] = 2;
        return values;
    })();

    lens.Polygon = (function() {

        /**
         * Properties of a Polygon.
         * @memberof lens
         * @interface IPolygon
         * @property {Array.<lens.Polygon.IVertex>|null} [vertex] Polygon vertex
         * @property {lens.Polygon.VertexOrdering|null} [vertexOrdering] Polygon vertexOrdering
         * @property {lens.CoordinateType|null} [coordinateType] Polygon coordinateType
         */

        /**
         * Constructs a new Polygon.
         * @memberof lens
         * @classdesc Represents a Polygon.
         * @implements IPolygon
         * @constructor
         * @param {lens.IPolygon=} [properties] Properties to set
         */
        function Polygon(properties) {
            this.vertex = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Polygon vertex.
         * @member {Array.<lens.Polygon.IVertex>} vertex
         * @memberof lens.Polygon
         * @instance
         */
        Polygon.prototype.vertex = $util.emptyArray;

        /**
         * Polygon vertexOrdering.
         * @member {lens.Polygon.VertexOrdering} vertexOrdering
         * @memberof lens.Polygon
         * @instance
         */
        Polygon.prototype.vertexOrdering = 0;

        /**
         * Polygon coordinateType.
         * @member {lens.CoordinateType} coordinateType
         * @memberof lens.Polygon
         * @instance
         */
        Polygon.prototype.coordinateType = 0;

        /**
         * Creates a new Polygon instance using the specified properties.
         * @function create
         * @memberof lens.Polygon
         * @static
         * @param {lens.IPolygon=} [properties] Properties to set
         * @returns {lens.Polygon} Polygon instance
         */
        Polygon.create = function create(properties) {
            return new Polygon(properties);
        };

        /**
         * Encodes the specified Polygon message. Does not implicitly {@link lens.Polygon.verify|verify} messages.
         * @function encode
         * @memberof lens.Polygon
         * @static
         * @param {lens.IPolygon} message Polygon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Polygon.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.vertex != null && message.vertex.length)
                for (var i = 0; i < message.vertex.length; ++i)
                    $root.lens.Polygon.Vertex.encode(message.vertex[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.vertexOrdering != null && Object.hasOwnProperty.call(message, "vertexOrdering"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.vertexOrdering);
            if (message.coordinateType != null && Object.hasOwnProperty.call(message, "coordinateType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.coordinateType);
            return writer;
        };

        /**
         * Encodes the specified Polygon message, length delimited. Does not implicitly {@link lens.Polygon.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Polygon
         * @static
         * @param {lens.IPolygon} message Polygon message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Polygon.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Polygon message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Polygon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Polygon} Polygon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Polygon.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Polygon();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.vertex && message.vertex.length))
                            message.vertex = [];
                        message.vertex.push($root.lens.Polygon.Vertex.decode(reader, reader.uint32()));
                        break;
                    }
                case 2: {
                        message.vertexOrdering = reader.int32();
                        break;
                    }
                case 3: {
                        message.coordinateType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Polygon message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Polygon
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Polygon} Polygon
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Polygon.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Polygon message.
         * @function verify
         * @memberof lens.Polygon
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Polygon.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.vertex != null && message.hasOwnProperty("vertex")) {
                if (!Array.isArray(message.vertex))
                    return "vertex: array expected";
                for (var i = 0; i < message.vertex.length; ++i) {
                    var error = $root.lens.Polygon.Vertex.verify(message.vertex[i]);
                    if (error)
                        return "vertex." + error;
                }
            }
            if (message.vertexOrdering != null && message.hasOwnProperty("vertexOrdering"))
                switch (message.vertexOrdering) {
                default:
                    return "vertexOrdering: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            if (message.coordinateType != null && message.hasOwnProperty("coordinateType"))
                switch (message.coordinateType) {
                default:
                    return "coordinateType: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Polygon message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Polygon
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Polygon} Polygon
         */
        Polygon.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Polygon)
                return object;
            var message = new $root.lens.Polygon();
            if (object.vertex) {
                if (!Array.isArray(object.vertex))
                    throw TypeError(".lens.Polygon.vertex: array expected");
                message.vertex = [];
                for (var i = 0; i < object.vertex.length; ++i) {
                    if (typeof object.vertex[i] !== "object")
                        throw TypeError(".lens.Polygon.vertex: object expected");
                    message.vertex[i] = $root.lens.Polygon.Vertex.fromObject(object.vertex[i]);
                }
            }
            switch (object.vertexOrdering) {
            default:
                if (typeof object.vertexOrdering === "number") {
                    message.vertexOrdering = object.vertexOrdering;
                    break;
                }
                break;
            case "VERTEX_ORDERING_UNSPECIFIED":
            case 0:
                message.vertexOrdering = 0;
                break;
            case "CLOCKWISE":
            case 1:
                message.vertexOrdering = 1;
                break;
            case "COUNTER_CLOCKWISE":
            case 2:
                message.vertexOrdering = 2;
                break;
            }
            switch (object.coordinateType) {
            default:
                if (typeof object.coordinateType === "number") {
                    message.coordinateType = object.coordinateType;
                    break;
                }
                break;
            case "COORDINATE_TYPE_UNSPECIFIED":
            case 0:
                message.coordinateType = 0;
                break;
            case "NORMALIZED":
            case 1:
                message.coordinateType = 1;
                break;
            case "IMAGE":
            case 2:
                message.coordinateType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Polygon message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Polygon
         * @static
         * @param {lens.Polygon} message Polygon
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Polygon.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.vertex = [];
            if (options.defaults) {
                object.vertexOrdering = options.enums === String ? "VERTEX_ORDERING_UNSPECIFIED" : 0;
                object.coordinateType = options.enums === String ? "COORDINATE_TYPE_UNSPECIFIED" : 0;
            }
            if (message.vertex && message.vertex.length) {
                object.vertex = [];
                for (var j = 0; j < message.vertex.length; ++j)
                    object.vertex[j] = $root.lens.Polygon.Vertex.toObject(message.vertex[j], options);
            }
            if (message.vertexOrdering != null && message.hasOwnProperty("vertexOrdering"))
                object.vertexOrdering = options.enums === String ? $root.lens.Polygon.VertexOrdering[message.vertexOrdering] === undefined ? message.vertexOrdering : $root.lens.Polygon.VertexOrdering[message.vertexOrdering] : message.vertexOrdering;
            if (message.coordinateType != null && message.hasOwnProperty("coordinateType"))
                object.coordinateType = options.enums === String ? $root.lens.CoordinateType[message.coordinateType] === undefined ? message.coordinateType : $root.lens.CoordinateType[message.coordinateType] : message.coordinateType;
            return object;
        };

        /**
         * Converts this Polygon to JSON.
         * @function toJSON
         * @memberof lens.Polygon
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Polygon.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Polygon
         * @function getTypeUrl
         * @memberof lens.Polygon
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Polygon.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Polygon";
        };

        Polygon.Vertex = (function() {

            /**
             * Properties of a Vertex.
             * @memberof lens.Polygon
             * @interface IVertex
             * @property {number|null} [x] Vertex x
             * @property {number|null} [y] Vertex y
             */

            /**
             * Constructs a new Vertex.
             * @memberof lens.Polygon
             * @classdesc Represents a Vertex.
             * @implements IVertex
             * @constructor
             * @param {lens.Polygon.IVertex=} [properties] Properties to set
             */
            function Vertex(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Vertex x.
             * @member {number} x
             * @memberof lens.Polygon.Vertex
             * @instance
             */
            Vertex.prototype.x = 0;

            /**
             * Vertex y.
             * @member {number} y
             * @memberof lens.Polygon.Vertex
             * @instance
             */
            Vertex.prototype.y = 0;

            /**
             * Creates a new Vertex instance using the specified properties.
             * @function create
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {lens.Polygon.IVertex=} [properties] Properties to set
             * @returns {lens.Polygon.Vertex} Vertex instance
             */
            Vertex.create = function create(properties) {
                return new Vertex(properties);
            };

            /**
             * Encodes the specified Vertex message. Does not implicitly {@link lens.Polygon.Vertex.verify|verify} messages.
             * @function encode
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {lens.Polygon.IVertex} message Vertex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vertex.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                    writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                    writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                return writer;
            };

            /**
             * Encodes the specified Vertex message, length delimited. Does not implicitly {@link lens.Polygon.Vertex.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {lens.Polygon.IVertex} message Vertex message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Vertex.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Vertex message from the specified reader or buffer.
             * @function decode
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.Polygon.Vertex} Vertex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vertex.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Polygon.Vertex();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.x = reader.float();
                            break;
                        }
                    case 2: {
                            message.y = reader.float();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Vertex message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.Polygon.Vertex} Vertex
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Vertex.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Vertex message.
             * @function verify
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Vertex.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.x != null && message.hasOwnProperty("x"))
                    if (typeof message.x !== "number")
                        return "x: number expected";
                if (message.y != null && message.hasOwnProperty("y"))
                    if (typeof message.y !== "number")
                        return "y: number expected";
                return null;
            };

            /**
             * Creates a Vertex message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.Polygon.Vertex} Vertex
             */
            Vertex.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.Polygon.Vertex)
                    return object;
                var message = new $root.lens.Polygon.Vertex();
                if (object.x != null)
                    message.x = Number(object.x);
                if (object.y != null)
                    message.y = Number(object.y);
                return message;
            };

            /**
             * Creates a plain object from a Vertex message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {lens.Polygon.Vertex} message Vertex
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Vertex.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.x = 0;
                    object.y = 0;
                }
                if (message.x != null && message.hasOwnProperty("x"))
                    object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                if (message.y != null && message.hasOwnProperty("y"))
                    object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                return object;
            };

            /**
             * Converts this Vertex to JSON.
             * @function toJSON
             * @memberof lens.Polygon.Vertex
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Vertex.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for Vertex
             * @function getTypeUrl
             * @memberof lens.Polygon.Vertex
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            Vertex.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.Polygon.Vertex";
            };

            return Vertex;
        })();

        /**
         * VertexOrdering enum.
         * @name lens.Polygon.VertexOrdering
         * @enum {number}
         * @property {number} VERTEX_ORDERING_UNSPECIFIED=0 VERTEX_ORDERING_UNSPECIFIED value
         * @property {number} CLOCKWISE=1 CLOCKWISE value
         * @property {number} COUNTER_CLOCKWISE=2 COUNTER_CLOCKWISE value
         */
        Polygon.VertexOrdering = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "VERTEX_ORDERING_UNSPECIFIED"] = 0;
            values[valuesById[1] = "CLOCKWISE"] = 1;
            values[valuesById[2] = "COUNTER_CLOCKWISE"] = 2;
            return values;
        })();

        return Polygon;
    })();

    lens.LensOverlayDocument = (function() {

        /**
         * Properties of a LensOverlayDocument.
         * @memberof lens
         * @interface ILensOverlayDocument
         * @property {Array.<lens.IPage>|null} [pages] LensOverlayDocument pages
         */

        /**
         * Constructs a new LensOverlayDocument.
         * @memberof lens
         * @classdesc Represents a LensOverlayDocument.
         * @implements ILensOverlayDocument
         * @constructor
         * @param {lens.ILensOverlayDocument=} [properties] Properties to set
         */
        function LensOverlayDocument(properties) {
            this.pages = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayDocument pages.
         * @member {Array.<lens.IPage>} pages
         * @memberof lens.LensOverlayDocument
         * @instance
         */
        LensOverlayDocument.prototype.pages = $util.emptyArray;

        /**
         * Creates a new LensOverlayDocument instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {lens.ILensOverlayDocument=} [properties] Properties to set
         * @returns {lens.LensOverlayDocument} LensOverlayDocument instance
         */
        LensOverlayDocument.create = function create(properties) {
            return new LensOverlayDocument(properties);
        };

        /**
         * Encodes the specified LensOverlayDocument message. Does not implicitly {@link lens.LensOverlayDocument.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {lens.ILensOverlayDocument} message LensOverlayDocument message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayDocument.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pages != null && message.pages.length)
                for (var i = 0; i < message.pages.length; ++i)
                    $root.lens.Page.encode(message.pages[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayDocument message, length delimited. Does not implicitly {@link lens.LensOverlayDocument.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {lens.ILensOverlayDocument} message LensOverlayDocument message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayDocument.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayDocument message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayDocument} LensOverlayDocument
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayDocument.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayDocument();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.pages && message.pages.length))
                            message.pages = [];
                        message.pages.push($root.lens.Page.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayDocument message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayDocument} LensOverlayDocument
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayDocument.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayDocument message.
         * @function verify
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayDocument.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pages != null && message.hasOwnProperty("pages")) {
                if (!Array.isArray(message.pages))
                    return "pages: array expected";
                for (var i = 0; i < message.pages.length; ++i) {
                    var error = $root.lens.Page.verify(message.pages[i]);
                    if (error)
                        return "pages." + error;
                }
            }
            return null;
        };

        /**
         * Creates a LensOverlayDocument message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayDocument} LensOverlayDocument
         */
        LensOverlayDocument.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayDocument)
                return object;
            var message = new $root.lens.LensOverlayDocument();
            if (object.pages) {
                if (!Array.isArray(object.pages))
                    throw TypeError(".lens.LensOverlayDocument.pages: array expected");
                message.pages = [];
                for (var i = 0; i < object.pages.length; ++i) {
                    if (typeof object.pages[i] !== "object")
                        throw TypeError(".lens.LensOverlayDocument.pages: object expected");
                    message.pages[i] = $root.lens.Page.fromObject(object.pages[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayDocument message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {lens.LensOverlayDocument} message LensOverlayDocument
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayDocument.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.pages = [];
            if (message.pages && message.pages.length) {
                object.pages = [];
                for (var j = 0; j < message.pages.length; ++j)
                    object.pages[j] = $root.lens.Page.toObject(message.pages[j], options);
            }
            return object;
        };

        /**
         * Converts this LensOverlayDocument to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayDocument
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayDocument.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayDocument
         * @function getTypeUrl
         * @memberof lens.LensOverlayDocument
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayDocument.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayDocument";
        };

        return LensOverlayDocument;
    })();

    lens.Page = (function() {

        /**
         * Properties of a Page.
         * @memberof lens
         * @interface IPage
         * @property {number|null} [pageNumber] Page pageNumber
         * @property {Array.<string>|null} [textSegments] Page textSegments
         */

        /**
         * Constructs a new Page.
         * @memberof lens
         * @classdesc Represents a Page.
         * @implements IPage
         * @constructor
         * @param {lens.IPage=} [properties] Properties to set
         */
        function Page(properties) {
            this.textSegments = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Page pageNumber.
         * @member {number} pageNumber
         * @memberof lens.Page
         * @instance
         */
        Page.prototype.pageNumber = 0;

        /**
         * Page textSegments.
         * @member {Array.<string>} textSegments
         * @memberof lens.Page
         * @instance
         */
        Page.prototype.textSegments = $util.emptyArray;

        /**
         * Creates a new Page instance using the specified properties.
         * @function create
         * @memberof lens.Page
         * @static
         * @param {lens.IPage=} [properties] Properties to set
         * @returns {lens.Page} Page instance
         */
        Page.create = function create(properties) {
            return new Page(properties);
        };

        /**
         * Encodes the specified Page message. Does not implicitly {@link lens.Page.verify|verify} messages.
         * @function encode
         * @memberof lens.Page
         * @static
         * @param {lens.IPage} message Page message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Page.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.pageNumber != null && Object.hasOwnProperty.call(message, "pageNumber"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.pageNumber);
            if (message.textSegments != null && message.textSegments.length)
                for (var i = 0; i < message.textSegments.length; ++i)
                    writer.uint32(/* id 4, wireType 2 =*/34).string(message.textSegments[i]);
            return writer;
        };

        /**
         * Encodes the specified Page message, length delimited. Does not implicitly {@link lens.Page.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Page
         * @static
         * @param {lens.IPage} message Page message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Page.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Page message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Page
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Page} Page
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Page.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Page();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.pageNumber = reader.int32();
                        break;
                    }
                case 4: {
                        if (!(message.textSegments && message.textSegments.length))
                            message.textSegments = [];
                        message.textSegments.push(reader.string());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Page message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Page
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Page} Page
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Page.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Page message.
         * @function verify
         * @memberof lens.Page
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Page.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.pageNumber != null && message.hasOwnProperty("pageNumber"))
                if (!$util.isInteger(message.pageNumber))
                    return "pageNumber: integer expected";
            if (message.textSegments != null && message.hasOwnProperty("textSegments")) {
                if (!Array.isArray(message.textSegments))
                    return "textSegments: array expected";
                for (var i = 0; i < message.textSegments.length; ++i)
                    if (!$util.isString(message.textSegments[i]))
                        return "textSegments: string[] expected";
            }
            return null;
        };

        /**
         * Creates a Page message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Page
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Page} Page
         */
        Page.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Page)
                return object;
            var message = new $root.lens.Page();
            if (object.pageNumber != null)
                message.pageNumber = object.pageNumber | 0;
            if (object.textSegments) {
                if (!Array.isArray(object.textSegments))
                    throw TypeError(".lens.Page.textSegments: array expected");
                message.textSegments = [];
                for (var i = 0; i < object.textSegments.length; ++i)
                    message.textSegments[i] = String(object.textSegments[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a Page message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Page
         * @static
         * @param {lens.Page} message Page
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Page.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.textSegments = [];
            if (options.defaults)
                object.pageNumber = 0;
            if (message.pageNumber != null && message.hasOwnProperty("pageNumber"))
                object.pageNumber = message.pageNumber;
            if (message.textSegments && message.textSegments.length) {
                object.textSegments = [];
                for (var j = 0; j < message.textSegments.length; ++j)
                    object.textSegments[j] = message.textSegments[j];
            }
            return object;
        };

        /**
         * Converts this Page to JSON.
         * @function toJSON
         * @memberof lens.Page
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Page.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Page
         * @function getTypeUrl
         * @memberof lens.Page
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Page.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Page";
        };

        return Page;
    })();

    lens.ImageCrop = (function() {

        /**
         * Properties of an ImageCrop.
         * @memberof lens
         * @interface IImageCrop
         * @property {string|null} [cropId] ImageCrop cropId
         * @property {lens.IClientImage|null} [image] ImageCrop image
         * @property {lens.IZoomedCrop|null} [zoomedCrop] ImageCrop zoomedCrop
         */

        /**
         * Constructs a new ImageCrop.
         * @memberof lens
         * @classdesc Represents an ImageCrop.
         * @implements IImageCrop
         * @constructor
         * @param {lens.IImageCrop=} [properties] Properties to set
         */
        function ImageCrop(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImageCrop cropId.
         * @member {string} cropId
         * @memberof lens.ImageCrop
         * @instance
         */
        ImageCrop.prototype.cropId = "";

        /**
         * ImageCrop image.
         * @member {lens.IClientImage|null|undefined} image
         * @memberof lens.ImageCrop
         * @instance
         */
        ImageCrop.prototype.image = null;

        /**
         * ImageCrop zoomedCrop.
         * @member {lens.IZoomedCrop|null|undefined} zoomedCrop
         * @memberof lens.ImageCrop
         * @instance
         */
        ImageCrop.prototype.zoomedCrop = null;

        /**
         * Creates a new ImageCrop instance using the specified properties.
         * @function create
         * @memberof lens.ImageCrop
         * @static
         * @param {lens.IImageCrop=} [properties] Properties to set
         * @returns {lens.ImageCrop} ImageCrop instance
         */
        ImageCrop.create = function create(properties) {
            return new ImageCrop(properties);
        };

        /**
         * Encodes the specified ImageCrop message. Does not implicitly {@link lens.ImageCrop.verify|verify} messages.
         * @function encode
         * @memberof lens.ImageCrop
         * @static
         * @param {lens.IImageCrop} message ImageCrop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageCrop.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.cropId != null && Object.hasOwnProperty.call(message, "cropId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.cropId);
            if (message.image != null && Object.hasOwnProperty.call(message, "image"))
                $root.lens.ClientImage.encode(message.image, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.zoomedCrop != null && Object.hasOwnProperty.call(message, "zoomedCrop"))
                $root.lens.ZoomedCrop.encode(message.zoomedCrop, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImageCrop message, length delimited. Does not implicitly {@link lens.ImageCrop.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ImageCrop
         * @static
         * @param {lens.IImageCrop} message ImageCrop message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageCrop.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImageCrop message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ImageCrop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ImageCrop} ImageCrop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageCrop.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ImageCrop();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.cropId = reader.string();
                        break;
                    }
                case 2: {
                        message.image = $root.lens.ClientImage.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.zoomedCrop = $root.lens.ZoomedCrop.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImageCrop message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ImageCrop
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ImageCrop} ImageCrop
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageCrop.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImageCrop message.
         * @function verify
         * @memberof lens.ImageCrop
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageCrop.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.cropId != null && message.hasOwnProperty("cropId"))
                if (!$util.isString(message.cropId))
                    return "cropId: string expected";
            if (message.image != null && message.hasOwnProperty("image")) {
                var error = $root.lens.ClientImage.verify(message.image);
                if (error)
                    return "image." + error;
            }
            if (message.zoomedCrop != null && message.hasOwnProperty("zoomedCrop")) {
                var error = $root.lens.ZoomedCrop.verify(message.zoomedCrop);
                if (error)
                    return "zoomedCrop." + error;
            }
            return null;
        };

        /**
         * Creates an ImageCrop message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ImageCrop
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ImageCrop} ImageCrop
         */
        ImageCrop.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ImageCrop)
                return object;
            var message = new $root.lens.ImageCrop();
            if (object.cropId != null)
                message.cropId = String(object.cropId);
            if (object.image != null) {
                if (typeof object.image !== "object")
                    throw TypeError(".lens.ImageCrop.image: object expected");
                message.image = $root.lens.ClientImage.fromObject(object.image);
            }
            if (object.zoomedCrop != null) {
                if (typeof object.zoomedCrop !== "object")
                    throw TypeError(".lens.ImageCrop.zoomedCrop: object expected");
                message.zoomedCrop = $root.lens.ZoomedCrop.fromObject(object.zoomedCrop);
            }
            return message;
        };

        /**
         * Creates a plain object from an ImageCrop message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ImageCrop
         * @static
         * @param {lens.ImageCrop} message ImageCrop
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageCrop.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.cropId = "";
                object.image = null;
                object.zoomedCrop = null;
            }
            if (message.cropId != null && message.hasOwnProperty("cropId"))
                object.cropId = message.cropId;
            if (message.image != null && message.hasOwnProperty("image"))
                object.image = $root.lens.ClientImage.toObject(message.image, options);
            if (message.zoomedCrop != null && message.hasOwnProperty("zoomedCrop"))
                object.zoomedCrop = $root.lens.ZoomedCrop.toObject(message.zoomedCrop, options);
            return object;
        };

        /**
         * Converts this ImageCrop to JSON.
         * @function toJSON
         * @memberof lens.ImageCrop
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageCrop.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImageCrop
         * @function getTypeUrl
         * @memberof lens.ImageCrop
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImageCrop.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ImageCrop";
        };

        return ImageCrop;
    })();

    lens.ClientImage = (function() {

        /**
         * Properties of a ClientImage.
         * @memberof lens
         * @interface IClientImage
         * @property {Uint8Array|null} [imageContent] ClientImage imageContent
         */

        /**
         * Constructs a new ClientImage.
         * @memberof lens
         * @classdesc Represents a ClientImage.
         * @implements IClientImage
         * @constructor
         * @param {lens.IClientImage=} [properties] Properties to set
         */
        function ClientImage(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ClientImage imageContent.
         * @member {Uint8Array} imageContent
         * @memberof lens.ClientImage
         * @instance
         */
        ClientImage.prototype.imageContent = $util.newBuffer([]);

        /**
         * Creates a new ClientImage instance using the specified properties.
         * @function create
         * @memberof lens.ClientImage
         * @static
         * @param {lens.IClientImage=} [properties] Properties to set
         * @returns {lens.ClientImage} ClientImage instance
         */
        ClientImage.create = function create(properties) {
            return new ClientImage(properties);
        };

        /**
         * Encodes the specified ClientImage message. Does not implicitly {@link lens.ClientImage.verify|verify} messages.
         * @function encode
         * @memberof lens.ClientImage
         * @static
         * @param {lens.IClientImage} message ClientImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientImage.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.imageContent != null && Object.hasOwnProperty.call(message, "imageContent"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.imageContent);
            return writer;
        };

        /**
         * Encodes the specified ClientImage message, length delimited. Does not implicitly {@link lens.ClientImage.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ClientImage
         * @static
         * @param {lens.IClientImage} message ClientImage message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ClientImage.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ClientImage message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ClientImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ClientImage} ClientImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientImage.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ClientImage();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.imageContent = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ClientImage message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ClientImage
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ClientImage} ClientImage
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ClientImage.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ClientImage message.
         * @function verify
         * @memberof lens.ClientImage
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ClientImage.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.imageContent != null && message.hasOwnProperty("imageContent"))
                if (!(message.imageContent && typeof message.imageContent.length === "number" || $util.isString(message.imageContent)))
                    return "imageContent: buffer expected";
            return null;
        };

        /**
         * Creates a ClientImage message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ClientImage
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ClientImage} ClientImage
         */
        ClientImage.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ClientImage)
                return object;
            var message = new $root.lens.ClientImage();
            if (object.imageContent != null)
                if (typeof object.imageContent === "string")
                    $util.base64.decode(object.imageContent, message.imageContent = $util.newBuffer($util.base64.length(object.imageContent)), 0);
                else if (object.imageContent.length >= 0)
                    message.imageContent = object.imageContent;
            return message;
        };

        /**
         * Creates a plain object from a ClientImage message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ClientImage
         * @static
         * @param {lens.ClientImage} message ClientImage
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ClientImage.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.imageContent = "";
                else {
                    object.imageContent = [];
                    if (options.bytes !== Array)
                        object.imageContent = $util.newBuffer(object.imageContent);
                }
            if (message.imageContent != null && message.hasOwnProperty("imageContent"))
                object.imageContent = options.bytes === String ? $util.base64.encode(message.imageContent, 0, message.imageContent.length) : options.bytes === Array ? Array.prototype.slice.call(message.imageContent) : message.imageContent;
            return object;
        };

        /**
         * Converts this ClientImage to JSON.
         * @function toJSON
         * @memberof lens.ClientImage
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ClientImage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ClientImage
         * @function getTypeUrl
         * @memberof lens.ClientImage
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ClientImage.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ClientImage";
        };

        return ClientImage;
    })();

    lens.ImageData = (function() {

        /**
         * Properties of an ImageData.
         * @memberof lens
         * @interface IImageData
         * @property {lens.IImagePayload|null} [payload] ImageData payload
         * @property {lens.IImageMetadata|null} [imageMetadata] ImageData imageMetadata
         * @property {Array.<lens.IGeometry>|null} [significantRegions] ImageData significantRegions
         */

        /**
         * Constructs a new ImageData.
         * @memberof lens
         * @classdesc Represents an ImageData.
         * @implements IImageData
         * @constructor
         * @param {lens.IImageData=} [properties] Properties to set
         */
        function ImageData(properties) {
            this.significantRegions = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImageData payload.
         * @member {lens.IImagePayload|null|undefined} payload
         * @memberof lens.ImageData
         * @instance
         */
        ImageData.prototype.payload = null;

        /**
         * ImageData imageMetadata.
         * @member {lens.IImageMetadata|null|undefined} imageMetadata
         * @memberof lens.ImageData
         * @instance
         */
        ImageData.prototype.imageMetadata = null;

        /**
         * ImageData significantRegions.
         * @member {Array.<lens.IGeometry>} significantRegions
         * @memberof lens.ImageData
         * @instance
         */
        ImageData.prototype.significantRegions = $util.emptyArray;

        /**
         * Creates a new ImageData instance using the specified properties.
         * @function create
         * @memberof lens.ImageData
         * @static
         * @param {lens.IImageData=} [properties] Properties to set
         * @returns {lens.ImageData} ImageData instance
         */
        ImageData.create = function create(properties) {
            return new ImageData(properties);
        };

        /**
         * Encodes the specified ImageData message. Does not implicitly {@link lens.ImageData.verify|verify} messages.
         * @function encode
         * @memberof lens.ImageData
         * @static
         * @param {lens.IImageData} message ImageData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                $root.lens.ImagePayload.encode(message.payload, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.imageMetadata != null && Object.hasOwnProperty.call(message, "imageMetadata"))
                $root.lens.ImageMetadata.encode(message.imageMetadata, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.significantRegions != null && message.significantRegions.length)
                for (var i = 0; i < message.significantRegions.length; ++i)
                    $root.lens.Geometry.encode(message.significantRegions[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ImageData message, length delimited. Does not implicitly {@link lens.ImageData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ImageData
         * @static
         * @param {lens.IImageData} message ImageData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImageData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ImageData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ImageData} ImageData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ImageData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.payload = $root.lens.ImagePayload.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.imageMetadata = $root.lens.ImageMetadata.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.significantRegions && message.significantRegions.length))
                            message.significantRegions = [];
                        message.significantRegions.push($root.lens.Geometry.decode(reader, reader.uint32()));
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImageData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ImageData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ImageData} ImageData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImageData message.
         * @function verify
         * @memberof lens.ImageData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.lens.ImagePayload.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            if (message.imageMetadata != null && message.hasOwnProperty("imageMetadata")) {
                var error = $root.lens.ImageMetadata.verify(message.imageMetadata);
                if (error)
                    return "imageMetadata." + error;
            }
            if (message.significantRegions != null && message.hasOwnProperty("significantRegions")) {
                if (!Array.isArray(message.significantRegions))
                    return "significantRegions: array expected";
                for (var i = 0; i < message.significantRegions.length; ++i) {
                    var error = $root.lens.Geometry.verify(message.significantRegions[i]);
                    if (error)
                        return "significantRegions." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ImageData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ImageData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ImageData} ImageData
         */
        ImageData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ImageData)
                return object;
            var message = new $root.lens.ImageData();
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".lens.ImageData.payload: object expected");
                message.payload = $root.lens.ImagePayload.fromObject(object.payload);
            }
            if (object.imageMetadata != null) {
                if (typeof object.imageMetadata !== "object")
                    throw TypeError(".lens.ImageData.imageMetadata: object expected");
                message.imageMetadata = $root.lens.ImageMetadata.fromObject(object.imageMetadata);
            }
            if (object.significantRegions) {
                if (!Array.isArray(object.significantRegions))
                    throw TypeError(".lens.ImageData.significantRegions: array expected");
                message.significantRegions = [];
                for (var i = 0; i < object.significantRegions.length; ++i) {
                    if (typeof object.significantRegions[i] !== "object")
                        throw TypeError(".lens.ImageData.significantRegions: object expected");
                    message.significantRegions[i] = $root.lens.Geometry.fromObject(object.significantRegions[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from an ImageData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ImageData
         * @static
         * @param {lens.ImageData} message ImageData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.significantRegions = [];
            if (options.defaults) {
                object.payload = null;
                object.imageMetadata = null;
            }
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.lens.ImagePayload.toObject(message.payload, options);
            if (message.imageMetadata != null && message.hasOwnProperty("imageMetadata"))
                object.imageMetadata = $root.lens.ImageMetadata.toObject(message.imageMetadata, options);
            if (message.significantRegions && message.significantRegions.length) {
                object.significantRegions = [];
                for (var j = 0; j < message.significantRegions.length; ++j)
                    object.significantRegions[j] = $root.lens.Geometry.toObject(message.significantRegions[j], options);
            }
            return object;
        };

        /**
         * Converts this ImageData to JSON.
         * @function toJSON
         * @memberof lens.ImageData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImageData
         * @function getTypeUrl
         * @memberof lens.ImageData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImageData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ImageData";
        };

        return ImageData;
    })();

    lens.ImagePayload = (function() {

        /**
         * Properties of an ImagePayload.
         * @memberof lens
         * @interface IImagePayload
         * @property {Uint8Array|null} [imageBytes] ImagePayload imageBytes
         */

        /**
         * Constructs a new ImagePayload.
         * @memberof lens
         * @classdesc Represents an ImagePayload.
         * @implements IImagePayload
         * @constructor
         * @param {lens.IImagePayload=} [properties] Properties to set
         */
        function ImagePayload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImagePayload imageBytes.
         * @member {Uint8Array} imageBytes
         * @memberof lens.ImagePayload
         * @instance
         */
        ImagePayload.prototype.imageBytes = $util.newBuffer([]);

        /**
         * Creates a new ImagePayload instance using the specified properties.
         * @function create
         * @memberof lens.ImagePayload
         * @static
         * @param {lens.IImagePayload=} [properties] Properties to set
         * @returns {lens.ImagePayload} ImagePayload instance
         */
        ImagePayload.create = function create(properties) {
            return new ImagePayload(properties);
        };

        /**
         * Encodes the specified ImagePayload message. Does not implicitly {@link lens.ImagePayload.verify|verify} messages.
         * @function encode
         * @memberof lens.ImagePayload
         * @static
         * @param {lens.IImagePayload} message ImagePayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImagePayload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.imageBytes != null && Object.hasOwnProperty.call(message, "imageBytes"))
                writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.imageBytes);
            return writer;
        };

        /**
         * Encodes the specified ImagePayload message, length delimited. Does not implicitly {@link lens.ImagePayload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ImagePayload
         * @static
         * @param {lens.IImagePayload} message ImagePayload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImagePayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImagePayload message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ImagePayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ImagePayload} ImagePayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImagePayload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ImagePayload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.imageBytes = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImagePayload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ImagePayload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ImagePayload} ImagePayload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImagePayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImagePayload message.
         * @function verify
         * @memberof lens.ImagePayload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImagePayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.imageBytes != null && message.hasOwnProperty("imageBytes"))
                if (!(message.imageBytes && typeof message.imageBytes.length === "number" || $util.isString(message.imageBytes)))
                    return "imageBytes: buffer expected";
            return null;
        };

        /**
         * Creates an ImagePayload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ImagePayload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ImagePayload} ImagePayload
         */
        ImagePayload.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ImagePayload)
                return object;
            var message = new $root.lens.ImagePayload();
            if (object.imageBytes != null)
                if (typeof object.imageBytes === "string")
                    $util.base64.decode(object.imageBytes, message.imageBytes = $util.newBuffer($util.base64.length(object.imageBytes)), 0);
                else if (object.imageBytes.length >= 0)
                    message.imageBytes = object.imageBytes;
            return message;
        };

        /**
         * Creates a plain object from an ImagePayload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ImagePayload
         * @static
         * @param {lens.ImagePayload} message ImagePayload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImagePayload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                if (options.bytes === String)
                    object.imageBytes = "";
                else {
                    object.imageBytes = [];
                    if (options.bytes !== Array)
                        object.imageBytes = $util.newBuffer(object.imageBytes);
                }
            if (message.imageBytes != null && message.hasOwnProperty("imageBytes"))
                object.imageBytes = options.bytes === String ? $util.base64.encode(message.imageBytes, 0, message.imageBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.imageBytes) : message.imageBytes;
            return object;
        };

        /**
         * Converts this ImagePayload to JSON.
         * @function toJSON
         * @memberof lens.ImagePayload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImagePayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImagePayload
         * @function getTypeUrl
         * @memberof lens.ImagePayload
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImagePayload.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ImagePayload";
        };

        return ImagePayload;
    })();

    lens.ImageMetadata = (function() {

        /**
         * Properties of an ImageMetadata.
         * @memberof lens
         * @interface IImageMetadata
         * @property {number|null} [width] ImageMetadata width
         * @property {number|null} [height] ImageMetadata height
         */

        /**
         * Constructs a new ImageMetadata.
         * @memberof lens
         * @classdesc Represents an ImageMetadata.
         * @implements IImageMetadata
         * @constructor
         * @param {lens.IImageMetadata=} [properties] Properties to set
         */
        function ImageMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ImageMetadata width.
         * @member {number} width
         * @memberof lens.ImageMetadata
         * @instance
         */
        ImageMetadata.prototype.width = 0;

        /**
         * ImageMetadata height.
         * @member {number} height
         * @memberof lens.ImageMetadata
         * @instance
         */
        ImageMetadata.prototype.height = 0;

        /**
         * Creates a new ImageMetadata instance using the specified properties.
         * @function create
         * @memberof lens.ImageMetadata
         * @static
         * @param {lens.IImageMetadata=} [properties] Properties to set
         * @returns {lens.ImageMetadata} ImageMetadata instance
         */
        ImageMetadata.create = function create(properties) {
            return new ImageMetadata(properties);
        };

        /**
         * Encodes the specified ImageMetadata message. Does not implicitly {@link lens.ImageMetadata.verify|verify} messages.
         * @function encode
         * @memberof lens.ImageMetadata
         * @static
         * @param {lens.IImageMetadata} message ImageMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.width != null && Object.hasOwnProperty.call(message, "width"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.width);
            if (message.height != null && Object.hasOwnProperty.call(message, "height"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.height);
            return writer;
        };

        /**
         * Encodes the specified ImageMetadata message, length delimited. Does not implicitly {@link lens.ImageMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ImageMetadata
         * @static
         * @param {lens.IImageMetadata} message ImageMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ImageMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ImageMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ImageMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ImageMetadata} ImageMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ImageMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.width = reader.int32();
                        break;
                    }
                case 2: {
                        message.height = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ImageMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ImageMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ImageMetadata} ImageMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ImageMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ImageMetadata message.
         * @function verify
         * @memberof lens.ImageMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ImageMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.width != null && message.hasOwnProperty("width"))
                if (!$util.isInteger(message.width))
                    return "width: integer expected";
            if (message.height != null && message.hasOwnProperty("height"))
                if (!$util.isInteger(message.height))
                    return "height: integer expected";
            return null;
        };

        /**
         * Creates an ImageMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ImageMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ImageMetadata} ImageMetadata
         */
        ImageMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ImageMetadata)
                return object;
            var message = new $root.lens.ImageMetadata();
            if (object.width != null)
                message.width = object.width | 0;
            if (object.height != null)
                message.height = object.height | 0;
            return message;
        };

        /**
         * Creates a plain object from an ImageMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ImageMetadata
         * @static
         * @param {lens.ImageMetadata} message ImageMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ImageMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.width = 0;
                object.height = 0;
            }
            if (message.width != null && message.hasOwnProperty("width"))
                object.width = message.width;
            if (message.height != null && message.hasOwnProperty("height"))
                object.height = message.height;
            return object;
        };

        /**
         * Converts this ImageMetadata to JSON.
         * @function toJSON
         * @memberof lens.ImageMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ImageMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ImageMetadata
         * @function getTypeUrl
         * @memberof lens.ImageMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ImageMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ImageMetadata";
        };

        return ImageMetadata;
    })();

    lens.LensOverlayInteractionRequestMetadata = (function() {

        /**
         * Properties of a LensOverlayInteractionRequestMetadata.
         * @memberof lens
         * @interface ILensOverlayInteractionRequestMetadata
         * @property {lens.LensOverlayInteractionRequestMetadata.Type|null} [type] LensOverlayInteractionRequestMetadata type
         * @property {lens.LensOverlayInteractionRequestMetadata.ISelectionMetadata|null} [selectionMetadata] LensOverlayInteractionRequestMetadata selectionMetadata
         * @property {lens.LensOverlayInteractionRequestMetadata.IQueryMetadata|null} [queryMetadata] LensOverlayInteractionRequestMetadata queryMetadata
         */

        /**
         * Constructs a new LensOverlayInteractionRequestMetadata.
         * @memberof lens
         * @classdesc Represents a LensOverlayInteractionRequestMetadata.
         * @implements ILensOverlayInteractionRequestMetadata
         * @constructor
         * @param {lens.ILensOverlayInteractionRequestMetadata=} [properties] Properties to set
         */
        function LensOverlayInteractionRequestMetadata(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayInteractionRequestMetadata type.
         * @member {lens.LensOverlayInteractionRequestMetadata.Type} type
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @instance
         */
        LensOverlayInteractionRequestMetadata.prototype.type = 0;

        /**
         * LensOverlayInteractionRequestMetadata selectionMetadata.
         * @member {lens.LensOverlayInteractionRequestMetadata.ISelectionMetadata|null|undefined} selectionMetadata
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @instance
         */
        LensOverlayInteractionRequestMetadata.prototype.selectionMetadata = null;

        /**
         * LensOverlayInteractionRequestMetadata queryMetadata.
         * @member {lens.LensOverlayInteractionRequestMetadata.IQueryMetadata|null|undefined} queryMetadata
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @instance
         */
        LensOverlayInteractionRequestMetadata.prototype.queryMetadata = null;

        /**
         * Creates a new LensOverlayInteractionRequestMetadata instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {lens.ILensOverlayInteractionRequestMetadata=} [properties] Properties to set
         * @returns {lens.LensOverlayInteractionRequestMetadata} LensOverlayInteractionRequestMetadata instance
         */
        LensOverlayInteractionRequestMetadata.create = function create(properties) {
            return new LensOverlayInteractionRequestMetadata(properties);
        };

        /**
         * Encodes the specified LensOverlayInteractionRequestMetadata message. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {lens.ILensOverlayInteractionRequestMetadata} message LensOverlayInteractionRequestMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayInteractionRequestMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.type);
            if (message.selectionMetadata != null && Object.hasOwnProperty.call(message, "selectionMetadata"))
                $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.encode(message.selectionMetadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.queryMetadata != null && Object.hasOwnProperty.call(message, "queryMetadata"))
                $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata.encode(message.queryMetadata, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayInteractionRequestMetadata message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {lens.ILensOverlayInteractionRequestMetadata} message LensOverlayInteractionRequestMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayInteractionRequestMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayInteractionRequestMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayInteractionRequestMetadata} LensOverlayInteractionRequestMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayInteractionRequestMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionRequestMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.type = reader.int32();
                        break;
                    }
                case 2: {
                        message.selectionMetadata = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.queryMetadata = $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayInteractionRequestMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayInteractionRequestMetadata} LensOverlayInteractionRequestMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayInteractionRequestMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayInteractionRequestMetadata message.
         * @function verify
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayInteractionRequestMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.type != null && message.hasOwnProperty("type"))
                switch (message.type) {
                default:
                    return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.selectionMetadata != null && message.hasOwnProperty("selectionMetadata")) {
                var error = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.verify(message.selectionMetadata);
                if (error)
                    return "selectionMetadata." + error;
            }
            if (message.queryMetadata != null && message.hasOwnProperty("queryMetadata")) {
                var error = $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata.verify(message.queryMetadata);
                if (error)
                    return "queryMetadata." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayInteractionRequestMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayInteractionRequestMetadata} LensOverlayInteractionRequestMetadata
         */
        LensOverlayInteractionRequestMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayInteractionRequestMetadata)
                return object;
            var message = new $root.lens.LensOverlayInteractionRequestMetadata();
            switch (object.type) {
            default:
                if (typeof object.type === "number") {
                    message.type = object.type;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.type = 0;
                break;
            case "TAP":
            case 1:
                message.type = 1;
                break;
            case "REGION":
            case 2:
                message.type = 2;
                break;
            case "TEXT_SELECTION":
            case 3:
                message.type = 3;
                break;
            case "REGION_SEARCH":
            case 4:
                message.type = 4;
                break;
            case "OBJECT_FULFILLMENT":
            case 5:
                message.type = 5;
                break;
            case "CONTEXTUAL_SEARCH_QUERY":
            case 9:
                message.type = 9;
                break;
            case "PDF_QUERY":
            case 10:
                message.type = 10;
                break;
            case "WEBPAGE_QUERY":
            case 11:
                message.type = 11;
                break;
            }
            if (object.selectionMetadata != null) {
                if (typeof object.selectionMetadata !== "object")
                    throw TypeError(".lens.LensOverlayInteractionRequestMetadata.selectionMetadata: object expected");
                message.selectionMetadata = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.fromObject(object.selectionMetadata);
            }
            if (object.queryMetadata != null) {
                if (typeof object.queryMetadata !== "object")
                    throw TypeError(".lens.LensOverlayInteractionRequestMetadata.queryMetadata: object expected");
                message.queryMetadata = $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata.fromObject(object.queryMetadata);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayInteractionRequestMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {lens.LensOverlayInteractionRequestMetadata} message LensOverlayInteractionRequestMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayInteractionRequestMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.type = options.enums === String ? "UNKNOWN" : 0;
                object.selectionMetadata = null;
                object.queryMetadata = null;
            }
            if (message.type != null && message.hasOwnProperty("type"))
                object.type = options.enums === String ? $root.lens.LensOverlayInteractionRequestMetadata.Type[message.type] === undefined ? message.type : $root.lens.LensOverlayInteractionRequestMetadata.Type[message.type] : message.type;
            if (message.selectionMetadata != null && message.hasOwnProperty("selectionMetadata"))
                object.selectionMetadata = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.toObject(message.selectionMetadata, options);
            if (message.queryMetadata != null && message.hasOwnProperty("queryMetadata"))
                object.queryMetadata = $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata.toObject(message.queryMetadata, options);
            return object;
        };

        /**
         * Converts this LensOverlayInteractionRequestMetadata to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayInteractionRequestMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayInteractionRequestMetadata
         * @function getTypeUrl
         * @memberof lens.LensOverlayInteractionRequestMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayInteractionRequestMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayInteractionRequestMetadata";
        };

        /**
         * Type enum.
         * @name lens.LensOverlayInteractionRequestMetadata.Type
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} TAP=1 TAP value
         * @property {number} REGION=2 REGION value
         * @property {number} TEXT_SELECTION=3 TEXT_SELECTION value
         * @property {number} REGION_SEARCH=4 REGION_SEARCH value
         * @property {number} OBJECT_FULFILLMENT=5 OBJECT_FULFILLMENT value
         * @property {number} CONTEXTUAL_SEARCH_QUERY=9 CONTEXTUAL_SEARCH_QUERY value
         * @property {number} PDF_QUERY=10 PDF_QUERY value
         * @property {number} WEBPAGE_QUERY=11 WEBPAGE_QUERY value
         */
        LensOverlayInteractionRequestMetadata.Type = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[1] = "TAP"] = 1;
            values[valuesById[2] = "REGION"] = 2;
            values[valuesById[3] = "TEXT_SELECTION"] = 3;
            values[valuesById[4] = "REGION_SEARCH"] = 4;
            values[valuesById[5] = "OBJECT_FULFILLMENT"] = 5;
            values[valuesById[9] = "CONTEXTUAL_SEARCH_QUERY"] = 9;
            values[valuesById[10] = "PDF_QUERY"] = 10;
            values[valuesById[11] = "WEBPAGE_QUERY"] = 11;
            return values;
        })();

        LensOverlayInteractionRequestMetadata.SelectionMetadata = (function() {

            /**
             * Properties of a SelectionMetadata.
             * @memberof lens.LensOverlayInteractionRequestMetadata
             * @interface ISelectionMetadata
             * @property {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IPoint|null} [point] SelectionMetadata point
             * @property {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IRegion|null} [region] SelectionMetadata region
             * @property {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IObject|null} [object] SelectionMetadata object
             */

            /**
             * Constructs a new SelectionMetadata.
             * @memberof lens.LensOverlayInteractionRequestMetadata
             * @classdesc Represents a SelectionMetadata.
             * @implements ISelectionMetadata
             * @constructor
             * @param {lens.LensOverlayInteractionRequestMetadata.ISelectionMetadata=} [properties] Properties to set
             */
            function SelectionMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SelectionMetadata point.
             * @member {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IPoint|null|undefined} point
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @instance
             */
            SelectionMetadata.prototype.point = null;

            /**
             * SelectionMetadata region.
             * @member {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IRegion|null|undefined} region
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @instance
             */
            SelectionMetadata.prototype.region = null;

            /**
             * SelectionMetadata object.
             * @member {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IObject|null|undefined} object
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @instance
             */
            SelectionMetadata.prototype.object = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * SelectionMetadata selection.
             * @member {"point"|"region"|"object"|undefined} selection
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @instance
             */
            Object.defineProperty(SelectionMetadata.prototype, "selection", {
                get: $util.oneOfGetter($oneOfFields = ["point", "region", "object"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new SelectionMetadata instance using the specified properties.
             * @function create
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.ISelectionMetadata=} [properties] Properties to set
             * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata} SelectionMetadata instance
             */
            SelectionMetadata.create = function create(properties) {
                return new SelectionMetadata(properties);
            };

            /**
             * Encodes the specified SelectionMetadata message. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.verify|verify} messages.
             * @function encode
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.ISelectionMetadata} message SelectionMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelectionMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.point != null && Object.hasOwnProperty.call(message, "point"))
                    $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point.encode(message.point, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                    $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.encode(message.region, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.object != null && Object.hasOwnProperty.call(message, "object"))
                    $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.encode(message.object, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SelectionMetadata message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.ISelectionMetadata} message SelectionMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SelectionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SelectionMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata} SelectionMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelectionMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.point = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point.decode(reader, reader.uint32());
                            break;
                        }
                    case 2: {
                            message.region = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.decode(reader, reader.uint32());
                            break;
                        }
                    case 3: {
                            message.object = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SelectionMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata} SelectionMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SelectionMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SelectionMetadata message.
             * @function verify
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SelectionMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.point != null && message.hasOwnProperty("point")) {
                    properties.selection = 1;
                    {
                        var error = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point.verify(message.point);
                        if (error)
                            return "point." + error;
                    }
                }
                if (message.region != null && message.hasOwnProperty("region")) {
                    if (properties.selection === 1)
                        return "selection: multiple values";
                    properties.selection = 1;
                    {
                        var error = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.verify(message.region);
                        if (error)
                            return "region." + error;
                    }
                }
                if (message.object != null && message.hasOwnProperty("object")) {
                    if (properties.selection === 1)
                        return "selection: multiple values";
                    properties.selection = 1;
                    {
                        var error = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.verify(message.object);
                        if (error)
                            return "object." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SelectionMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata} SelectionMetadata
             */
            SelectionMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata)
                    return object;
                var message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata();
                if (object.point != null) {
                    if (typeof object.point !== "object")
                        throw TypeError(".lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.point: object expected");
                    message.point = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point.fromObject(object.point);
                }
                if (object.region != null) {
                    if (typeof object.region !== "object")
                        throw TypeError(".lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.region: object expected");
                    message.region = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.fromObject(object.region);
                }
                if (object.object != null) {
                    if (typeof object.object !== "object")
                        throw TypeError(".lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.object: object expected");
                    message.object = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.fromObject(object.object);
                }
                return message;
            };

            /**
             * Creates a plain object from a SelectionMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata} message SelectionMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SelectionMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.point != null && message.hasOwnProperty("point")) {
                    object.point = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point.toObject(message.point, options);
                    if (options.oneofs)
                        object.selection = "point";
                }
                if (message.region != null && message.hasOwnProperty("region")) {
                    object.region = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.toObject(message.region, options);
                    if (options.oneofs)
                        object.selection = "region";
                }
                if (message.object != null && message.hasOwnProperty("object")) {
                    object.object = $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.toObject(message.object, options);
                    if (options.oneofs)
                        object.selection = "object";
                }
                return object;
            };

            /**
             * Converts this SelectionMetadata to JSON.
             * @function toJSON
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SelectionMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for SelectionMetadata
             * @function getTypeUrl
             * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            SelectionMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.LensOverlayInteractionRequestMetadata.SelectionMetadata";
            };

            SelectionMetadata.Point = (function() {

                /**
                 * Properties of a Point.
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
                 * @interface IPoint
                 * @property {number|null} [x] Point x
                 * @property {number|null} [y] Point y
                 */

                /**
                 * Constructs a new Point.
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
                 * @classdesc Represents a Point.
                 * @implements IPoint
                 * @constructor
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IPoint=} [properties] Properties to set
                 */
                function Point(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Point x.
                 * @member {number} x
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @instance
                 */
                Point.prototype.x = 0;

                /**
                 * Point y.
                 * @member {number} y
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @instance
                 */
                Point.prototype.y = 0;

                /**
                 * Creates a new Point instance using the specified properties.
                 * @function create
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IPoint=} [properties] Properties to set
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point} Point instance
                 */
                Point.create = function create(properties) {
                    return new Point(properties);
                };

                /**
                 * Encodes the specified Point message. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point.verify|verify} messages.
                 * @function encode
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IPoint} message Point message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.x != null && Object.hasOwnProperty.call(message, "x"))
                        writer.uint32(/* id 1, wireType 5 =*/13).float(message.x);
                    if (message.y != null && Object.hasOwnProperty.call(message, "y"))
                        writer.uint32(/* id 2, wireType 5 =*/21).float(message.y);
                    return writer;
                };

                /**
                 * Encodes the specified Point message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IPoint} message Point message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Point.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Point message from the specified reader or buffer.
                 * @function decode
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point} Point
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.x = reader.float();
                                break;
                            }
                        case 2: {
                                message.y = reader.float();
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Point message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point} Point
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Point.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Point message.
                 * @function verify
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Point.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.x != null && message.hasOwnProperty("x"))
                        if (typeof message.x !== "number")
                            return "x: number expected";
                    if (message.y != null && message.hasOwnProperty("y"))
                        if (typeof message.y !== "number")
                            return "y: number expected";
                    return null;
                };

                /**
                 * Creates a Point message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point} Point
                 */
                Point.fromObject = function fromObject(object) {
                    if (object instanceof $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point)
                        return object;
                    var message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point();
                    if (object.x != null)
                        message.x = Number(object.x);
                    if (object.y != null)
                        message.y = Number(object.y);
                    return message;
                };

                /**
                 * Creates a plain object from a Point message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point} message Point
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Point.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.x = 0;
                        object.y = 0;
                    }
                    if (message.x != null && message.hasOwnProperty("x"))
                        object.x = options.json && !isFinite(message.x) ? String(message.x) : message.x;
                    if (message.y != null && message.hasOwnProperty("y"))
                        object.y = options.json && !isFinite(message.y) ? String(message.y) : message.y;
                    return object;
                };

                /**
                 * Converts this Point to JSON.
                 * @function toJSON
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Point.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Point
                 * @function getTypeUrl
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Point.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Point";
                };

                return Point;
            })();

            SelectionMetadata.Region = (function() {

                /**
                 * Properties of a Region.
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
                 * @interface IRegion
                 * @property {lens.ICenterRotatedBox|null} [region] Region region
                 */

                /**
                 * Constructs a new Region.
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
                 * @classdesc Represents a Region.
                 * @implements IRegion
                 * @constructor
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IRegion=} [properties] Properties to set
                 */
                function Region(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Region region.
                 * @member {lens.ICenterRotatedBox|null|undefined} region
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @instance
                 */
                Region.prototype.region = null;

                /**
                 * Creates a new Region instance using the specified properties.
                 * @function create
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IRegion=} [properties] Properties to set
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region} Region instance
                 */
                Region.create = function create(properties) {
                    return new Region(properties);
                };

                /**
                 * Encodes the specified Region message. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.verify|verify} messages.
                 * @function encode
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IRegion} message Region message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Region.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.region != null && Object.hasOwnProperty.call(message, "region"))
                        $root.lens.CenterRotatedBox.encode(message.region, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Region message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IRegion} message Region message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Region.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Region message from the specified reader or buffer.
                 * @function decode
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region} Region
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Region.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.region = $root.lens.CenterRotatedBox.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Region message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region} Region
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Region.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Region message.
                 * @function verify
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Region.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.region != null && message.hasOwnProperty("region")) {
                        var error = $root.lens.CenterRotatedBox.verify(message.region);
                        if (error)
                            return "region." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Region message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region} Region
                 */
                Region.fromObject = function fromObject(object) {
                    if (object instanceof $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region)
                        return object;
                    var message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region();
                    if (object.region != null) {
                        if (typeof object.region !== "object")
                            throw TypeError(".lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region.region: object expected");
                        message.region = $root.lens.CenterRotatedBox.fromObject(object.region);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Region message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region} message Region
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Region.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.region = null;
                    if (message.region != null && message.hasOwnProperty("region"))
                        object.region = $root.lens.CenterRotatedBox.toObject(message.region, options);
                    return object;
                };

                /**
                 * Converts this Region to JSON.
                 * @function toJSON
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Region.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Region
                 * @function getTypeUrl
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Region.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Region";
                };

                return Region;
            })();

            SelectionMetadata.Object = (function() {

                /**
                 * Properties of an Object.
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
                 * @interface IObject
                 * @property {string|null} [objectId] Object objectId
                 * @property {lens.IGeometry|null} [geometry] Object geometry
                 */

                /**
                 * Constructs a new Object.
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata
                 * @classdesc Represents an Object.
                 * @implements IObject
                 * @constructor
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IObject=} [properties] Properties to set
                 */
                function Object(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Object objectId.
                 * @member {string} objectId
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @instance
                 */
                Object.prototype.objectId = "";

                /**
                 * Object geometry.
                 * @member {lens.IGeometry|null|undefined} geometry
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @instance
                 */
                Object.prototype.geometry = null;

                /**
                 * Creates a new Object instance using the specified properties.
                 * @function create
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IObject=} [properties] Properties to set
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object} Object instance
                 */
                Object.create = function create(properties) {
                    return new Object(properties);
                };

                /**
                 * Encodes the specified Object message. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.verify|verify} messages.
                 * @function encode
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IObject} message Object message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Object.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.objectId != null && Object.hasOwnProperty.call(message, "objectId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.objectId);
                    if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                        $root.lens.Geometry.encode(message.geometry, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Object message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.IObject} message Object message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Object.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Object message from the specified reader or buffer.
                 * @function decode
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object} Object
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Object.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1: {
                                message.objectId = reader.string();
                                break;
                            }
                        case 2: {
                                message.geometry = $root.lens.Geometry.decode(reader, reader.uint32());
                                break;
                            }
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Object message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object} Object
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Object.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Object message.
                 * @function verify
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Object.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.objectId != null && message.hasOwnProperty("objectId"))
                        if (!$util.isString(message.objectId))
                            return "objectId: string expected";
                    if (message.geometry != null && message.hasOwnProperty("geometry")) {
                        var error = $root.lens.Geometry.verify(message.geometry);
                        if (error)
                            return "geometry." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Object message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object} Object
                 */
                Object.fromObject = function fromObject(object) {
                    if (object instanceof $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object)
                        return object;
                    var message = new $root.lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object();
                    if (object.objectId != null)
                        message.objectId = String(object.objectId);
                    if (object.geometry != null) {
                        if (typeof object.geometry !== "object")
                            throw TypeError(".lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object.geometry: object expected");
                        message.geometry = $root.lens.Geometry.fromObject(object.geometry);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Object message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object} message Object
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Object.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.objectId = "";
                        object.geometry = null;
                    }
                    if (message.objectId != null && message.hasOwnProperty("objectId"))
                        object.objectId = message.objectId;
                    if (message.geometry != null && message.hasOwnProperty("geometry"))
                        object.geometry = $root.lens.Geometry.toObject(message.geometry, options);
                    return object;
                };

                /**
                 * Converts this Object to JSON.
                 * @function toJSON
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Object.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Gets the default type url for Object
                 * @function getTypeUrl
                 * @memberof lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object
                 * @static
                 * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
                 * @returns {string} The default type url
                 */
                Object.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                    if (typeUrlPrefix === undefined) {
                        typeUrlPrefix = "type.googleapis.com";
                    }
                    return typeUrlPrefix + "/lens.LensOverlayInteractionRequestMetadata.SelectionMetadata.Object";
                };

                return Object;
            })();

            return SelectionMetadata;
        })();

        LensOverlayInteractionRequestMetadata.QueryMetadata = (function() {

            /**
             * Properties of a QueryMetadata.
             * @memberof lens.LensOverlayInteractionRequestMetadata
             * @interface IQueryMetadata
             * @property {lens.ITextQuery|null} [textQuery] QueryMetadata textQuery
             */

            /**
             * Constructs a new QueryMetadata.
             * @memberof lens.LensOverlayInteractionRequestMetadata
             * @classdesc Represents a QueryMetadata.
             * @implements IQueryMetadata
             * @constructor
             * @param {lens.LensOverlayInteractionRequestMetadata.IQueryMetadata=} [properties] Properties to set
             */
            function QueryMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryMetadata textQuery.
             * @member {lens.ITextQuery|null|undefined} textQuery
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @instance
             */
            QueryMetadata.prototype.textQuery = null;

            /**
             * Creates a new QueryMetadata instance using the specified properties.
             * @function create
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.IQueryMetadata=} [properties] Properties to set
             * @returns {lens.LensOverlayInteractionRequestMetadata.QueryMetadata} QueryMetadata instance
             */
            QueryMetadata.create = function create(properties) {
                return new QueryMetadata(properties);
            };

            /**
             * Encodes the specified QueryMetadata message. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.QueryMetadata.verify|verify} messages.
             * @function encode
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.IQueryMetadata} message QueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.textQuery != null && Object.hasOwnProperty.call(message, "textQuery"))
                    $root.lens.TextQuery.encode(message.textQuery, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified QueryMetadata message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionRequestMetadata.QueryMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.IQueryMetadata} message QueryMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.LensOverlayInteractionRequestMetadata.QueryMetadata} QueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2: {
                            message.textQuery = $root.lens.TextQuery.decode(reader, reader.uint32());
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.LensOverlayInteractionRequestMetadata.QueryMetadata} QueryMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryMetadata message.
             * @function verify
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.textQuery != null && message.hasOwnProperty("textQuery")) {
                    var error = $root.lens.TextQuery.verify(message.textQuery);
                    if (error)
                        return "textQuery." + error;
                }
                return null;
            };

            /**
             * Creates a QueryMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.LensOverlayInteractionRequestMetadata.QueryMetadata} QueryMetadata
             */
            QueryMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata)
                    return object;
                var message = new $root.lens.LensOverlayInteractionRequestMetadata.QueryMetadata();
                if (object.textQuery != null) {
                    if (typeof object.textQuery !== "object")
                        throw TypeError(".lens.LensOverlayInteractionRequestMetadata.QueryMetadata.textQuery: object expected");
                    message.textQuery = $root.lens.TextQuery.fromObject(object.textQuery);
                }
                return message;
            };

            /**
             * Creates a plain object from a QueryMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {lens.LensOverlayInteractionRequestMetadata.QueryMetadata} message QueryMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.textQuery = null;
                if (message.textQuery != null && message.hasOwnProperty("textQuery"))
                    object.textQuery = $root.lens.TextQuery.toObject(message.textQuery, options);
                return object;
            };

            /**
             * Converts this QueryMetadata to JSON.
             * @function toJSON
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for QueryMetadata
             * @function getTypeUrl
             * @memberof lens.LensOverlayInteractionRequestMetadata.QueryMetadata
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            QueryMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.LensOverlayInteractionRequestMetadata.QueryMetadata";
            };

            return QueryMetadata;
        })();

        return LensOverlayInteractionRequestMetadata;
    })();

    lens.TextQuery = (function() {

        /**
         * Properties of a TextQuery.
         * @memberof lens
         * @interface ITextQuery
         * @property {string|null} [query] TextQuery query
         * @property {boolean|null} [isPrimary] TextQuery isPrimary
         */

        /**
         * Constructs a new TextQuery.
         * @memberof lens
         * @classdesc Represents a TextQuery.
         * @implements ITextQuery
         * @constructor
         * @param {lens.ITextQuery=} [properties] Properties to set
         */
        function TextQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TextQuery query.
         * @member {string} query
         * @memberof lens.TextQuery
         * @instance
         */
        TextQuery.prototype.query = "";

        /**
         * TextQuery isPrimary.
         * @member {boolean} isPrimary
         * @memberof lens.TextQuery
         * @instance
         */
        TextQuery.prototype.isPrimary = false;

        /**
         * Creates a new TextQuery instance using the specified properties.
         * @function create
         * @memberof lens.TextQuery
         * @static
         * @param {lens.ITextQuery=} [properties] Properties to set
         * @returns {lens.TextQuery} TextQuery instance
         */
        TextQuery.create = function create(properties) {
            return new TextQuery(properties);
        };

        /**
         * Encodes the specified TextQuery message. Does not implicitly {@link lens.TextQuery.verify|verify} messages.
         * @function encode
         * @memberof lens.TextQuery
         * @static
         * @param {lens.ITextQuery} message TextQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.query != null && Object.hasOwnProperty.call(message, "query"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.query);
            if (message.isPrimary != null && Object.hasOwnProperty.call(message, "isPrimary"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isPrimary);
            return writer;
        };

        /**
         * Encodes the specified TextQuery message, length delimited. Does not implicitly {@link lens.TextQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.TextQuery
         * @static
         * @param {lens.ITextQuery} message TextQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TextQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TextQuery message from the specified reader or buffer.
         * @function decode
         * @memberof lens.TextQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.TextQuery} TextQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TextQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.query = reader.string();
                        break;
                    }
                case 2: {
                        message.isPrimary = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TextQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.TextQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.TextQuery} TextQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TextQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TextQuery message.
         * @function verify
         * @memberof lens.TextQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TextQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.query != null && message.hasOwnProperty("query"))
                if (!$util.isString(message.query))
                    return "query: string expected";
            if (message.isPrimary != null && message.hasOwnProperty("isPrimary"))
                if (typeof message.isPrimary !== "boolean")
                    return "isPrimary: boolean expected";
            return null;
        };

        /**
         * Creates a TextQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.TextQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.TextQuery} TextQuery
         */
        TextQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.TextQuery)
                return object;
            var message = new $root.lens.TextQuery();
            if (object.query != null)
                message.query = String(object.query);
            if (object.isPrimary != null)
                message.isPrimary = Boolean(object.isPrimary);
            return message;
        };

        /**
         * Creates a plain object from a TextQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.TextQuery
         * @static
         * @param {lens.TextQuery} message TextQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TextQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.query = "";
                object.isPrimary = false;
            }
            if (message.query != null && message.hasOwnProperty("query"))
                object.query = message.query;
            if (message.isPrimary != null && message.hasOwnProperty("isPrimary"))
                object.isPrimary = message.isPrimary;
            return object;
        };

        /**
         * Converts this TextQuery to JSON.
         * @function toJSON
         * @memberof lens.TextQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TextQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TextQuery
         * @function getTypeUrl
         * @memberof lens.TextQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TextQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.TextQuery";
        };

        return TextQuery;
    })();

    lens.FunctionCall = (function() {

        /**
         * Properties of a FunctionCall.
         * @memberof lens
         * @interface IFunctionCall
         * @property {string|null} [name] FunctionCall name
         * @property {Array.<lens.IArgument>|null} [argument] FunctionCall argument
         * @property {lens.IFunctionCallSignals|null} [signals] FunctionCall signals
         */

        /**
         * Constructs a new FunctionCall.
         * @memberof lens
         * @classdesc Represents a FunctionCall.
         * @implements IFunctionCall
         * @constructor
         * @param {lens.IFunctionCall=} [properties] Properties to set
         */
        function FunctionCall(properties) {
            this.argument = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FunctionCall name.
         * @member {string} name
         * @memberof lens.FunctionCall
         * @instance
         */
        FunctionCall.prototype.name = "";

        /**
         * FunctionCall argument.
         * @member {Array.<lens.IArgument>} argument
         * @memberof lens.FunctionCall
         * @instance
         */
        FunctionCall.prototype.argument = $util.emptyArray;

        /**
         * FunctionCall signals.
         * @member {lens.IFunctionCallSignals|null|undefined} signals
         * @memberof lens.FunctionCall
         * @instance
         */
        FunctionCall.prototype.signals = null;

        /**
         * Creates a new FunctionCall instance using the specified properties.
         * @function create
         * @memberof lens.FunctionCall
         * @static
         * @param {lens.IFunctionCall=} [properties] Properties to set
         * @returns {lens.FunctionCall} FunctionCall instance
         */
        FunctionCall.create = function create(properties) {
            return new FunctionCall(properties);
        };

        /**
         * Encodes the specified FunctionCall message. Does not implicitly {@link lens.FunctionCall.verify|verify} messages.
         * @function encode
         * @memberof lens.FunctionCall
         * @static
         * @param {lens.IFunctionCall} message FunctionCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionCall.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.argument != null && message.argument.length)
                for (var i = 0; i < message.argument.length; ++i)
                    $root.lens.Argument.encode(message.argument[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.signals != null && Object.hasOwnProperty.call(message, "signals"))
                $root.lens.FunctionCallSignals.encode(message.signals, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FunctionCall message, length delimited. Does not implicitly {@link lens.FunctionCall.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.FunctionCall
         * @static
         * @param {lens.IFunctionCall} message FunctionCall message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionCall.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FunctionCall message from the specified reader or buffer.
         * @function decode
         * @memberof lens.FunctionCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.FunctionCall} FunctionCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionCall.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.FunctionCall();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.argument && message.argument.length))
                            message.argument = [];
                        message.argument.push($root.lens.Argument.decode(reader, reader.uint32()));
                        break;
                    }
                case 4: {
                        message.signals = $root.lens.FunctionCallSignals.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FunctionCall message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.FunctionCall
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.FunctionCall} FunctionCall
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionCall.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FunctionCall message.
         * @function verify
         * @memberof lens.FunctionCall
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FunctionCall.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.argument != null && message.hasOwnProperty("argument")) {
                if (!Array.isArray(message.argument))
                    return "argument: array expected";
                for (var i = 0; i < message.argument.length; ++i) {
                    var error = $root.lens.Argument.verify(message.argument[i]);
                    if (error)
                        return "argument." + error;
                }
            }
            if (message.signals != null && message.hasOwnProperty("signals")) {
                var error = $root.lens.FunctionCallSignals.verify(message.signals);
                if (error)
                    return "signals." + error;
            }
            return null;
        };

        /**
         * Creates a FunctionCall message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.FunctionCall
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.FunctionCall} FunctionCall
         */
        FunctionCall.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.FunctionCall)
                return object;
            var message = new $root.lens.FunctionCall();
            if (object.name != null)
                message.name = String(object.name);
            if (object.argument) {
                if (!Array.isArray(object.argument))
                    throw TypeError(".lens.FunctionCall.argument: array expected");
                message.argument = [];
                for (var i = 0; i < object.argument.length; ++i) {
                    if (typeof object.argument[i] !== "object")
                        throw TypeError(".lens.FunctionCall.argument: object expected");
                    message.argument[i] = $root.lens.Argument.fromObject(object.argument[i]);
                }
            }
            if (object.signals != null) {
                if (typeof object.signals !== "object")
                    throw TypeError(".lens.FunctionCall.signals: object expected");
                message.signals = $root.lens.FunctionCallSignals.fromObject(object.signals);
            }
            return message;
        };

        /**
         * Creates a plain object from a FunctionCall message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.FunctionCall
         * @static
         * @param {lens.FunctionCall} message FunctionCall
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FunctionCall.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.argument = [];
            if (options.defaults) {
                object.name = "";
                object.signals = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.argument && message.argument.length) {
                object.argument = [];
                for (var j = 0; j < message.argument.length; ++j)
                    object.argument[j] = $root.lens.Argument.toObject(message.argument[j], options);
            }
            if (message.signals != null && message.hasOwnProperty("signals"))
                object.signals = $root.lens.FunctionCallSignals.toObject(message.signals, options);
            return object;
        };

        /**
         * Converts this FunctionCall to JSON.
         * @function toJSON
         * @memberof lens.FunctionCall
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FunctionCall.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FunctionCall
         * @function getTypeUrl
         * @memberof lens.FunctionCall
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FunctionCall.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.FunctionCall";
        };

        return FunctionCall;
    })();

    lens.FunctionCallSignals = (function() {

        /**
         * Properties of a FunctionCallSignals.
         * @memberof lens
         * @interface IFunctionCallSignals
         * @property {lens.ITranslateStickinessSignals|null} [translateStickinessSignals] FunctionCallSignals translateStickinessSignals
         */

        /**
         * Constructs a new FunctionCallSignals.
         * @memberof lens
         * @classdesc Represents a FunctionCallSignals.
         * @implements IFunctionCallSignals
         * @constructor
         * @param {lens.IFunctionCallSignals=} [properties] Properties to set
         */
        function FunctionCallSignals(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FunctionCallSignals translateStickinessSignals.
         * @member {lens.ITranslateStickinessSignals|null|undefined} translateStickinessSignals
         * @memberof lens.FunctionCallSignals
         * @instance
         */
        FunctionCallSignals.prototype.translateStickinessSignals = null;

        /**
         * Creates a new FunctionCallSignals instance using the specified properties.
         * @function create
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {lens.IFunctionCallSignals=} [properties] Properties to set
         * @returns {lens.FunctionCallSignals} FunctionCallSignals instance
         */
        FunctionCallSignals.create = function create(properties) {
            return new FunctionCallSignals(properties);
        };

        /**
         * Encodes the specified FunctionCallSignals message. Does not implicitly {@link lens.FunctionCallSignals.verify|verify} messages.
         * @function encode
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {lens.IFunctionCallSignals} message FunctionCallSignals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionCallSignals.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.translateStickinessSignals != null && Object.hasOwnProperty.call(message, "translateStickinessSignals"))
                $root.lens.TranslateStickinessSignals.encode(message.translateStickinessSignals, writer.uint32(/* id 311378150, wireType 2 =*/2491025202).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified FunctionCallSignals message, length delimited. Does not implicitly {@link lens.FunctionCallSignals.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {lens.IFunctionCallSignals} message FunctionCallSignals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FunctionCallSignals.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FunctionCallSignals message from the specified reader or buffer.
         * @function decode
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.FunctionCallSignals} FunctionCallSignals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionCallSignals.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.FunctionCallSignals();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 311378150: {
                        message.translateStickinessSignals = $root.lens.TranslateStickinessSignals.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FunctionCallSignals message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.FunctionCallSignals} FunctionCallSignals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FunctionCallSignals.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FunctionCallSignals message.
         * @function verify
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FunctionCallSignals.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.translateStickinessSignals != null && message.hasOwnProperty("translateStickinessSignals")) {
                var error = $root.lens.TranslateStickinessSignals.verify(message.translateStickinessSignals);
                if (error)
                    return "translateStickinessSignals." + error;
            }
            return null;
        };

        /**
         * Creates a FunctionCallSignals message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.FunctionCallSignals} FunctionCallSignals
         */
        FunctionCallSignals.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.FunctionCallSignals)
                return object;
            var message = new $root.lens.FunctionCallSignals();
            if (object.translateStickinessSignals != null) {
                if (typeof object.translateStickinessSignals !== "object")
                    throw TypeError(".lens.FunctionCallSignals.translateStickinessSignals: object expected");
                message.translateStickinessSignals = $root.lens.TranslateStickinessSignals.fromObject(object.translateStickinessSignals);
            }
            return message;
        };

        /**
         * Creates a plain object from a FunctionCallSignals message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {lens.FunctionCallSignals} message FunctionCallSignals
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FunctionCallSignals.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.translateStickinessSignals = null;
            if (message.translateStickinessSignals != null && message.hasOwnProperty("translateStickinessSignals"))
                object.translateStickinessSignals = $root.lens.TranslateStickinessSignals.toObject(message.translateStickinessSignals, options);
            return object;
        };

        /**
         * Converts this FunctionCallSignals to JSON.
         * @function toJSON
         * @memberof lens.FunctionCallSignals
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FunctionCallSignals.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FunctionCallSignals
         * @function getTypeUrl
         * @memberof lens.FunctionCallSignals
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FunctionCallSignals.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.FunctionCallSignals";
        };

        return FunctionCallSignals;
    })();

    lens.Argument = (function() {

        /**
         * Properties of an Argument.
         * @memberof lens
         * @interface IArgument
         * @property {string|null} [name] Argument name
         * @property {lens.IArgumentValue|null} [value] Argument value
         */

        /**
         * Constructs a new Argument.
         * @memberof lens
         * @classdesc Represents an Argument.
         * @implements IArgument
         * @constructor
         * @param {lens.IArgument=} [properties] Properties to set
         */
        function Argument(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Argument name.
         * @member {string} name
         * @memberof lens.Argument
         * @instance
         */
        Argument.prototype.name = "";

        /**
         * Argument value.
         * @member {lens.IArgumentValue|null|undefined} value
         * @memberof lens.Argument
         * @instance
         */
        Argument.prototype.value = null;

        /**
         * Creates a new Argument instance using the specified properties.
         * @function create
         * @memberof lens.Argument
         * @static
         * @param {lens.IArgument=} [properties] Properties to set
         * @returns {lens.Argument} Argument instance
         */
        Argument.create = function create(properties) {
            return new Argument(properties);
        };

        /**
         * Encodes the specified Argument message. Does not implicitly {@link lens.Argument.verify|verify} messages.
         * @function encode
         * @memberof lens.Argument
         * @static
         * @param {lens.IArgument} message Argument message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Argument.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
            if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                $root.lens.ArgumentValue.encode(message.value, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Argument message, length delimited. Does not implicitly {@link lens.Argument.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Argument
         * @static
         * @param {lens.IArgument} message Argument message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Argument.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an Argument message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Argument
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Argument} Argument
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Argument.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Argument();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.name = reader.string();
                        break;
                    }
                case 2: {
                        message.value = $root.lens.ArgumentValue.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an Argument message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Argument
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Argument} Argument
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Argument.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an Argument message.
         * @function verify
         * @memberof lens.Argument
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Argument.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.name != null && message.hasOwnProperty("name"))
                if (!$util.isString(message.name))
                    return "name: string expected";
            if (message.value != null && message.hasOwnProperty("value")) {
                var error = $root.lens.ArgumentValue.verify(message.value);
                if (error)
                    return "value." + error;
            }
            return null;
        };

        /**
         * Creates an Argument message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Argument
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Argument} Argument
         */
        Argument.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Argument)
                return object;
            var message = new $root.lens.Argument();
            if (object.name != null)
                message.name = String(object.name);
            if (object.value != null) {
                if (typeof object.value !== "object")
                    throw TypeError(".lens.Argument.value: object expected");
                message.value = $root.lens.ArgumentValue.fromObject(object.value);
            }
            return message;
        };

        /**
         * Creates a plain object from an Argument message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Argument
         * @static
         * @param {lens.Argument} message Argument
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Argument.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.name = "";
                object.value = null;
            }
            if (message.name != null && message.hasOwnProperty("name"))
                object.name = message.name;
            if (message.value != null && message.hasOwnProperty("value"))
                object.value = $root.lens.ArgumentValue.toObject(message.value, options);
            return object;
        };

        /**
         * Converts this Argument to JSON.
         * @function toJSON
         * @memberof lens.Argument
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Argument.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Argument
         * @function getTypeUrl
         * @memberof lens.Argument
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Argument.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Argument";
        };

        return Argument;
    })();

    lens.ArgumentValue = (function() {

        /**
         * Properties of an ArgumentValue.
         * @memberof lens
         * @interface IArgumentValue
         * @property {lens.ISimpleValue|null} [simpleValue] ArgumentValue simpleValue
         */

        /**
         * Constructs a new ArgumentValue.
         * @memberof lens
         * @classdesc Represents an ArgumentValue.
         * @implements IArgumentValue
         * @constructor
         * @param {lens.IArgumentValue=} [properties] Properties to set
         */
        function ArgumentValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ArgumentValue simpleValue.
         * @member {lens.ISimpleValue|null|undefined} simpleValue
         * @memberof lens.ArgumentValue
         * @instance
         */
        ArgumentValue.prototype.simpleValue = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * ArgumentValue value.
         * @member {"simpleValue"|undefined} value
         * @memberof lens.ArgumentValue
         * @instance
         */
        Object.defineProperty(ArgumentValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["simpleValue"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new ArgumentValue instance using the specified properties.
         * @function create
         * @memberof lens.ArgumentValue
         * @static
         * @param {lens.IArgumentValue=} [properties] Properties to set
         * @returns {lens.ArgumentValue} ArgumentValue instance
         */
        ArgumentValue.create = function create(properties) {
            return new ArgumentValue(properties);
        };

        /**
         * Encodes the specified ArgumentValue message. Does not implicitly {@link lens.ArgumentValue.verify|verify} messages.
         * @function encode
         * @memberof lens.ArgumentValue
         * @static
         * @param {lens.IArgumentValue} message ArgumentValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArgumentValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.simpleValue != null && Object.hasOwnProperty.call(message, "simpleValue"))
                $root.lens.SimpleValue.encode(message.simpleValue, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ArgumentValue message, length delimited. Does not implicitly {@link lens.ArgumentValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ArgumentValue
         * @static
         * @param {lens.IArgumentValue} message ArgumentValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ArgumentValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an ArgumentValue message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ArgumentValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ArgumentValue} ArgumentValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArgumentValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ArgumentValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.simpleValue = $root.lens.SimpleValue.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an ArgumentValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ArgumentValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ArgumentValue} ArgumentValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ArgumentValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an ArgumentValue message.
         * @function verify
         * @memberof lens.ArgumentValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ArgumentValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.simpleValue != null && message.hasOwnProperty("simpleValue")) {
                properties.value = 1;
                {
                    var error = $root.lens.SimpleValue.verify(message.simpleValue);
                    if (error)
                        return "simpleValue." + error;
                }
            }
            return null;
        };

        /**
         * Creates an ArgumentValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ArgumentValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ArgumentValue} ArgumentValue
         */
        ArgumentValue.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ArgumentValue)
                return object;
            var message = new $root.lens.ArgumentValue();
            if (object.simpleValue != null) {
                if (typeof object.simpleValue !== "object")
                    throw TypeError(".lens.ArgumentValue.simpleValue: object expected");
                message.simpleValue = $root.lens.SimpleValue.fromObject(object.simpleValue);
            }
            return message;
        };

        /**
         * Creates a plain object from an ArgumentValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ArgumentValue
         * @static
         * @param {lens.ArgumentValue} message ArgumentValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ArgumentValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.simpleValue != null && message.hasOwnProperty("simpleValue")) {
                object.simpleValue = $root.lens.SimpleValue.toObject(message.simpleValue, options);
                if (options.oneofs)
                    object.value = "simpleValue";
            }
            return object;
        };

        /**
         * Converts this ArgumentValue to JSON.
         * @function toJSON
         * @memberof lens.ArgumentValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ArgumentValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ArgumentValue
         * @function getTypeUrl
         * @memberof lens.ArgumentValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ArgumentValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ArgumentValue";
        };

        return ArgumentValue;
    })();

    lens.SimpleValue = (function() {

        /**
         * Properties of a SimpleValue.
         * @memberof lens
         * @interface ISimpleValue
         * @property {string|null} [stringValue] SimpleValue stringValue
         */

        /**
         * Constructs a new SimpleValue.
         * @memberof lens
         * @classdesc Represents a SimpleValue.
         * @implements ISimpleValue
         * @constructor
         * @param {lens.ISimpleValue=} [properties] Properties to set
         */
        function SimpleValue(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SimpleValue stringValue.
         * @member {string|null|undefined} stringValue
         * @memberof lens.SimpleValue
         * @instance
         */
        SimpleValue.prototype.stringValue = null;

        // OneOf field names bound to virtual getters and setters
        var $oneOfFields;

        /**
         * SimpleValue value.
         * @member {"stringValue"|undefined} value
         * @memberof lens.SimpleValue
         * @instance
         */
        Object.defineProperty(SimpleValue.prototype, "value", {
            get: $util.oneOfGetter($oneOfFields = ["stringValue"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Creates a new SimpleValue instance using the specified properties.
         * @function create
         * @memberof lens.SimpleValue
         * @static
         * @param {lens.ISimpleValue=} [properties] Properties to set
         * @returns {lens.SimpleValue} SimpleValue instance
         */
        SimpleValue.create = function create(properties) {
            return new SimpleValue(properties);
        };

        /**
         * Encodes the specified SimpleValue message. Does not implicitly {@link lens.SimpleValue.verify|verify} messages.
         * @function encode
         * @memberof lens.SimpleValue
         * @static
         * @param {lens.ISimpleValue} message SimpleValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleValue.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);
            return writer;
        };

        /**
         * Encodes the specified SimpleValue message, length delimited. Does not implicitly {@link lens.SimpleValue.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.SimpleValue
         * @static
         * @param {lens.ISimpleValue} message SimpleValue message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        SimpleValue.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a SimpleValue message from the specified reader or buffer.
         * @function decode
         * @memberof lens.SimpleValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.SimpleValue} SimpleValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleValue.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.SimpleValue();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.stringValue = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a SimpleValue message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.SimpleValue
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.SimpleValue} SimpleValue
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        SimpleValue.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a SimpleValue message.
         * @function verify
         * @memberof lens.SimpleValue
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SimpleValue.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            var properties = {};
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                properties.value = 1;
                if (!$util.isString(message.stringValue))
                    return "stringValue: string expected";
            }
            return null;
        };

        /**
         * Creates a SimpleValue message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.SimpleValue
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.SimpleValue} SimpleValue
         */
        SimpleValue.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.SimpleValue)
                return object;
            var message = new $root.lens.SimpleValue();
            if (object.stringValue != null)
                message.stringValue = String(object.stringValue);
            return message;
        };

        /**
         * Creates a plain object from a SimpleValue message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.SimpleValue
         * @static
         * @param {lens.SimpleValue} message SimpleValue
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SimpleValue.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                object.stringValue = message.stringValue;
                if (options.oneofs)
                    object.value = "stringValue";
            }
            return object;
        };

        /**
         * Converts this SimpleValue to JSON.
         * @function toJSON
         * @memberof lens.SimpleValue
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SimpleValue.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for SimpleValue
         * @function getTypeUrl
         * @memberof lens.SimpleValue
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        SimpleValue.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.SimpleValue";
        };

        return SimpleValue;
    })();

    lens.TranslateStickinessSignals = (function() {

        /**
         * Properties of a TranslateStickinessSignals.
         * @memberof lens
         * @interface ITranslateStickinessSignals
         * @property {boolean|null} [translateSuppressEchoForSticky] TranslateStickinessSignals translateSuppressEchoForSticky
         */

        /**
         * Constructs a new TranslateStickinessSignals.
         * @memberof lens
         * @classdesc Represents a TranslateStickinessSignals.
         * @implements ITranslateStickinessSignals
         * @constructor
         * @param {lens.ITranslateStickinessSignals=} [properties] Properties to set
         */
        function TranslateStickinessSignals(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TranslateStickinessSignals translateSuppressEchoForSticky.
         * @member {boolean} translateSuppressEchoForSticky
         * @memberof lens.TranslateStickinessSignals
         * @instance
         */
        TranslateStickinessSignals.prototype.translateSuppressEchoForSticky = false;

        /**
         * Creates a new TranslateStickinessSignals instance using the specified properties.
         * @function create
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {lens.ITranslateStickinessSignals=} [properties] Properties to set
         * @returns {lens.TranslateStickinessSignals} TranslateStickinessSignals instance
         */
        TranslateStickinessSignals.create = function create(properties) {
            return new TranslateStickinessSignals(properties);
        };

        /**
         * Encodes the specified TranslateStickinessSignals message. Does not implicitly {@link lens.TranslateStickinessSignals.verify|verify} messages.
         * @function encode
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {lens.ITranslateStickinessSignals} message TranslateStickinessSignals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TranslateStickinessSignals.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.translateSuppressEchoForSticky != null && Object.hasOwnProperty.call(message, "translateSuppressEchoForSticky"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.translateSuppressEchoForSticky);
            return writer;
        };

        /**
         * Encodes the specified TranslateStickinessSignals message, length delimited. Does not implicitly {@link lens.TranslateStickinessSignals.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {lens.ITranslateStickinessSignals} message TranslateStickinessSignals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        TranslateStickinessSignals.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a TranslateStickinessSignals message from the specified reader or buffer.
         * @function decode
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.TranslateStickinessSignals} TranslateStickinessSignals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TranslateStickinessSignals.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.TranslateStickinessSignals();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.translateSuppressEchoForSticky = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a TranslateStickinessSignals message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.TranslateStickinessSignals} TranslateStickinessSignals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        TranslateStickinessSignals.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a TranslateStickinessSignals message.
         * @function verify
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TranslateStickinessSignals.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.translateSuppressEchoForSticky != null && message.hasOwnProperty("translateSuppressEchoForSticky"))
                if (typeof message.translateSuppressEchoForSticky !== "boolean")
                    return "translateSuppressEchoForSticky: boolean expected";
            return null;
        };

        /**
         * Creates a TranslateStickinessSignals message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.TranslateStickinessSignals} TranslateStickinessSignals
         */
        TranslateStickinessSignals.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.TranslateStickinessSignals)
                return object;
            var message = new $root.lens.TranslateStickinessSignals();
            if (object.translateSuppressEchoForSticky != null)
                message.translateSuppressEchoForSticky = Boolean(object.translateSuppressEchoForSticky);
            return message;
        };

        /**
         * Creates a plain object from a TranslateStickinessSignals message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {lens.TranslateStickinessSignals} message TranslateStickinessSignals
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TranslateStickinessSignals.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.translateSuppressEchoForSticky = false;
            if (message.translateSuppressEchoForSticky != null && message.hasOwnProperty("translateSuppressEchoForSticky"))
                object.translateSuppressEchoForSticky = message.translateSuppressEchoForSticky;
            return object;
        };

        /**
         * Converts this TranslateStickinessSignals to JSON.
         * @function toJSON
         * @memberof lens.TranslateStickinessSignals
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TranslateStickinessSignals.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for TranslateStickinessSignals
         * @function getTypeUrl
         * @memberof lens.TranslateStickinessSignals
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        TranslateStickinessSignals.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.TranslateStickinessSignals";
        };

        return TranslateStickinessSignals;
    })();

    lens.Query = (function() {

        /**
         * Properties of a Query.
         * @memberof lens
         * @interface IQuery
         * @property {lens.IFunctionCall|null} [intentQuery] Query intentQuery
         */

        /**
         * Constructs a new Query.
         * @memberof lens
         * @classdesc Represents a Query.
         * @implements IQuery
         * @constructor
         * @param {lens.IQuery=} [properties] Properties to set
         */
        function Query(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Query intentQuery.
         * @member {lens.IFunctionCall|null|undefined} intentQuery
         * @memberof lens.Query
         * @instance
         */
        Query.prototype.intentQuery = null;

        /**
         * Creates a new Query instance using the specified properties.
         * @function create
         * @memberof lens.Query
         * @static
         * @param {lens.IQuery=} [properties] Properties to set
         * @returns {lens.Query} Query instance
         */
        Query.create = function create(properties) {
            return new Query(properties);
        };

        /**
         * Encodes the specified Query message. Does not implicitly {@link lens.Query.verify|verify} messages.
         * @function encode
         * @memberof lens.Query
         * @static
         * @param {lens.IQuery} message Query message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Query.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.intentQuery != null && Object.hasOwnProperty.call(message, "intentQuery"))
                $root.lens.FunctionCall.encode(message.intentQuery, writer.uint32(/* id 56249026, wireType 2 =*/449992210).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Query message, length delimited. Does not implicitly {@link lens.Query.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Query
         * @static
         * @param {lens.IQuery} message Query message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Query.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Query message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Query
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Query} Query
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Query.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Query();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 56249026: {
                        message.intentQuery = $root.lens.FunctionCall.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Query message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Query
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Query} Query
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Query.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Query message.
         * @function verify
         * @memberof lens.Query
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Query.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.intentQuery != null && message.hasOwnProperty("intentQuery")) {
                var error = $root.lens.FunctionCall.verify(message.intentQuery);
                if (error)
                    return "intentQuery." + error;
            }
            return null;
        };

        /**
         * Creates a Query message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Query
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Query} Query
         */
        Query.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Query)
                return object;
            var message = new $root.lens.Query();
            if (object.intentQuery != null) {
                if (typeof object.intentQuery !== "object")
                    throw TypeError(".lens.Query.intentQuery: object expected");
                message.intentQuery = $root.lens.FunctionCall.fromObject(object.intentQuery);
            }
            return message;
        };

        /**
         * Creates a plain object from a Query message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Query
         * @static
         * @param {lens.Query} message Query
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Query.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.intentQuery = null;
            if (message.intentQuery != null && message.hasOwnProperty("intentQuery"))
                object.intentQuery = $root.lens.FunctionCall.toObject(message.intentQuery, options);
            return object;
        };

        /**
         * Converts this Query to JSON.
         * @function toJSON
         * @memberof lens.Query
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Query.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Query
         * @function getTypeUrl
         * @memberof lens.Query
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Query.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Query";
        };

        return Query;
    })();

    lens.MathSolverQuery = (function() {

        /**
         * Properties of a MathSolverQuery.
         * @memberof lens
         * @interface IMathSolverQuery
         * @property {string|null} [mathInputEquation] MathSolverQuery mathInputEquation
         */

        /**
         * Constructs a new MathSolverQuery.
         * @memberof lens
         * @classdesc Represents a MathSolverQuery.
         * @implements IMathSolverQuery
         * @constructor
         * @param {lens.IMathSolverQuery=} [properties] Properties to set
         */
        function MathSolverQuery(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MathSolverQuery mathInputEquation.
         * @member {string} mathInputEquation
         * @memberof lens.MathSolverQuery
         * @instance
         */
        MathSolverQuery.prototype.mathInputEquation = "";

        /**
         * Creates a new MathSolverQuery instance using the specified properties.
         * @function create
         * @memberof lens.MathSolverQuery
         * @static
         * @param {lens.IMathSolverQuery=} [properties] Properties to set
         * @returns {lens.MathSolverQuery} MathSolverQuery instance
         */
        MathSolverQuery.create = function create(properties) {
            return new MathSolverQuery(properties);
        };

        /**
         * Encodes the specified MathSolverQuery message. Does not implicitly {@link lens.MathSolverQuery.verify|verify} messages.
         * @function encode
         * @memberof lens.MathSolverQuery
         * @static
         * @param {lens.IMathSolverQuery} message MathSolverQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MathSolverQuery.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mathInputEquation != null && Object.hasOwnProperty.call(message, "mathInputEquation"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.mathInputEquation);
            return writer;
        };

        /**
         * Encodes the specified MathSolverQuery message, length delimited. Does not implicitly {@link lens.MathSolverQuery.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.MathSolverQuery
         * @static
         * @param {lens.IMathSolverQuery} message MathSolverQuery message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MathSolverQuery.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MathSolverQuery message from the specified reader or buffer.
         * @function decode
         * @memberof lens.MathSolverQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.MathSolverQuery} MathSolverQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MathSolverQuery.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.MathSolverQuery();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.mathInputEquation = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MathSolverQuery message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.MathSolverQuery
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.MathSolverQuery} MathSolverQuery
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MathSolverQuery.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MathSolverQuery message.
         * @function verify
         * @memberof lens.MathSolverQuery
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MathSolverQuery.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mathInputEquation != null && message.hasOwnProperty("mathInputEquation"))
                if (!$util.isString(message.mathInputEquation))
                    return "mathInputEquation: string expected";
            return null;
        };

        /**
         * Creates a MathSolverQuery message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.MathSolverQuery
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.MathSolverQuery} MathSolverQuery
         */
        MathSolverQuery.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.MathSolverQuery)
                return object;
            var message = new $root.lens.MathSolverQuery();
            if (object.mathInputEquation != null)
                message.mathInputEquation = String(object.mathInputEquation);
            return message;
        };

        /**
         * Creates a plain object from a MathSolverQuery message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.MathSolverQuery
         * @static
         * @param {lens.MathSolverQuery} message MathSolverQuery
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MathSolverQuery.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mathInputEquation = "";
            if (message.mathInputEquation != null && message.hasOwnProperty("mathInputEquation"))
                object.mathInputEquation = message.mathInputEquation;
            return object;
        };

        /**
         * Converts this MathSolverQuery to JSON.
         * @function toJSON
         * @memberof lens.MathSolverQuery
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MathSolverQuery.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MathSolverQuery
         * @function getTypeUrl
         * @memberof lens.MathSolverQuery
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MathSolverQuery.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.MathSolverQuery";
        };

        return MathSolverQuery;
    })();

    lens.MessageSet = (function() {

        /**
         * Properties of a MessageSet.
         * @memberof lens
         * @interface IMessageSet
         * @property {lens.IQuery|null} [messageSetExtension] MessageSet messageSetExtension
         */

        /**
         * Constructs a new MessageSet.
         * @memberof lens
         * @classdesc Represents a MessageSet.
         * @implements IMessageSet
         * @constructor
         * @param {lens.IMessageSet=} [properties] Properties to set
         */
        function MessageSet(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageSet messageSetExtension.
         * @member {lens.IQuery|null|undefined} messageSetExtension
         * @memberof lens.MessageSet
         * @instance
         */
        MessageSet.prototype.messageSetExtension = null;

        /**
         * Creates a new MessageSet instance using the specified properties.
         * @function create
         * @memberof lens.MessageSet
         * @static
         * @param {lens.IMessageSet=} [properties] Properties to set
         * @returns {lens.MessageSet} MessageSet instance
         */
        MessageSet.create = function create(properties) {
            return new MessageSet(properties);
        };

        /**
         * Encodes the specified MessageSet message. Does not implicitly {@link lens.MessageSet.verify|verify} messages.
         * @function encode
         * @memberof lens.MessageSet
         * @static
         * @param {lens.IMessageSet} message MessageSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageSet.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.messageSetExtension != null && Object.hasOwnProperty.call(message, "messageSetExtension"))
                $root.lens.Query.encode(message.messageSetExtension, writer.uint32(/* id 41401449, wireType 2 =*/331211594).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified MessageSet message, length delimited. Does not implicitly {@link lens.MessageSet.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.MessageSet
         * @static
         * @param {lens.IMessageSet} message MessageSet message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        MessageSet.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a MessageSet message from the specified reader or buffer.
         * @function decode
         * @memberof lens.MessageSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.MessageSet} MessageSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageSet.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.MessageSet();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 41401449: {
                        message.messageSetExtension = $root.lens.Query.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a MessageSet message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.MessageSet
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.MessageSet} MessageSet
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        MessageSet.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a MessageSet message.
         * @function verify
         * @memberof lens.MessageSet
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageSet.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.messageSetExtension != null && message.hasOwnProperty("messageSetExtension")) {
                var error = $root.lens.Query.verify(message.messageSetExtension);
                if (error)
                    return "messageSetExtension." + error;
            }
            return null;
        };

        /**
         * Creates a MessageSet message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.MessageSet
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.MessageSet} MessageSet
         */
        MessageSet.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.MessageSet)
                return object;
            var message = new $root.lens.MessageSet();
            if (object.messageSetExtension != null) {
                if (typeof object.messageSetExtension !== "object")
                    throw TypeError(".lens.MessageSet.messageSetExtension: object expected");
                message.messageSetExtension = $root.lens.Query.fromObject(object.messageSetExtension);
            }
            return message;
        };

        /**
         * Creates a plain object from a MessageSet message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.MessageSet
         * @static
         * @param {lens.MessageSet} message MessageSet
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageSet.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.messageSetExtension = null;
            if (message.messageSetExtension != null && message.hasOwnProperty("messageSetExtension"))
                object.messageSetExtension = $root.lens.Query.toObject(message.messageSetExtension, options);
            return object;
        };

        /**
         * Converts this MessageSet to JSON.
         * @function toJSON
         * @memberof lens.MessageSet
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageSet.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for MessageSet
         * @function getTypeUrl
         * @memberof lens.MessageSet
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        MessageSet.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.MessageSet";
        };

        return MessageSet;
    })();

    lens.OverlayObject = (function() {

        /**
         * Properties of an OverlayObject.
         * @memberof lens
         * @interface IOverlayObject
         * @property {string|null} [id] OverlayObject id
         * @property {lens.IGeometry|null} [geometry] OverlayObject geometry
         * @property {lens.OverlayObject.IRenderingMetadata|null} [renderingMetadata] OverlayObject renderingMetadata
         * @property {lens.OverlayObject.IInteractionProperties|null} [interactionProperties] OverlayObject interactionProperties
         * @property {boolean|null} [isFulfilled] OverlayObject isFulfilled
         */

        /**
         * Constructs a new OverlayObject.
         * @memberof lens
         * @classdesc Represents an OverlayObject.
         * @implements IOverlayObject
         * @constructor
         * @param {lens.IOverlayObject=} [properties] Properties to set
         */
        function OverlayObject(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * OverlayObject id.
         * @member {string} id
         * @memberof lens.OverlayObject
         * @instance
         */
        OverlayObject.prototype.id = "";

        /**
         * OverlayObject geometry.
         * @member {lens.IGeometry|null|undefined} geometry
         * @memberof lens.OverlayObject
         * @instance
         */
        OverlayObject.prototype.geometry = null;

        /**
         * OverlayObject renderingMetadata.
         * @member {lens.OverlayObject.IRenderingMetadata|null|undefined} renderingMetadata
         * @memberof lens.OverlayObject
         * @instance
         */
        OverlayObject.prototype.renderingMetadata = null;

        /**
         * OverlayObject interactionProperties.
         * @member {lens.OverlayObject.IInteractionProperties|null|undefined} interactionProperties
         * @memberof lens.OverlayObject
         * @instance
         */
        OverlayObject.prototype.interactionProperties = null;

        /**
         * OverlayObject isFulfilled.
         * @member {boolean} isFulfilled
         * @memberof lens.OverlayObject
         * @instance
         */
        OverlayObject.prototype.isFulfilled = false;

        /**
         * Creates a new OverlayObject instance using the specified properties.
         * @function create
         * @memberof lens.OverlayObject
         * @static
         * @param {lens.IOverlayObject=} [properties] Properties to set
         * @returns {lens.OverlayObject} OverlayObject instance
         */
        OverlayObject.create = function create(properties) {
            return new OverlayObject(properties);
        };

        /**
         * Encodes the specified OverlayObject message. Does not implicitly {@link lens.OverlayObject.verify|verify} messages.
         * @function encode
         * @memberof lens.OverlayObject
         * @static
         * @param {lens.IOverlayObject} message OverlayObject message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OverlayObject.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.id);
            if (message.geometry != null && Object.hasOwnProperty.call(message, "geometry"))
                $root.lens.Geometry.encode(message.geometry, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.interactionProperties != null && Object.hasOwnProperty.call(message, "interactionProperties"))
                $root.lens.OverlayObject.InteractionProperties.encode(message.interactionProperties, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.renderingMetadata != null && Object.hasOwnProperty.call(message, "renderingMetadata"))
                $root.lens.OverlayObject.RenderingMetadata.encode(message.renderingMetadata, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
            if (message.isFulfilled != null && Object.hasOwnProperty.call(message, "isFulfilled"))
                writer.uint32(/* id 9, wireType 0 =*/72).bool(message.isFulfilled);
            return writer;
        };

        /**
         * Encodes the specified OverlayObject message, length delimited. Does not implicitly {@link lens.OverlayObject.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.OverlayObject
         * @static
         * @param {lens.IOverlayObject} message OverlayObject message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        OverlayObject.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an OverlayObject message from the specified reader or buffer.
         * @function decode
         * @memberof lens.OverlayObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.OverlayObject} OverlayObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OverlayObject.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.OverlayObject();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.id = reader.string();
                        break;
                    }
                case 2: {
                        message.geometry = $root.lens.Geometry.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.renderingMetadata = $root.lens.OverlayObject.RenderingMetadata.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.interactionProperties = $root.lens.OverlayObject.InteractionProperties.decode(reader, reader.uint32());
                        break;
                    }
                case 9: {
                        message.isFulfilled = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an OverlayObject message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.OverlayObject
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.OverlayObject} OverlayObject
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        OverlayObject.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an OverlayObject message.
         * @function verify
         * @memberof lens.OverlayObject
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        OverlayObject.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.id != null && message.hasOwnProperty("id"))
                if (!$util.isString(message.id))
                    return "id: string expected";
            if (message.geometry != null && message.hasOwnProperty("geometry")) {
                var error = $root.lens.Geometry.verify(message.geometry);
                if (error)
                    return "geometry." + error;
            }
            if (message.renderingMetadata != null && message.hasOwnProperty("renderingMetadata")) {
                var error = $root.lens.OverlayObject.RenderingMetadata.verify(message.renderingMetadata);
                if (error)
                    return "renderingMetadata." + error;
            }
            if (message.interactionProperties != null && message.hasOwnProperty("interactionProperties")) {
                var error = $root.lens.OverlayObject.InteractionProperties.verify(message.interactionProperties);
                if (error)
                    return "interactionProperties." + error;
            }
            if (message.isFulfilled != null && message.hasOwnProperty("isFulfilled"))
                if (typeof message.isFulfilled !== "boolean")
                    return "isFulfilled: boolean expected";
            return null;
        };

        /**
         * Creates an OverlayObject message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.OverlayObject
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.OverlayObject} OverlayObject
         */
        OverlayObject.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.OverlayObject)
                return object;
            var message = new $root.lens.OverlayObject();
            if (object.id != null)
                message.id = String(object.id);
            if (object.geometry != null) {
                if (typeof object.geometry !== "object")
                    throw TypeError(".lens.OverlayObject.geometry: object expected");
                message.geometry = $root.lens.Geometry.fromObject(object.geometry);
            }
            if (object.renderingMetadata != null) {
                if (typeof object.renderingMetadata !== "object")
                    throw TypeError(".lens.OverlayObject.renderingMetadata: object expected");
                message.renderingMetadata = $root.lens.OverlayObject.RenderingMetadata.fromObject(object.renderingMetadata);
            }
            if (object.interactionProperties != null) {
                if (typeof object.interactionProperties !== "object")
                    throw TypeError(".lens.OverlayObject.interactionProperties: object expected");
                message.interactionProperties = $root.lens.OverlayObject.InteractionProperties.fromObject(object.interactionProperties);
            }
            if (object.isFulfilled != null)
                message.isFulfilled = Boolean(object.isFulfilled);
            return message;
        };

        /**
         * Creates a plain object from an OverlayObject message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.OverlayObject
         * @static
         * @param {lens.OverlayObject} message OverlayObject
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        OverlayObject.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.id = "";
                object.geometry = null;
                object.interactionProperties = null;
                object.renderingMetadata = null;
                object.isFulfilled = false;
            }
            if (message.id != null && message.hasOwnProperty("id"))
                object.id = message.id;
            if (message.geometry != null && message.hasOwnProperty("geometry"))
                object.geometry = $root.lens.Geometry.toObject(message.geometry, options);
            if (message.interactionProperties != null && message.hasOwnProperty("interactionProperties"))
                object.interactionProperties = $root.lens.OverlayObject.InteractionProperties.toObject(message.interactionProperties, options);
            if (message.renderingMetadata != null && message.hasOwnProperty("renderingMetadata"))
                object.renderingMetadata = $root.lens.OverlayObject.RenderingMetadata.toObject(message.renderingMetadata, options);
            if (message.isFulfilled != null && message.hasOwnProperty("isFulfilled"))
                object.isFulfilled = message.isFulfilled;
            return object;
        };

        /**
         * Converts this OverlayObject to JSON.
         * @function toJSON
         * @memberof lens.OverlayObject
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        OverlayObject.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for OverlayObject
         * @function getTypeUrl
         * @memberof lens.OverlayObject
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        OverlayObject.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.OverlayObject";
        };

        OverlayObject.RenderingMetadata = (function() {

            /**
             * Properties of a RenderingMetadata.
             * @memberof lens.OverlayObject
             * @interface IRenderingMetadata
             * @property {lens.OverlayObject.RenderingMetadata.RenderType|null} [renderType] RenderingMetadata renderType
             */

            /**
             * Constructs a new RenderingMetadata.
             * @memberof lens.OverlayObject
             * @classdesc Represents a RenderingMetadata.
             * @implements IRenderingMetadata
             * @constructor
             * @param {lens.OverlayObject.IRenderingMetadata=} [properties] Properties to set
             */
            function RenderingMetadata(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RenderingMetadata renderType.
             * @member {lens.OverlayObject.RenderingMetadata.RenderType} renderType
             * @memberof lens.OverlayObject.RenderingMetadata
             * @instance
             */
            RenderingMetadata.prototype.renderType = 0;

            /**
             * Creates a new RenderingMetadata instance using the specified properties.
             * @function create
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {lens.OverlayObject.IRenderingMetadata=} [properties] Properties to set
             * @returns {lens.OverlayObject.RenderingMetadata} RenderingMetadata instance
             */
            RenderingMetadata.create = function create(properties) {
                return new RenderingMetadata(properties);
            };

            /**
             * Encodes the specified RenderingMetadata message. Does not implicitly {@link lens.OverlayObject.RenderingMetadata.verify|verify} messages.
             * @function encode
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {lens.OverlayObject.IRenderingMetadata} message RenderingMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenderingMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.renderType != null && Object.hasOwnProperty.call(message, "renderType"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.renderType);
                return writer;
            };

            /**
             * Encodes the specified RenderingMetadata message, length delimited. Does not implicitly {@link lens.OverlayObject.RenderingMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {lens.OverlayObject.IRenderingMetadata} message RenderingMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RenderingMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RenderingMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.OverlayObject.RenderingMetadata} RenderingMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenderingMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.OverlayObject.RenderingMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.renderType = reader.int32();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RenderingMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.OverlayObject.RenderingMetadata} RenderingMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RenderingMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RenderingMetadata message.
             * @function verify
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RenderingMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.renderType != null && message.hasOwnProperty("renderType"))
                    switch (message.renderType) {
                    default:
                        return "renderType: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a RenderingMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.OverlayObject.RenderingMetadata} RenderingMetadata
             */
            RenderingMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.OverlayObject.RenderingMetadata)
                    return object;
                var message = new $root.lens.OverlayObject.RenderingMetadata();
                switch (object.renderType) {
                default:
                    if (typeof object.renderType === "number") {
                        message.renderType = object.renderType;
                        break;
                    }
                    break;
                case "DEFAULT":
                case 0:
                    message.renderType = 0;
                    break;
                case "GLEAM":
                case 1:
                    message.renderType = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a RenderingMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {lens.OverlayObject.RenderingMetadata} message RenderingMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RenderingMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.renderType = options.enums === String ? "DEFAULT" : 0;
                if (message.renderType != null && message.hasOwnProperty("renderType"))
                    object.renderType = options.enums === String ? $root.lens.OverlayObject.RenderingMetadata.RenderType[message.renderType] === undefined ? message.renderType : $root.lens.OverlayObject.RenderingMetadata.RenderType[message.renderType] : message.renderType;
                return object;
            };

            /**
             * Converts this RenderingMetadata to JSON.
             * @function toJSON
             * @memberof lens.OverlayObject.RenderingMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RenderingMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for RenderingMetadata
             * @function getTypeUrl
             * @memberof lens.OverlayObject.RenderingMetadata
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            RenderingMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.OverlayObject.RenderingMetadata";
            };

            /**
             * RenderType enum.
             * @name lens.OverlayObject.RenderingMetadata.RenderType
             * @enum {number}
             * @property {number} DEFAULT=0 DEFAULT value
             * @property {number} GLEAM=1 GLEAM value
             */
            RenderingMetadata.RenderType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "DEFAULT"] = 0;
                values[valuesById[1] = "GLEAM"] = 1;
                return values;
            })();

            return RenderingMetadata;
        })();

        OverlayObject.InteractionProperties = (function() {

            /**
             * Properties of an InteractionProperties.
             * @memberof lens.OverlayObject
             * @interface IInteractionProperties
             * @property {boolean|null} [selectOnTap] InteractionProperties selectOnTap
             */

            /**
             * Constructs a new InteractionProperties.
             * @memberof lens.OverlayObject
             * @classdesc Represents an InteractionProperties.
             * @implements IInteractionProperties
             * @constructor
             * @param {lens.OverlayObject.IInteractionProperties=} [properties] Properties to set
             */
            function InteractionProperties(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * InteractionProperties selectOnTap.
             * @member {boolean} selectOnTap
             * @memberof lens.OverlayObject.InteractionProperties
             * @instance
             */
            InteractionProperties.prototype.selectOnTap = false;

            /**
             * Creates a new InteractionProperties instance using the specified properties.
             * @function create
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {lens.OverlayObject.IInteractionProperties=} [properties] Properties to set
             * @returns {lens.OverlayObject.InteractionProperties} InteractionProperties instance
             */
            InteractionProperties.create = function create(properties) {
                return new InteractionProperties(properties);
            };

            /**
             * Encodes the specified InteractionProperties message. Does not implicitly {@link lens.OverlayObject.InteractionProperties.verify|verify} messages.
             * @function encode
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {lens.OverlayObject.IInteractionProperties} message InteractionProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InteractionProperties.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.selectOnTap != null && Object.hasOwnProperty.call(message, "selectOnTap"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.selectOnTap);
                return writer;
            };

            /**
             * Encodes the specified InteractionProperties message, length delimited. Does not implicitly {@link lens.OverlayObject.InteractionProperties.verify|verify} messages.
             * @function encodeDelimited
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {lens.OverlayObject.IInteractionProperties} message InteractionProperties message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            InteractionProperties.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an InteractionProperties message from the specified reader or buffer.
             * @function decode
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {lens.OverlayObject.InteractionProperties} InteractionProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InteractionProperties.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.OverlayObject.InteractionProperties();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1: {
                            message.selectOnTap = reader.bool();
                            break;
                        }
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an InteractionProperties message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {lens.OverlayObject.InteractionProperties} InteractionProperties
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            InteractionProperties.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an InteractionProperties message.
             * @function verify
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            InteractionProperties.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.selectOnTap != null && message.hasOwnProperty("selectOnTap"))
                    if (typeof message.selectOnTap !== "boolean")
                        return "selectOnTap: boolean expected";
                return null;
            };

            /**
             * Creates an InteractionProperties message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {lens.OverlayObject.InteractionProperties} InteractionProperties
             */
            InteractionProperties.fromObject = function fromObject(object) {
                if (object instanceof $root.lens.OverlayObject.InteractionProperties)
                    return object;
                var message = new $root.lens.OverlayObject.InteractionProperties();
                if (object.selectOnTap != null)
                    message.selectOnTap = Boolean(object.selectOnTap);
                return message;
            };

            /**
             * Creates a plain object from an InteractionProperties message. Also converts values to other types if specified.
             * @function toObject
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {lens.OverlayObject.InteractionProperties} message InteractionProperties
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            InteractionProperties.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.selectOnTap = false;
                if (message.selectOnTap != null && message.hasOwnProperty("selectOnTap"))
                    object.selectOnTap = message.selectOnTap;
                return object;
            };

            /**
             * Converts this InteractionProperties to JSON.
             * @function toJSON
             * @memberof lens.OverlayObject.InteractionProperties
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            InteractionProperties.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Gets the default type url for InteractionProperties
             * @function getTypeUrl
             * @memberof lens.OverlayObject.InteractionProperties
             * @static
             * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
             * @returns {string} The default type url
             */
            InteractionProperties.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
                if (typeUrlPrefix === undefined) {
                    typeUrlPrefix = "type.googleapis.com";
                }
                return typeUrlPrefix + "/lens.OverlayObject.InteractionProperties";
            };

            return InteractionProperties;
        })();

        return OverlayObject;
    })();

    lens.LensOverlayRequestId = (function() {

        /**
         * Properties of a LensOverlayRequestId.
         * @memberof lens
         * @interface ILensOverlayRequestId
         * @property {number|Long|null} [uuid] LensOverlayRequestId uuid
         * @property {number|null} [sequenceId] LensOverlayRequestId sequenceId
         * @property {number|null} [imageSequenceId] LensOverlayRequestId imageSequenceId
         * @property {Uint8Array|null} [analyticsId] LensOverlayRequestId analyticsId
         * @property {number|null} [longContextId] LensOverlayRequestId longContextId
         * @property {lens.ILensOverlayRoutingInfo|null} [routingInfo] LensOverlayRequestId routingInfo
         */

        /**
         * Constructs a new LensOverlayRequestId.
         * @memberof lens
         * @classdesc Represents a LensOverlayRequestId.
         * @implements ILensOverlayRequestId
         * @constructor
         * @param {lens.ILensOverlayRequestId=} [properties] Properties to set
         */
        function LensOverlayRequestId(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayRequestId uuid.
         * @member {number|Long} uuid
         * @memberof lens.LensOverlayRequestId
         * @instance
         */
        LensOverlayRequestId.prototype.uuid = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * LensOverlayRequestId sequenceId.
         * @member {number} sequenceId
         * @memberof lens.LensOverlayRequestId
         * @instance
         */
        LensOverlayRequestId.prototype.sequenceId = 0;

        /**
         * LensOverlayRequestId imageSequenceId.
         * @member {number} imageSequenceId
         * @memberof lens.LensOverlayRequestId
         * @instance
         */
        LensOverlayRequestId.prototype.imageSequenceId = 0;

        /**
         * LensOverlayRequestId analyticsId.
         * @member {Uint8Array} analyticsId
         * @memberof lens.LensOverlayRequestId
         * @instance
         */
        LensOverlayRequestId.prototype.analyticsId = $util.newBuffer([]);

        /**
         * LensOverlayRequestId longContextId.
         * @member {number} longContextId
         * @memberof lens.LensOverlayRequestId
         * @instance
         */
        LensOverlayRequestId.prototype.longContextId = 0;

        /**
         * LensOverlayRequestId routingInfo.
         * @member {lens.ILensOverlayRoutingInfo|null|undefined} routingInfo
         * @memberof lens.LensOverlayRequestId
         * @instance
         */
        LensOverlayRequestId.prototype.routingInfo = null;

        /**
         * Creates a new LensOverlayRequestId instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {lens.ILensOverlayRequestId=} [properties] Properties to set
         * @returns {lens.LensOverlayRequestId} LensOverlayRequestId instance
         */
        LensOverlayRequestId.create = function create(properties) {
            return new LensOverlayRequestId(properties);
        };

        /**
         * Encodes the specified LensOverlayRequestId message. Does not implicitly {@link lens.LensOverlayRequestId.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {lens.ILensOverlayRequestId} message LensOverlayRequestId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayRequestId.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.uuid != null && Object.hasOwnProperty.call(message, "uuid"))
                writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.uuid);
            if (message.sequenceId != null && Object.hasOwnProperty.call(message, "sequenceId"))
                writer.uint32(/* id 2, wireType 0 =*/16).int32(message.sequenceId);
            if (message.imageSequenceId != null && Object.hasOwnProperty.call(message, "imageSequenceId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.imageSequenceId);
            if (message.analyticsId != null && Object.hasOwnProperty.call(message, "analyticsId"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.analyticsId);
            if (message.routingInfo != null && Object.hasOwnProperty.call(message, "routingInfo"))
                $root.lens.LensOverlayRoutingInfo.encode(message.routingInfo, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            if (message.longContextId != null && Object.hasOwnProperty.call(message, "longContextId"))
                writer.uint32(/* id 9, wireType 0 =*/72).int32(message.longContextId);
            return writer;
        };

        /**
         * Encodes the specified LensOverlayRequestId message, length delimited. Does not implicitly {@link lens.LensOverlayRequestId.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {lens.ILensOverlayRequestId} message LensOverlayRequestId message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayRequestId.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayRequestId message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayRequestId} LensOverlayRequestId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayRequestId.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayRequestId();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.uuid = reader.uint64();
                        break;
                    }
                case 2: {
                        message.sequenceId = reader.int32();
                        break;
                    }
                case 3: {
                        message.imageSequenceId = reader.int32();
                        break;
                    }
                case 4: {
                        message.analyticsId = reader.bytes();
                        break;
                    }
                case 9: {
                        message.longContextId = reader.int32();
                        break;
                    }
                case 6: {
                        message.routingInfo = $root.lens.LensOverlayRoutingInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayRequestId message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayRequestId} LensOverlayRequestId
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayRequestId.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayRequestId message.
         * @function verify
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayRequestId.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                if (!$util.isInteger(message.uuid) && !(message.uuid && $util.isInteger(message.uuid.low) && $util.isInteger(message.uuid.high)))
                    return "uuid: integer|Long expected";
            if (message.sequenceId != null && message.hasOwnProperty("sequenceId"))
                if (!$util.isInteger(message.sequenceId))
                    return "sequenceId: integer expected";
            if (message.imageSequenceId != null && message.hasOwnProperty("imageSequenceId"))
                if (!$util.isInteger(message.imageSequenceId))
                    return "imageSequenceId: integer expected";
            if (message.analyticsId != null && message.hasOwnProperty("analyticsId"))
                if (!(message.analyticsId && typeof message.analyticsId.length === "number" || $util.isString(message.analyticsId)))
                    return "analyticsId: buffer expected";
            if (message.longContextId != null && message.hasOwnProperty("longContextId"))
                if (!$util.isInteger(message.longContextId))
                    return "longContextId: integer expected";
            if (message.routingInfo != null && message.hasOwnProperty("routingInfo")) {
                var error = $root.lens.LensOverlayRoutingInfo.verify(message.routingInfo);
                if (error)
                    return "routingInfo." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayRequestId message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayRequestId} LensOverlayRequestId
         */
        LensOverlayRequestId.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayRequestId)
                return object;
            var message = new $root.lens.LensOverlayRequestId();
            if (object.uuid != null)
                if ($util.Long)
                    (message.uuid = $util.Long.fromValue(object.uuid)).unsigned = true;
                else if (typeof object.uuid === "string")
                    message.uuid = parseInt(object.uuid, 10);
                else if (typeof object.uuid === "number")
                    message.uuid = object.uuid;
                else if (typeof object.uuid === "object")
                    message.uuid = new $util.LongBits(object.uuid.low >>> 0, object.uuid.high >>> 0).toNumber(true);
            if (object.sequenceId != null)
                message.sequenceId = object.sequenceId | 0;
            if (object.imageSequenceId != null)
                message.imageSequenceId = object.imageSequenceId | 0;
            if (object.analyticsId != null)
                if (typeof object.analyticsId === "string")
                    $util.base64.decode(object.analyticsId, message.analyticsId = $util.newBuffer($util.base64.length(object.analyticsId)), 0);
                else if (object.analyticsId.length >= 0)
                    message.analyticsId = object.analyticsId;
            if (object.longContextId != null)
                message.longContextId = object.longContextId | 0;
            if (object.routingInfo != null) {
                if (typeof object.routingInfo !== "object")
                    throw TypeError(".lens.LensOverlayRequestId.routingInfo: object expected");
                message.routingInfo = $root.lens.LensOverlayRoutingInfo.fromObject(object.routingInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayRequestId message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {lens.LensOverlayRequestId} message LensOverlayRequestId
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayRequestId.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, true);
                    object.uuid = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.uuid = options.longs === String ? "0" : 0;
                object.sequenceId = 0;
                object.imageSequenceId = 0;
                if (options.bytes === String)
                    object.analyticsId = "";
                else {
                    object.analyticsId = [];
                    if (options.bytes !== Array)
                        object.analyticsId = $util.newBuffer(object.analyticsId);
                }
                object.routingInfo = null;
                object.longContextId = 0;
            }
            if (message.uuid != null && message.hasOwnProperty("uuid"))
                if (typeof message.uuid === "number")
                    object.uuid = options.longs === String ? String(message.uuid) : message.uuid;
                else
                    object.uuid = options.longs === String ? $util.Long.prototype.toString.call(message.uuid) : options.longs === Number ? new $util.LongBits(message.uuid.low >>> 0, message.uuid.high >>> 0).toNumber(true) : message.uuid;
            if (message.sequenceId != null && message.hasOwnProperty("sequenceId"))
                object.sequenceId = message.sequenceId;
            if (message.imageSequenceId != null && message.hasOwnProperty("imageSequenceId"))
                object.imageSequenceId = message.imageSequenceId;
            if (message.analyticsId != null && message.hasOwnProperty("analyticsId"))
                object.analyticsId = options.bytes === String ? $util.base64.encode(message.analyticsId, 0, message.analyticsId.length) : options.bytes === Array ? Array.prototype.slice.call(message.analyticsId) : message.analyticsId;
            if (message.routingInfo != null && message.hasOwnProperty("routingInfo"))
                object.routingInfo = $root.lens.LensOverlayRoutingInfo.toObject(message.routingInfo, options);
            if (message.longContextId != null && message.hasOwnProperty("longContextId"))
                object.longContextId = message.longContextId;
            return object;
        };

        /**
         * Converts this LensOverlayRequestId to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayRequestId
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayRequestId.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayRequestId
         * @function getTypeUrl
         * @memberof lens.LensOverlayRequestId
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayRequestId.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayRequestId";
        };

        return LensOverlayRequestId;
    })();

    /**
     * RequestType enum.
     * @name lens.RequestType
     * @enum {number}
     * @property {number} REQUEST_TYPE_DEFAULT=0 REQUEST_TYPE_DEFAULT value
     * @property {number} REQUEST_TYPE_PDF=1 REQUEST_TYPE_PDF value
     * @property {number} REQUEST_TYPE_EARLY_PARTIAL_PDF=3 REQUEST_TYPE_EARLY_PARTIAL_PDF value
     * @property {number} REQUEST_TYPE_WEBPAGE=2 REQUEST_TYPE_WEBPAGE value
     */
    lens.RequestType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "REQUEST_TYPE_DEFAULT"] = 0;
        values[valuesById[1] = "REQUEST_TYPE_PDF"] = 1;
        values[valuesById[3] = "REQUEST_TYPE_EARLY_PARTIAL_PDF"] = 3;
        values[valuesById[2] = "REQUEST_TYPE_WEBPAGE"] = 2;
        return values;
    })();

    /**
     * LensOverlaySelectionType enum.
     * @name lens.LensOverlaySelectionType
     * @enum {number}
     * @property {number} UNKNOWN_SELECTION_TYPE=0 UNKNOWN_SELECTION_TYPE value
     * @property {number} TAP_ON_EMPTY=1 TAP_ON_EMPTY value
     * @property {number} SELECT_TEXT_HIGHLIGHT=3 SELECT_TEXT_HIGHLIGHT value
     * @property {number} REGION_SEARCH=7 REGION_SEARCH value
     * @property {number} INJECTED_IMAGE=10 INJECTED_IMAGE value
     * @property {number} TAP_ON_REGION_GLEAM=15 TAP_ON_REGION_GLEAM value
     * @property {number} MULTIMODAL_SEARCH=18 MULTIMODAL_SEARCH value
     * @property {number} SELECT_TRANSLATED_TEXT=21 SELECT_TRANSLATED_TEXT value
     * @property {number} TAP_ON_OBJECT=22 TAP_ON_OBJECT value
     * @property {number} MULTIMODAL_SUGGEST_TYPEAHEAD=25 MULTIMODAL_SUGGEST_TYPEAHEAD value
     * @property {number} MULTIMODAL_SUGGEST_ZERO_PREFIX=26 MULTIMODAL_SUGGEST_ZERO_PREFIX value
     * @property {number} TRANSLATE_CHIP=52 TRANSLATE_CHIP value
     * @property {number} SYMBOLIC_MATH_OBJECT=53 SYMBOLIC_MATH_OBJECT value
     */
    lens.LensOverlaySelectionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN_SELECTION_TYPE"] = 0;
        values[valuesById[1] = "TAP_ON_EMPTY"] = 1;
        values[valuesById[3] = "SELECT_TEXT_HIGHLIGHT"] = 3;
        values[valuesById[7] = "REGION_SEARCH"] = 7;
        values[valuesById[10] = "INJECTED_IMAGE"] = 10;
        values[valuesById[15] = "TAP_ON_REGION_GLEAM"] = 15;
        values[valuesById[18] = "MULTIMODAL_SEARCH"] = 18;
        values[valuesById[21] = "SELECT_TRANSLATED_TEXT"] = 21;
        values[valuesById[22] = "TAP_ON_OBJECT"] = 22;
        values[valuesById[25] = "MULTIMODAL_SUGGEST_TYPEAHEAD"] = 25;
        values[valuesById[26] = "MULTIMODAL_SUGGEST_ZERO_PREFIX"] = 26;
        values[valuesById[52] = "TRANSLATE_CHIP"] = 52;
        values[valuesById[53] = "SYMBOLIC_MATH_OBJECT"] = 53;
        return values;
    })();

    lens.LensOverlayServerClusterInfoRequest = (function() {

        /**
         * Properties of a LensOverlayServerClusterInfoRequest.
         * @memberof lens
         * @interface ILensOverlayServerClusterInfoRequest
         * @property {boolean|null} [enableSearchSessionId] LensOverlayServerClusterInfoRequest enableSearchSessionId
         */

        /**
         * Constructs a new LensOverlayServerClusterInfoRequest.
         * @memberof lens
         * @classdesc Represents a LensOverlayServerClusterInfoRequest.
         * @implements ILensOverlayServerClusterInfoRequest
         * @constructor
         * @param {lens.ILensOverlayServerClusterInfoRequest=} [properties] Properties to set
         */
        function LensOverlayServerClusterInfoRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayServerClusterInfoRequest enableSearchSessionId.
         * @member {boolean} enableSearchSessionId
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @instance
         */
        LensOverlayServerClusterInfoRequest.prototype.enableSearchSessionId = false;

        /**
         * Creates a new LensOverlayServerClusterInfoRequest instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {lens.ILensOverlayServerClusterInfoRequest=} [properties] Properties to set
         * @returns {lens.LensOverlayServerClusterInfoRequest} LensOverlayServerClusterInfoRequest instance
         */
        LensOverlayServerClusterInfoRequest.create = function create(properties) {
            return new LensOverlayServerClusterInfoRequest(properties);
        };

        /**
         * Encodes the specified LensOverlayServerClusterInfoRequest message. Does not implicitly {@link lens.LensOverlayServerClusterInfoRequest.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {lens.ILensOverlayServerClusterInfoRequest} message LensOverlayServerClusterInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerClusterInfoRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.enableSearchSessionId != null && Object.hasOwnProperty.call(message, "enableSearchSessionId"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.enableSearchSessionId);
            return writer;
        };

        /**
         * Encodes the specified LensOverlayServerClusterInfoRequest message, length delimited. Does not implicitly {@link lens.LensOverlayServerClusterInfoRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {lens.ILensOverlayServerClusterInfoRequest} message LensOverlayServerClusterInfoRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerClusterInfoRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayServerClusterInfoRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayServerClusterInfoRequest} LensOverlayServerClusterInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerClusterInfoRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayServerClusterInfoRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.enableSearchSessionId = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayServerClusterInfoRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayServerClusterInfoRequest} LensOverlayServerClusterInfoRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerClusterInfoRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayServerClusterInfoRequest message.
         * @function verify
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayServerClusterInfoRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.enableSearchSessionId != null && message.hasOwnProperty("enableSearchSessionId"))
                if (typeof message.enableSearchSessionId !== "boolean")
                    return "enableSearchSessionId: boolean expected";
            return null;
        };

        /**
         * Creates a LensOverlayServerClusterInfoRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayServerClusterInfoRequest} LensOverlayServerClusterInfoRequest
         */
        LensOverlayServerClusterInfoRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayServerClusterInfoRequest)
                return object;
            var message = new $root.lens.LensOverlayServerClusterInfoRequest();
            if (object.enableSearchSessionId != null)
                message.enableSearchSessionId = Boolean(object.enableSearchSessionId);
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayServerClusterInfoRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {lens.LensOverlayServerClusterInfoRequest} message LensOverlayServerClusterInfoRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayServerClusterInfoRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.enableSearchSessionId = false;
            if (message.enableSearchSessionId != null && message.hasOwnProperty("enableSearchSessionId"))
                object.enableSearchSessionId = message.enableSearchSessionId;
            return object;
        };

        /**
         * Converts this LensOverlayServerClusterInfoRequest to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayServerClusterInfoRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayServerClusterInfoRequest
         * @function getTypeUrl
         * @memberof lens.LensOverlayServerClusterInfoRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayServerClusterInfoRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayServerClusterInfoRequest";
        };

        return LensOverlayServerClusterInfoRequest;
    })();

    lens.LensOverlayServerClusterInfoResponse = (function() {

        /**
         * Properties of a LensOverlayServerClusterInfoResponse.
         * @memberof lens
         * @interface ILensOverlayServerClusterInfoResponse
         * @property {string|null} [serverSessionId] LensOverlayServerClusterInfoResponse serverSessionId
         * @property {string|null} [searchSessionId] LensOverlayServerClusterInfoResponse searchSessionId
         * @property {lens.ILensOverlayRoutingInfo|null} [routingInfo] LensOverlayServerClusterInfoResponse routingInfo
         */

        /**
         * Constructs a new LensOverlayServerClusterInfoResponse.
         * @memberof lens
         * @classdesc Represents a LensOverlayServerClusterInfoResponse.
         * @implements ILensOverlayServerClusterInfoResponse
         * @constructor
         * @param {lens.ILensOverlayServerClusterInfoResponse=} [properties] Properties to set
         */
        function LensOverlayServerClusterInfoResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayServerClusterInfoResponse serverSessionId.
         * @member {string} serverSessionId
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @instance
         */
        LensOverlayServerClusterInfoResponse.prototype.serverSessionId = "";

        /**
         * LensOverlayServerClusterInfoResponse searchSessionId.
         * @member {string} searchSessionId
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @instance
         */
        LensOverlayServerClusterInfoResponse.prototype.searchSessionId = "";

        /**
         * LensOverlayServerClusterInfoResponse routingInfo.
         * @member {lens.ILensOverlayRoutingInfo|null|undefined} routingInfo
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @instance
         */
        LensOverlayServerClusterInfoResponse.prototype.routingInfo = null;

        /**
         * Creates a new LensOverlayServerClusterInfoResponse instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {lens.ILensOverlayServerClusterInfoResponse=} [properties] Properties to set
         * @returns {lens.LensOverlayServerClusterInfoResponse} LensOverlayServerClusterInfoResponse instance
         */
        LensOverlayServerClusterInfoResponse.create = function create(properties) {
            return new LensOverlayServerClusterInfoResponse(properties);
        };

        /**
         * Encodes the specified LensOverlayServerClusterInfoResponse message. Does not implicitly {@link lens.LensOverlayServerClusterInfoResponse.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {lens.ILensOverlayServerClusterInfoResponse} message LensOverlayServerClusterInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerClusterInfoResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.serverSessionId != null && Object.hasOwnProperty.call(message, "serverSessionId"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.serverSessionId);
            if (message.searchSessionId != null && Object.hasOwnProperty.call(message, "searchSessionId"))
                writer.uint32(/* id 2, wireType 2 =*/18).string(message.searchSessionId);
            if (message.routingInfo != null && Object.hasOwnProperty.call(message, "routingInfo"))
                $root.lens.LensOverlayRoutingInfo.encode(message.routingInfo, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayServerClusterInfoResponse message, length delimited. Does not implicitly {@link lens.LensOverlayServerClusterInfoResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {lens.ILensOverlayServerClusterInfoResponse} message LensOverlayServerClusterInfoResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerClusterInfoResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayServerClusterInfoResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayServerClusterInfoResponse} LensOverlayServerClusterInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerClusterInfoResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayServerClusterInfoResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.serverSessionId = reader.string();
                        break;
                    }
                case 2: {
                        message.searchSessionId = reader.string();
                        break;
                    }
                case 3: {
                        message.routingInfo = $root.lens.LensOverlayRoutingInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayServerClusterInfoResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayServerClusterInfoResponse} LensOverlayServerClusterInfoResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerClusterInfoResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayServerClusterInfoResponse message.
         * @function verify
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayServerClusterInfoResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.serverSessionId != null && message.hasOwnProperty("serverSessionId"))
                if (!$util.isString(message.serverSessionId))
                    return "serverSessionId: string expected";
            if (message.searchSessionId != null && message.hasOwnProperty("searchSessionId"))
                if (!$util.isString(message.searchSessionId))
                    return "searchSessionId: string expected";
            if (message.routingInfo != null && message.hasOwnProperty("routingInfo")) {
                var error = $root.lens.LensOverlayRoutingInfo.verify(message.routingInfo);
                if (error)
                    return "routingInfo." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayServerClusterInfoResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayServerClusterInfoResponse} LensOverlayServerClusterInfoResponse
         */
        LensOverlayServerClusterInfoResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayServerClusterInfoResponse)
                return object;
            var message = new $root.lens.LensOverlayServerClusterInfoResponse();
            if (object.serverSessionId != null)
                message.serverSessionId = String(object.serverSessionId);
            if (object.searchSessionId != null)
                message.searchSessionId = String(object.searchSessionId);
            if (object.routingInfo != null) {
                if (typeof object.routingInfo !== "object")
                    throw TypeError(".lens.LensOverlayServerClusterInfoResponse.routingInfo: object expected");
                message.routingInfo = $root.lens.LensOverlayRoutingInfo.fromObject(object.routingInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayServerClusterInfoResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {lens.LensOverlayServerClusterInfoResponse} message LensOverlayServerClusterInfoResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayServerClusterInfoResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.serverSessionId = "";
                object.searchSessionId = "";
                object.routingInfo = null;
            }
            if (message.serverSessionId != null && message.hasOwnProperty("serverSessionId"))
                object.serverSessionId = message.serverSessionId;
            if (message.searchSessionId != null && message.hasOwnProperty("searchSessionId"))
                object.searchSessionId = message.searchSessionId;
            if (message.routingInfo != null && message.hasOwnProperty("routingInfo"))
                object.routingInfo = $root.lens.LensOverlayRoutingInfo.toObject(message.routingInfo, options);
            return object;
        };

        /**
         * Converts this LensOverlayServerClusterInfoResponse to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayServerClusterInfoResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayServerClusterInfoResponse
         * @function getTypeUrl
         * @memberof lens.LensOverlayServerClusterInfoResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayServerClusterInfoResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayServerClusterInfoResponse";
        };

        return LensOverlayServerClusterInfoResponse;
    })();

    lens.LensOverlayServerError = (function() {

        /**
         * Properties of a LensOverlayServerError.
         * @memberof lens
         * @interface ILensOverlayServerError
         * @property {lens.LensOverlayServerError.ErrorType|null} [errorType] LensOverlayServerError errorType
         */

        /**
         * Constructs a new LensOverlayServerError.
         * @memberof lens
         * @classdesc Represents a LensOverlayServerError.
         * @implements ILensOverlayServerError
         * @constructor
         * @param {lens.ILensOverlayServerError=} [properties] Properties to set
         */
        function LensOverlayServerError(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayServerError errorType.
         * @member {lens.LensOverlayServerError.ErrorType} errorType
         * @memberof lens.LensOverlayServerError
         * @instance
         */
        LensOverlayServerError.prototype.errorType = 0;

        /**
         * Creates a new LensOverlayServerError instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {lens.ILensOverlayServerError=} [properties] Properties to set
         * @returns {lens.LensOverlayServerError} LensOverlayServerError instance
         */
        LensOverlayServerError.create = function create(properties) {
            return new LensOverlayServerError(properties);
        };

        /**
         * Encodes the specified LensOverlayServerError message. Does not implicitly {@link lens.LensOverlayServerError.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {lens.ILensOverlayServerError} message LensOverlayServerError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerError.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.errorType != null && Object.hasOwnProperty.call(message, "errorType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.errorType);
            return writer;
        };

        /**
         * Encodes the specified LensOverlayServerError message, length delimited. Does not implicitly {@link lens.LensOverlayServerError.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {lens.ILensOverlayServerError} message LensOverlayServerError message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerError.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayServerError message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayServerError} LensOverlayServerError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerError.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayServerError();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.errorType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayServerError message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayServerError} LensOverlayServerError
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerError.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayServerError message.
         * @function verify
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayServerError.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.errorType != null && message.hasOwnProperty("errorType"))
                switch (message.errorType) {
                default:
                    return "errorType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            return null;
        };

        /**
         * Creates a LensOverlayServerError message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayServerError} LensOverlayServerError
         */
        LensOverlayServerError.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayServerError)
                return object;
            var message = new $root.lens.LensOverlayServerError();
            switch (object.errorType) {
            default:
                if (typeof object.errorType === "number") {
                    message.errorType = object.errorType;
                    break;
                }
                break;
            case "UNKNOWN_TYPE":
            case 0:
                message.errorType = 0;
                break;
            case "MISSING_REQUEST":
            case 1:
                message.errorType = 1;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayServerError message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {lens.LensOverlayServerError} message LensOverlayServerError
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayServerError.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.errorType = options.enums === String ? "UNKNOWN_TYPE" : 0;
            if (message.errorType != null && message.hasOwnProperty("errorType"))
                object.errorType = options.enums === String ? $root.lens.LensOverlayServerError.ErrorType[message.errorType] === undefined ? message.errorType : $root.lens.LensOverlayServerError.ErrorType[message.errorType] : message.errorType;
            return object;
        };

        /**
         * Converts this LensOverlayServerError to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayServerError
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayServerError.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayServerError
         * @function getTypeUrl
         * @memberof lens.LensOverlayServerError
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayServerError.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayServerError";
        };

        /**
         * ErrorType enum.
         * @name lens.LensOverlayServerError.ErrorType
         * @enum {number}
         * @property {number} UNKNOWN_TYPE=0 UNKNOWN_TYPE value
         * @property {number} MISSING_REQUEST=1 MISSING_REQUEST value
         */
        LensOverlayServerError.ErrorType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN_TYPE"] = 0;
            values[valuesById[1] = "MISSING_REQUEST"] = 1;
            return values;
        })();

        return LensOverlayServerError;
    })();

    lens.LensOverlayServerRequest = (function() {

        /**
         * Properties of a LensOverlayServerRequest.
         * @memberof lens
         * @interface ILensOverlayServerRequest
         * @property {lens.ILensOverlayObjectsRequest|null} [objectsRequest] LensOverlayServerRequest objectsRequest
         * @property {lens.ILensOverlayInteractionRequest|null} [interactionRequest] LensOverlayServerRequest interactionRequest
         * @property {lens.ILensOverlayClientLogs|null} [clientLogs] LensOverlayServerRequest clientLogs
         */

        /**
         * Constructs a new LensOverlayServerRequest.
         * @memberof lens
         * @classdesc Represents a LensOverlayServerRequest.
         * @implements ILensOverlayServerRequest
         * @constructor
         * @param {lens.ILensOverlayServerRequest=} [properties] Properties to set
         */
        function LensOverlayServerRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayServerRequest objectsRequest.
         * @member {lens.ILensOverlayObjectsRequest|null|undefined} objectsRequest
         * @memberof lens.LensOverlayServerRequest
         * @instance
         */
        LensOverlayServerRequest.prototype.objectsRequest = null;

        /**
         * LensOverlayServerRequest interactionRequest.
         * @member {lens.ILensOverlayInteractionRequest|null|undefined} interactionRequest
         * @memberof lens.LensOverlayServerRequest
         * @instance
         */
        LensOverlayServerRequest.prototype.interactionRequest = null;

        /**
         * LensOverlayServerRequest clientLogs.
         * @member {lens.ILensOverlayClientLogs|null|undefined} clientLogs
         * @memberof lens.LensOverlayServerRequest
         * @instance
         */
        LensOverlayServerRequest.prototype.clientLogs = null;

        /**
         * Creates a new LensOverlayServerRequest instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {lens.ILensOverlayServerRequest=} [properties] Properties to set
         * @returns {lens.LensOverlayServerRequest} LensOverlayServerRequest instance
         */
        LensOverlayServerRequest.create = function create(properties) {
            return new LensOverlayServerRequest(properties);
        };

        /**
         * Encodes the specified LensOverlayServerRequest message. Does not implicitly {@link lens.LensOverlayServerRequest.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {lens.ILensOverlayServerRequest} message LensOverlayServerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.objectsRequest != null && Object.hasOwnProperty.call(message, "objectsRequest"))
                $root.lens.LensOverlayObjectsRequest.encode(message.objectsRequest, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.interactionRequest != null && Object.hasOwnProperty.call(message, "interactionRequest"))
                $root.lens.LensOverlayInteractionRequest.encode(message.interactionRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.clientLogs != null && Object.hasOwnProperty.call(message, "clientLogs"))
                $root.lens.LensOverlayClientLogs.encode(message.clientLogs, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayServerRequest message, length delimited. Does not implicitly {@link lens.LensOverlayServerRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {lens.ILensOverlayServerRequest} message LensOverlayServerRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayServerRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayServerRequest} LensOverlayServerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayServerRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.objectsRequest = $root.lens.LensOverlayObjectsRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.interactionRequest = $root.lens.LensOverlayInteractionRequest.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.clientLogs = $root.lens.LensOverlayClientLogs.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayServerRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayServerRequest} LensOverlayServerRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayServerRequest message.
         * @function verify
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayServerRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.objectsRequest != null && message.hasOwnProperty("objectsRequest")) {
                var error = $root.lens.LensOverlayObjectsRequest.verify(message.objectsRequest);
                if (error)
                    return "objectsRequest." + error;
            }
            if (message.interactionRequest != null && message.hasOwnProperty("interactionRequest")) {
                var error = $root.lens.LensOverlayInteractionRequest.verify(message.interactionRequest);
                if (error)
                    return "interactionRequest." + error;
            }
            if (message.clientLogs != null && message.hasOwnProperty("clientLogs")) {
                var error = $root.lens.LensOverlayClientLogs.verify(message.clientLogs);
                if (error)
                    return "clientLogs." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayServerRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayServerRequest} LensOverlayServerRequest
         */
        LensOverlayServerRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayServerRequest)
                return object;
            var message = new $root.lens.LensOverlayServerRequest();
            if (object.objectsRequest != null) {
                if (typeof object.objectsRequest !== "object")
                    throw TypeError(".lens.LensOverlayServerRequest.objectsRequest: object expected");
                message.objectsRequest = $root.lens.LensOverlayObjectsRequest.fromObject(object.objectsRequest);
            }
            if (object.interactionRequest != null) {
                if (typeof object.interactionRequest !== "object")
                    throw TypeError(".lens.LensOverlayServerRequest.interactionRequest: object expected");
                message.interactionRequest = $root.lens.LensOverlayInteractionRequest.fromObject(object.interactionRequest);
            }
            if (object.clientLogs != null) {
                if (typeof object.clientLogs !== "object")
                    throw TypeError(".lens.LensOverlayServerRequest.clientLogs: object expected");
                message.clientLogs = $root.lens.LensOverlayClientLogs.fromObject(object.clientLogs);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayServerRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {lens.LensOverlayServerRequest} message LensOverlayServerRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayServerRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.objectsRequest = null;
                object.interactionRequest = null;
                object.clientLogs = null;
            }
            if (message.objectsRequest != null && message.hasOwnProperty("objectsRequest"))
                object.objectsRequest = $root.lens.LensOverlayObjectsRequest.toObject(message.objectsRequest, options);
            if (message.interactionRequest != null && message.hasOwnProperty("interactionRequest"))
                object.interactionRequest = $root.lens.LensOverlayInteractionRequest.toObject(message.interactionRequest, options);
            if (message.clientLogs != null && message.hasOwnProperty("clientLogs"))
                object.clientLogs = $root.lens.LensOverlayClientLogs.toObject(message.clientLogs, options);
            return object;
        };

        /**
         * Converts this LensOverlayServerRequest to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayServerRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayServerRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayServerRequest
         * @function getTypeUrl
         * @memberof lens.LensOverlayServerRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayServerRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayServerRequest";
        };

        return LensOverlayServerRequest;
    })();

    lens.LensOverlayServerResponse = (function() {

        /**
         * Properties of a LensOverlayServerResponse.
         * @memberof lens
         * @interface ILensOverlayServerResponse
         * @property {lens.ILensOverlayServerError|null} [error] LensOverlayServerResponse error
         * @property {lens.ILensOverlayObjectsResponse|null} [objectsResponse] LensOverlayServerResponse objectsResponse
         * @property {lens.ILensOverlayInteractionResponse|null} [interactionResponse] LensOverlayServerResponse interactionResponse
         */

        /**
         * Constructs a new LensOverlayServerResponse.
         * @memberof lens
         * @classdesc Represents a LensOverlayServerResponse.
         * @implements ILensOverlayServerResponse
         * @constructor
         * @param {lens.ILensOverlayServerResponse=} [properties] Properties to set
         */
        function LensOverlayServerResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayServerResponse error.
         * @member {lens.ILensOverlayServerError|null|undefined} error
         * @memberof lens.LensOverlayServerResponse
         * @instance
         */
        LensOverlayServerResponse.prototype.error = null;

        /**
         * LensOverlayServerResponse objectsResponse.
         * @member {lens.ILensOverlayObjectsResponse|null|undefined} objectsResponse
         * @memberof lens.LensOverlayServerResponse
         * @instance
         */
        LensOverlayServerResponse.prototype.objectsResponse = null;

        /**
         * LensOverlayServerResponse interactionResponse.
         * @member {lens.ILensOverlayInteractionResponse|null|undefined} interactionResponse
         * @memberof lens.LensOverlayServerResponse
         * @instance
         */
        LensOverlayServerResponse.prototype.interactionResponse = null;

        /**
         * Creates a new LensOverlayServerResponse instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {lens.ILensOverlayServerResponse=} [properties] Properties to set
         * @returns {lens.LensOverlayServerResponse} LensOverlayServerResponse instance
         */
        LensOverlayServerResponse.create = function create(properties) {
            return new LensOverlayServerResponse(properties);
        };

        /**
         * Encodes the specified LensOverlayServerResponse message. Does not implicitly {@link lens.LensOverlayServerResponse.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {lens.ILensOverlayServerResponse} message LensOverlayServerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                $root.lens.LensOverlayServerError.encode(message.error, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.objectsResponse != null && Object.hasOwnProperty.call(message, "objectsResponse"))
                $root.lens.LensOverlayObjectsResponse.encode(message.objectsResponse, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.interactionResponse != null && Object.hasOwnProperty.call(message, "interactionResponse"))
                $root.lens.LensOverlayInteractionResponse.encode(message.interactionResponse, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayServerResponse message, length delimited. Does not implicitly {@link lens.LensOverlayServerResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {lens.ILensOverlayServerResponse} message LensOverlayServerResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayServerResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayServerResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayServerResponse} LensOverlayServerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayServerResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.error = $root.lens.LensOverlayServerError.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.objectsResponse = $root.lens.LensOverlayObjectsResponse.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.interactionResponse = $root.lens.LensOverlayInteractionResponse.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayServerResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayServerResponse} LensOverlayServerResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayServerResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayServerResponse message.
         * @function verify
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayServerResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.error != null && message.hasOwnProperty("error")) {
                var error = $root.lens.LensOverlayServerError.verify(message.error);
                if (error)
                    return "error." + error;
            }
            if (message.objectsResponse != null && message.hasOwnProperty("objectsResponse")) {
                var error = $root.lens.LensOverlayObjectsResponse.verify(message.objectsResponse);
                if (error)
                    return "objectsResponse." + error;
            }
            if (message.interactionResponse != null && message.hasOwnProperty("interactionResponse")) {
                var error = $root.lens.LensOverlayInteractionResponse.verify(message.interactionResponse);
                if (error)
                    return "interactionResponse." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayServerResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayServerResponse} LensOverlayServerResponse
         */
        LensOverlayServerResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayServerResponse)
                return object;
            var message = new $root.lens.LensOverlayServerResponse();
            if (object.error != null) {
                if (typeof object.error !== "object")
                    throw TypeError(".lens.LensOverlayServerResponse.error: object expected");
                message.error = $root.lens.LensOverlayServerError.fromObject(object.error);
            }
            if (object.objectsResponse != null) {
                if (typeof object.objectsResponse !== "object")
                    throw TypeError(".lens.LensOverlayServerResponse.objectsResponse: object expected");
                message.objectsResponse = $root.lens.LensOverlayObjectsResponse.fromObject(object.objectsResponse);
            }
            if (object.interactionResponse != null) {
                if (typeof object.interactionResponse !== "object")
                    throw TypeError(".lens.LensOverlayServerResponse.interactionResponse: object expected");
                message.interactionResponse = $root.lens.LensOverlayInteractionResponse.fromObject(object.interactionResponse);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayServerResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {lens.LensOverlayServerResponse} message LensOverlayServerResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayServerResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.error = null;
                object.objectsResponse = null;
                object.interactionResponse = null;
            }
            if (message.error != null && message.hasOwnProperty("error"))
                object.error = $root.lens.LensOverlayServerError.toObject(message.error, options);
            if (message.objectsResponse != null && message.hasOwnProperty("objectsResponse"))
                object.objectsResponse = $root.lens.LensOverlayObjectsResponse.toObject(message.objectsResponse, options);
            if (message.interactionResponse != null && message.hasOwnProperty("interactionResponse"))
                object.interactionResponse = $root.lens.LensOverlayInteractionResponse.toObject(message.interactionResponse, options);
            return object;
        };

        /**
         * Converts this LensOverlayServerResponse to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayServerResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayServerResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayServerResponse
         * @function getTypeUrl
         * @memberof lens.LensOverlayServerResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayServerResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayServerResponse";
        };

        return LensOverlayServerResponse;
    })();

    lens.LensOverlayRequestContext = (function() {

        /**
         * Properties of a LensOverlayRequestContext.
         * @memberof lens
         * @interface ILensOverlayRequestContext
         * @property {lens.ILensOverlayRequestId|null} [requestId] LensOverlayRequestContext requestId
         * @property {lens.ILensOverlayClientContext|null} [clientContext] LensOverlayRequestContext clientContext
         */

        /**
         * Constructs a new LensOverlayRequestContext.
         * @memberof lens
         * @classdesc Represents a LensOverlayRequestContext.
         * @implements ILensOverlayRequestContext
         * @constructor
         * @param {lens.ILensOverlayRequestContext=} [properties] Properties to set
         */
        function LensOverlayRequestContext(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayRequestContext requestId.
         * @member {lens.ILensOverlayRequestId|null|undefined} requestId
         * @memberof lens.LensOverlayRequestContext
         * @instance
         */
        LensOverlayRequestContext.prototype.requestId = null;

        /**
         * LensOverlayRequestContext clientContext.
         * @member {lens.ILensOverlayClientContext|null|undefined} clientContext
         * @memberof lens.LensOverlayRequestContext
         * @instance
         */
        LensOverlayRequestContext.prototype.clientContext = null;

        /**
         * Creates a new LensOverlayRequestContext instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {lens.ILensOverlayRequestContext=} [properties] Properties to set
         * @returns {lens.LensOverlayRequestContext} LensOverlayRequestContext instance
         */
        LensOverlayRequestContext.create = function create(properties) {
            return new LensOverlayRequestContext(properties);
        };

        /**
         * Encodes the specified LensOverlayRequestContext message. Does not implicitly {@link lens.LensOverlayRequestContext.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {lens.ILensOverlayRequestContext} message LensOverlayRequestContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayRequestContext.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestId != null && Object.hasOwnProperty.call(message, "requestId"))
                $root.lens.LensOverlayRequestId.encode(message.requestId, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.clientContext != null && Object.hasOwnProperty.call(message, "clientContext"))
                $root.lens.LensOverlayClientContext.encode(message.clientContext, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayRequestContext message, length delimited. Does not implicitly {@link lens.LensOverlayRequestContext.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {lens.ILensOverlayRequestContext} message LensOverlayRequestContext message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayRequestContext.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayRequestContext message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayRequestContext} LensOverlayRequestContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayRequestContext.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayRequestContext();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.requestId = $root.lens.LensOverlayRequestId.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.clientContext = $root.lens.LensOverlayClientContext.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayRequestContext message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayRequestContext} LensOverlayRequestContext
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayRequestContext.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayRequestContext message.
         * @function verify
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayRequestContext.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestId != null && message.hasOwnProperty("requestId")) {
                var error = $root.lens.LensOverlayRequestId.verify(message.requestId);
                if (error)
                    return "requestId." + error;
            }
            if (message.clientContext != null && message.hasOwnProperty("clientContext")) {
                var error = $root.lens.LensOverlayClientContext.verify(message.clientContext);
                if (error)
                    return "clientContext." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayRequestContext message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayRequestContext} LensOverlayRequestContext
         */
        LensOverlayRequestContext.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayRequestContext)
                return object;
            var message = new $root.lens.LensOverlayRequestContext();
            if (object.requestId != null) {
                if (typeof object.requestId !== "object")
                    throw TypeError(".lens.LensOverlayRequestContext.requestId: object expected");
                message.requestId = $root.lens.LensOverlayRequestId.fromObject(object.requestId);
            }
            if (object.clientContext != null) {
                if (typeof object.clientContext !== "object")
                    throw TypeError(".lens.LensOverlayRequestContext.clientContext: object expected");
                message.clientContext = $root.lens.LensOverlayClientContext.fromObject(object.clientContext);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayRequestContext message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {lens.LensOverlayRequestContext} message LensOverlayRequestContext
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayRequestContext.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.requestId = null;
                object.clientContext = null;
            }
            if (message.requestId != null && message.hasOwnProperty("requestId"))
                object.requestId = $root.lens.LensOverlayRequestId.toObject(message.requestId, options);
            if (message.clientContext != null && message.hasOwnProperty("clientContext"))
                object.clientContext = $root.lens.LensOverlayClientContext.toObject(message.clientContext, options);
            return object;
        };

        /**
         * Converts this LensOverlayRequestContext to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayRequestContext
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayRequestContext.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayRequestContext
         * @function getTypeUrl
         * @memberof lens.LensOverlayRequestContext
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayRequestContext.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayRequestContext";
        };

        return LensOverlayRequestContext;
    })();

    lens.LensOverlayObjectsRequest = (function() {

        /**
         * Properties of a LensOverlayObjectsRequest.
         * @memberof lens
         * @interface ILensOverlayObjectsRequest
         * @property {lens.ILensOverlayRequestContext|null} [requestContext] LensOverlayObjectsRequest requestContext
         * @property {lens.IImageData|null} [imageData] LensOverlayObjectsRequest imageData
         * @property {lens.IPayload|null} [payload] LensOverlayObjectsRequest payload
         */

        /**
         * Constructs a new LensOverlayObjectsRequest.
         * @memberof lens
         * @classdesc Represents a LensOverlayObjectsRequest.
         * @implements ILensOverlayObjectsRequest
         * @constructor
         * @param {lens.ILensOverlayObjectsRequest=} [properties] Properties to set
         */
        function LensOverlayObjectsRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayObjectsRequest requestContext.
         * @member {lens.ILensOverlayRequestContext|null|undefined} requestContext
         * @memberof lens.LensOverlayObjectsRequest
         * @instance
         */
        LensOverlayObjectsRequest.prototype.requestContext = null;

        /**
         * LensOverlayObjectsRequest imageData.
         * @member {lens.IImageData|null|undefined} imageData
         * @memberof lens.LensOverlayObjectsRequest
         * @instance
         */
        LensOverlayObjectsRequest.prototype.imageData = null;

        /**
         * LensOverlayObjectsRequest payload.
         * @member {lens.IPayload|null|undefined} payload
         * @memberof lens.LensOverlayObjectsRequest
         * @instance
         */
        LensOverlayObjectsRequest.prototype.payload = null;

        /**
         * Creates a new LensOverlayObjectsRequest instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {lens.ILensOverlayObjectsRequest=} [properties] Properties to set
         * @returns {lens.LensOverlayObjectsRequest} LensOverlayObjectsRequest instance
         */
        LensOverlayObjectsRequest.create = function create(properties) {
            return new LensOverlayObjectsRequest(properties);
        };

        /**
         * Encodes the specified LensOverlayObjectsRequest message. Does not implicitly {@link lens.LensOverlayObjectsRequest.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {lens.ILensOverlayObjectsRequest} message LensOverlayObjectsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayObjectsRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestContext != null && Object.hasOwnProperty.call(message, "requestContext"))
                $root.lens.LensOverlayRequestContext.encode(message.requestContext, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.imageData != null && Object.hasOwnProperty.call(message, "imageData"))
                $root.lens.ImageData.encode(message.imageData, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                $root.lens.Payload.encode(message.payload, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayObjectsRequest message, length delimited. Does not implicitly {@link lens.LensOverlayObjectsRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {lens.ILensOverlayObjectsRequest} message LensOverlayObjectsRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayObjectsRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayObjectsRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayObjectsRequest} LensOverlayObjectsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayObjectsRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayObjectsRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.requestContext = $root.lens.LensOverlayRequestContext.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.imageData = $root.lens.ImageData.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        message.payload = $root.lens.Payload.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayObjectsRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayObjectsRequest} LensOverlayObjectsRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayObjectsRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayObjectsRequest message.
         * @function verify
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayObjectsRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestContext != null && message.hasOwnProperty("requestContext")) {
                var error = $root.lens.LensOverlayRequestContext.verify(message.requestContext);
                if (error)
                    return "requestContext." + error;
            }
            if (message.imageData != null && message.hasOwnProperty("imageData")) {
                var error = $root.lens.ImageData.verify(message.imageData);
                if (error)
                    return "imageData." + error;
            }
            if (message.payload != null && message.hasOwnProperty("payload")) {
                var error = $root.lens.Payload.verify(message.payload);
                if (error)
                    return "payload." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayObjectsRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayObjectsRequest} LensOverlayObjectsRequest
         */
        LensOverlayObjectsRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayObjectsRequest)
                return object;
            var message = new $root.lens.LensOverlayObjectsRequest();
            if (object.requestContext != null) {
                if (typeof object.requestContext !== "object")
                    throw TypeError(".lens.LensOverlayObjectsRequest.requestContext: object expected");
                message.requestContext = $root.lens.LensOverlayRequestContext.fromObject(object.requestContext);
            }
            if (object.imageData != null) {
                if (typeof object.imageData !== "object")
                    throw TypeError(".lens.LensOverlayObjectsRequest.imageData: object expected");
                message.imageData = $root.lens.ImageData.fromObject(object.imageData);
            }
            if (object.payload != null) {
                if (typeof object.payload !== "object")
                    throw TypeError(".lens.LensOverlayObjectsRequest.payload: object expected");
                message.payload = $root.lens.Payload.fromObject(object.payload);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayObjectsRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {lens.LensOverlayObjectsRequest} message LensOverlayObjectsRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayObjectsRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.requestContext = null;
                object.imageData = null;
                object.payload = null;
            }
            if (message.requestContext != null && message.hasOwnProperty("requestContext"))
                object.requestContext = $root.lens.LensOverlayRequestContext.toObject(message.requestContext, options);
            if (message.imageData != null && message.hasOwnProperty("imageData"))
                object.imageData = $root.lens.ImageData.toObject(message.imageData, options);
            if (message.payload != null && message.hasOwnProperty("payload"))
                object.payload = $root.lens.Payload.toObject(message.payload, options);
            return object;
        };

        /**
         * Converts this LensOverlayObjectsRequest to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayObjectsRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayObjectsRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayObjectsRequest
         * @function getTypeUrl
         * @memberof lens.LensOverlayObjectsRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayObjectsRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayObjectsRequest";
        };

        return LensOverlayObjectsRequest;
    })();

    lens.LensOverlayUploadChunkRequest = (function() {

        /**
         * Properties of a LensOverlayUploadChunkRequest.
         * @memberof lens
         * @interface ILensOverlayUploadChunkRequest
         * @property {lens.ILensOverlayRequestContext|null} [requestContext] LensOverlayUploadChunkRequest requestContext
         * @property {lens.IChunkDebugOptions|null} [debugOptions] LensOverlayUploadChunkRequest debugOptions
         * @property {number|Long|null} [chunkId] LensOverlayUploadChunkRequest chunkId
         * @property {Uint8Array|null} [chunkBytes] LensOverlayUploadChunkRequest chunkBytes
         */

        /**
         * Constructs a new LensOverlayUploadChunkRequest.
         * @memberof lens
         * @classdesc Represents a LensOverlayUploadChunkRequest.
         * @implements ILensOverlayUploadChunkRequest
         * @constructor
         * @param {lens.ILensOverlayUploadChunkRequest=} [properties] Properties to set
         */
        function LensOverlayUploadChunkRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayUploadChunkRequest requestContext.
         * @member {lens.ILensOverlayRequestContext|null|undefined} requestContext
         * @memberof lens.LensOverlayUploadChunkRequest
         * @instance
         */
        LensOverlayUploadChunkRequest.prototype.requestContext = null;

        /**
         * LensOverlayUploadChunkRequest debugOptions.
         * @member {lens.IChunkDebugOptions|null|undefined} debugOptions
         * @memberof lens.LensOverlayUploadChunkRequest
         * @instance
         */
        LensOverlayUploadChunkRequest.prototype.debugOptions = null;

        /**
         * LensOverlayUploadChunkRequest chunkId.
         * @member {number|Long} chunkId
         * @memberof lens.LensOverlayUploadChunkRequest
         * @instance
         */
        LensOverlayUploadChunkRequest.prototype.chunkId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * LensOverlayUploadChunkRequest chunkBytes.
         * @member {Uint8Array} chunkBytes
         * @memberof lens.LensOverlayUploadChunkRequest
         * @instance
         */
        LensOverlayUploadChunkRequest.prototype.chunkBytes = $util.newBuffer([]);

        /**
         * Creates a new LensOverlayUploadChunkRequest instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {lens.ILensOverlayUploadChunkRequest=} [properties] Properties to set
         * @returns {lens.LensOverlayUploadChunkRequest} LensOverlayUploadChunkRequest instance
         */
        LensOverlayUploadChunkRequest.create = function create(properties) {
            return new LensOverlayUploadChunkRequest(properties);
        };

        /**
         * Encodes the specified LensOverlayUploadChunkRequest message. Does not implicitly {@link lens.LensOverlayUploadChunkRequest.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {lens.ILensOverlayUploadChunkRequest} message LensOverlayUploadChunkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayUploadChunkRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestContext != null && Object.hasOwnProperty.call(message, "requestContext"))
                $root.lens.LensOverlayRequestContext.encode(message.requestContext, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.chunkId != null && Object.hasOwnProperty.call(message, "chunkId"))
                writer.uint32(/* id 3, wireType 0 =*/24).int64(message.chunkId);
            if (message.chunkBytes != null && Object.hasOwnProperty.call(message, "chunkBytes"))
                writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.chunkBytes);
            if (message.debugOptions != null && Object.hasOwnProperty.call(message, "debugOptions"))
                $root.lens.ChunkDebugOptions.encode(message.debugOptions, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayUploadChunkRequest message, length delimited. Does not implicitly {@link lens.LensOverlayUploadChunkRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {lens.ILensOverlayUploadChunkRequest} message LensOverlayUploadChunkRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayUploadChunkRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayUploadChunkRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayUploadChunkRequest} LensOverlayUploadChunkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayUploadChunkRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayUploadChunkRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.requestContext = $root.lens.LensOverlayRequestContext.decode(reader, reader.uint32());
                        break;
                    }
                case 6: {
                        message.debugOptions = $root.lens.ChunkDebugOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.chunkId = reader.int64();
                        break;
                    }
                case 4: {
                        message.chunkBytes = reader.bytes();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayUploadChunkRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayUploadChunkRequest} LensOverlayUploadChunkRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayUploadChunkRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayUploadChunkRequest message.
         * @function verify
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayUploadChunkRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestContext != null && message.hasOwnProperty("requestContext")) {
                var error = $root.lens.LensOverlayRequestContext.verify(message.requestContext);
                if (error)
                    return "requestContext." + error;
            }
            if (message.debugOptions != null && message.hasOwnProperty("debugOptions")) {
                var error = $root.lens.ChunkDebugOptions.verify(message.debugOptions);
                if (error)
                    return "debugOptions." + error;
            }
            if (message.chunkId != null && message.hasOwnProperty("chunkId"))
                if (!$util.isInteger(message.chunkId) && !(message.chunkId && $util.isInteger(message.chunkId.low) && $util.isInteger(message.chunkId.high)))
                    return "chunkId: integer|Long expected";
            if (message.chunkBytes != null && message.hasOwnProperty("chunkBytes"))
                if (!(message.chunkBytes && typeof message.chunkBytes.length === "number" || $util.isString(message.chunkBytes)))
                    return "chunkBytes: buffer expected";
            return null;
        };

        /**
         * Creates a LensOverlayUploadChunkRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayUploadChunkRequest} LensOverlayUploadChunkRequest
         */
        LensOverlayUploadChunkRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayUploadChunkRequest)
                return object;
            var message = new $root.lens.LensOverlayUploadChunkRequest();
            if (object.requestContext != null) {
                if (typeof object.requestContext !== "object")
                    throw TypeError(".lens.LensOverlayUploadChunkRequest.requestContext: object expected");
                message.requestContext = $root.lens.LensOverlayRequestContext.fromObject(object.requestContext);
            }
            if (object.debugOptions != null) {
                if (typeof object.debugOptions !== "object")
                    throw TypeError(".lens.LensOverlayUploadChunkRequest.debugOptions: object expected");
                message.debugOptions = $root.lens.ChunkDebugOptions.fromObject(object.debugOptions);
            }
            if (object.chunkId != null)
                if ($util.Long)
                    (message.chunkId = $util.Long.fromValue(object.chunkId)).unsigned = false;
                else if (typeof object.chunkId === "string")
                    message.chunkId = parseInt(object.chunkId, 10);
                else if (typeof object.chunkId === "number")
                    message.chunkId = object.chunkId;
                else if (typeof object.chunkId === "object")
                    message.chunkId = new $util.LongBits(object.chunkId.low >>> 0, object.chunkId.high >>> 0).toNumber();
            if (object.chunkBytes != null)
                if (typeof object.chunkBytes === "string")
                    $util.base64.decode(object.chunkBytes, message.chunkBytes = $util.newBuffer($util.base64.length(object.chunkBytes)), 0);
                else if (object.chunkBytes.length >= 0)
                    message.chunkBytes = object.chunkBytes;
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayUploadChunkRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {lens.LensOverlayUploadChunkRequest} message LensOverlayUploadChunkRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayUploadChunkRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.requestContext = null;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.chunkId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.chunkId = options.longs === String ? "0" : 0;
                if (options.bytes === String)
                    object.chunkBytes = "";
                else {
                    object.chunkBytes = [];
                    if (options.bytes !== Array)
                        object.chunkBytes = $util.newBuffer(object.chunkBytes);
                }
                object.debugOptions = null;
            }
            if (message.requestContext != null && message.hasOwnProperty("requestContext"))
                object.requestContext = $root.lens.LensOverlayRequestContext.toObject(message.requestContext, options);
            if (message.chunkId != null && message.hasOwnProperty("chunkId"))
                if (typeof message.chunkId === "number")
                    object.chunkId = options.longs === String ? String(message.chunkId) : message.chunkId;
                else
                    object.chunkId = options.longs === String ? $util.Long.prototype.toString.call(message.chunkId) : options.longs === Number ? new $util.LongBits(message.chunkId.low >>> 0, message.chunkId.high >>> 0).toNumber() : message.chunkId;
            if (message.chunkBytes != null && message.hasOwnProperty("chunkBytes"))
                object.chunkBytes = options.bytes === String ? $util.base64.encode(message.chunkBytes, 0, message.chunkBytes.length) : options.bytes === Array ? Array.prototype.slice.call(message.chunkBytes) : message.chunkBytes;
            if (message.debugOptions != null && message.hasOwnProperty("debugOptions"))
                object.debugOptions = $root.lens.ChunkDebugOptions.toObject(message.debugOptions, options);
            return object;
        };

        /**
         * Converts this LensOverlayUploadChunkRequest to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayUploadChunkRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayUploadChunkRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayUploadChunkRequest
         * @function getTypeUrl
         * @memberof lens.LensOverlayUploadChunkRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayUploadChunkRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayUploadChunkRequest";
        };

        return LensOverlayUploadChunkRequest;
    })();

    lens.LensOverlayUploadChunkResponse = (function() {

        /**
         * Properties of a LensOverlayUploadChunkResponse.
         * @memberof lens
         * @interface ILensOverlayUploadChunkResponse
         * @property {lens.IChunkDebugMetadata|null} [debugMetadata] LensOverlayUploadChunkResponse debugMetadata
         */

        /**
         * Constructs a new LensOverlayUploadChunkResponse.
         * @memberof lens
         * @classdesc Represents a LensOverlayUploadChunkResponse.
         * @implements ILensOverlayUploadChunkResponse
         * @constructor
         * @param {lens.ILensOverlayUploadChunkResponse=} [properties] Properties to set
         */
        function LensOverlayUploadChunkResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayUploadChunkResponse debugMetadata.
         * @member {lens.IChunkDebugMetadata|null|undefined} debugMetadata
         * @memberof lens.LensOverlayUploadChunkResponse
         * @instance
         */
        LensOverlayUploadChunkResponse.prototype.debugMetadata = null;

        /**
         * Creates a new LensOverlayUploadChunkResponse instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {lens.ILensOverlayUploadChunkResponse=} [properties] Properties to set
         * @returns {lens.LensOverlayUploadChunkResponse} LensOverlayUploadChunkResponse instance
         */
        LensOverlayUploadChunkResponse.create = function create(properties) {
            return new LensOverlayUploadChunkResponse(properties);
        };

        /**
         * Encodes the specified LensOverlayUploadChunkResponse message. Does not implicitly {@link lens.LensOverlayUploadChunkResponse.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {lens.ILensOverlayUploadChunkResponse} message LensOverlayUploadChunkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayUploadChunkResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.debugMetadata != null && Object.hasOwnProperty.call(message, "debugMetadata"))
                $root.lens.ChunkDebugMetadata.encode(message.debugMetadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayUploadChunkResponse message, length delimited. Does not implicitly {@link lens.LensOverlayUploadChunkResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {lens.ILensOverlayUploadChunkResponse} message LensOverlayUploadChunkResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayUploadChunkResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayUploadChunkResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayUploadChunkResponse} LensOverlayUploadChunkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayUploadChunkResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayUploadChunkResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        message.debugMetadata = $root.lens.ChunkDebugMetadata.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayUploadChunkResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayUploadChunkResponse} LensOverlayUploadChunkResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayUploadChunkResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayUploadChunkResponse message.
         * @function verify
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayUploadChunkResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.debugMetadata != null && message.hasOwnProperty("debugMetadata")) {
                var error = $root.lens.ChunkDebugMetadata.verify(message.debugMetadata);
                if (error)
                    return "debugMetadata." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayUploadChunkResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayUploadChunkResponse} LensOverlayUploadChunkResponse
         */
        LensOverlayUploadChunkResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayUploadChunkResponse)
                return object;
            var message = new $root.lens.LensOverlayUploadChunkResponse();
            if (object.debugMetadata != null) {
                if (typeof object.debugMetadata !== "object")
                    throw TypeError(".lens.LensOverlayUploadChunkResponse.debugMetadata: object expected");
                message.debugMetadata = $root.lens.ChunkDebugMetadata.fromObject(object.debugMetadata);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayUploadChunkResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {lens.LensOverlayUploadChunkResponse} message LensOverlayUploadChunkResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayUploadChunkResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.debugMetadata = null;
            if (message.debugMetadata != null && message.hasOwnProperty("debugMetadata"))
                object.debugMetadata = $root.lens.ChunkDebugMetadata.toObject(message.debugMetadata, options);
            return object;
        };

        /**
         * Converts this LensOverlayUploadChunkResponse to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayUploadChunkResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayUploadChunkResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayUploadChunkResponse
         * @function getTypeUrl
         * @memberof lens.LensOverlayUploadChunkResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayUploadChunkResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayUploadChunkResponse";
        };

        return LensOverlayUploadChunkResponse;
    })();

    lens.ChunkDebugOptions = (function() {

        /**
         * Properties of a ChunkDebugOptions.
         * @memberof lens
         * @interface IChunkDebugOptions
         * @property {number|Long|null} [totalChunks] ChunkDebugOptions totalChunks
         * @property {boolean|null} [queryChunks] ChunkDebugOptions queryChunks
         */

        /**
         * Constructs a new ChunkDebugOptions.
         * @memberof lens
         * @classdesc Represents a ChunkDebugOptions.
         * @implements IChunkDebugOptions
         * @constructor
         * @param {lens.IChunkDebugOptions=} [properties] Properties to set
         */
        function ChunkDebugOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChunkDebugOptions totalChunks.
         * @member {number|Long} totalChunks
         * @memberof lens.ChunkDebugOptions
         * @instance
         */
        ChunkDebugOptions.prototype.totalChunks = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * ChunkDebugOptions queryChunks.
         * @member {boolean} queryChunks
         * @memberof lens.ChunkDebugOptions
         * @instance
         */
        ChunkDebugOptions.prototype.queryChunks = false;

        /**
         * Creates a new ChunkDebugOptions instance using the specified properties.
         * @function create
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {lens.IChunkDebugOptions=} [properties] Properties to set
         * @returns {lens.ChunkDebugOptions} ChunkDebugOptions instance
         */
        ChunkDebugOptions.create = function create(properties) {
            return new ChunkDebugOptions(properties);
        };

        /**
         * Encodes the specified ChunkDebugOptions message. Does not implicitly {@link lens.ChunkDebugOptions.verify|verify} messages.
         * @function encode
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {lens.IChunkDebugOptions} message ChunkDebugOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkDebugOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.totalChunks != null && Object.hasOwnProperty.call(message, "totalChunks"))
                writer.uint32(/* id 1, wireType 0 =*/8).int64(message.totalChunks);
            if (message.queryChunks != null && Object.hasOwnProperty.call(message, "queryChunks"))
                writer.uint32(/* id 2, wireType 0 =*/16).bool(message.queryChunks);
            return writer;
        };

        /**
         * Encodes the specified ChunkDebugOptions message, length delimited. Does not implicitly {@link lens.ChunkDebugOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {lens.IChunkDebugOptions} message ChunkDebugOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkDebugOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChunkDebugOptions message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ChunkDebugOptions} ChunkDebugOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkDebugOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ChunkDebugOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.totalChunks = reader.int64();
                        break;
                    }
                case 2: {
                        message.queryChunks = reader.bool();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChunkDebugOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ChunkDebugOptions} ChunkDebugOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkDebugOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChunkDebugOptions message.
         * @function verify
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChunkDebugOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.totalChunks != null && message.hasOwnProperty("totalChunks"))
                if (!$util.isInteger(message.totalChunks) && !(message.totalChunks && $util.isInteger(message.totalChunks.low) && $util.isInteger(message.totalChunks.high)))
                    return "totalChunks: integer|Long expected";
            if (message.queryChunks != null && message.hasOwnProperty("queryChunks"))
                if (typeof message.queryChunks !== "boolean")
                    return "queryChunks: boolean expected";
            return null;
        };

        /**
         * Creates a ChunkDebugOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ChunkDebugOptions} ChunkDebugOptions
         */
        ChunkDebugOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ChunkDebugOptions)
                return object;
            var message = new $root.lens.ChunkDebugOptions();
            if (object.totalChunks != null)
                if ($util.Long)
                    (message.totalChunks = $util.Long.fromValue(object.totalChunks)).unsigned = false;
                else if (typeof object.totalChunks === "string")
                    message.totalChunks = parseInt(object.totalChunks, 10);
                else if (typeof object.totalChunks === "number")
                    message.totalChunks = object.totalChunks;
                else if (typeof object.totalChunks === "object")
                    message.totalChunks = new $util.LongBits(object.totalChunks.low >>> 0, object.totalChunks.high >>> 0).toNumber();
            if (object.queryChunks != null)
                message.queryChunks = Boolean(object.queryChunks);
            return message;
        };

        /**
         * Creates a plain object from a ChunkDebugOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {lens.ChunkDebugOptions} message ChunkDebugOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChunkDebugOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalChunks = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalChunks = options.longs === String ? "0" : 0;
                object.queryChunks = false;
            }
            if (message.totalChunks != null && message.hasOwnProperty("totalChunks"))
                if (typeof message.totalChunks === "number")
                    object.totalChunks = options.longs === String ? String(message.totalChunks) : message.totalChunks;
                else
                    object.totalChunks = options.longs === String ? $util.Long.prototype.toString.call(message.totalChunks) : options.longs === Number ? new $util.LongBits(message.totalChunks.low >>> 0, message.totalChunks.high >>> 0).toNumber() : message.totalChunks;
            if (message.queryChunks != null && message.hasOwnProperty("queryChunks"))
                object.queryChunks = message.queryChunks;
            return object;
        };

        /**
         * Converts this ChunkDebugOptions to JSON.
         * @function toJSON
         * @memberof lens.ChunkDebugOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChunkDebugOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChunkDebugOptions
         * @function getTypeUrl
         * @memberof lens.ChunkDebugOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChunkDebugOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ChunkDebugOptions";
        };

        return ChunkDebugOptions;
    })();

    lens.ChunkDebugMetadata = (function() {

        /**
         * Properties of a ChunkDebugMetadata.
         * @memberof lens
         * @interface IChunkDebugMetadata
         * @property {Array.<number|Long>|null} [remainingChunks] ChunkDebugMetadata remainingChunks
         */

        /**
         * Constructs a new ChunkDebugMetadata.
         * @memberof lens
         * @classdesc Represents a ChunkDebugMetadata.
         * @implements IChunkDebugMetadata
         * @constructor
         * @param {lens.IChunkDebugMetadata=} [properties] Properties to set
         */
        function ChunkDebugMetadata(properties) {
            this.remainingChunks = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ChunkDebugMetadata remainingChunks.
         * @member {Array.<number|Long>} remainingChunks
         * @memberof lens.ChunkDebugMetadata
         * @instance
         */
        ChunkDebugMetadata.prototype.remainingChunks = $util.emptyArray;

        /**
         * Creates a new ChunkDebugMetadata instance using the specified properties.
         * @function create
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {lens.IChunkDebugMetadata=} [properties] Properties to set
         * @returns {lens.ChunkDebugMetadata} ChunkDebugMetadata instance
         */
        ChunkDebugMetadata.create = function create(properties) {
            return new ChunkDebugMetadata(properties);
        };

        /**
         * Encodes the specified ChunkDebugMetadata message. Does not implicitly {@link lens.ChunkDebugMetadata.verify|verify} messages.
         * @function encode
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {lens.IChunkDebugMetadata} message ChunkDebugMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkDebugMetadata.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.remainingChunks != null && message.remainingChunks.length) {
                writer.uint32(/* id 1, wireType 2 =*/10).fork();
                for (var i = 0; i < message.remainingChunks.length; ++i)
                    writer.int64(message.remainingChunks[i]);
                writer.ldelim();
            }
            return writer;
        };

        /**
         * Encodes the specified ChunkDebugMetadata message, length delimited. Does not implicitly {@link lens.ChunkDebugMetadata.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {lens.IChunkDebugMetadata} message ChunkDebugMetadata message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ChunkDebugMetadata.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ChunkDebugMetadata message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ChunkDebugMetadata} ChunkDebugMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkDebugMetadata.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ChunkDebugMetadata();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        if (!(message.remainingChunks && message.remainingChunks.length))
                            message.remainingChunks = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.remainingChunks.push(reader.int64());
                        } else
                            message.remainingChunks.push(reader.int64());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ChunkDebugMetadata message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ChunkDebugMetadata} ChunkDebugMetadata
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ChunkDebugMetadata.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ChunkDebugMetadata message.
         * @function verify
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ChunkDebugMetadata.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.remainingChunks != null && message.hasOwnProperty("remainingChunks")) {
                if (!Array.isArray(message.remainingChunks))
                    return "remainingChunks: array expected";
                for (var i = 0; i < message.remainingChunks.length; ++i)
                    if (!$util.isInteger(message.remainingChunks[i]) && !(message.remainingChunks[i] && $util.isInteger(message.remainingChunks[i].low) && $util.isInteger(message.remainingChunks[i].high)))
                        return "remainingChunks: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a ChunkDebugMetadata message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ChunkDebugMetadata} ChunkDebugMetadata
         */
        ChunkDebugMetadata.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ChunkDebugMetadata)
                return object;
            var message = new $root.lens.ChunkDebugMetadata();
            if (object.remainingChunks) {
                if (!Array.isArray(object.remainingChunks))
                    throw TypeError(".lens.ChunkDebugMetadata.remainingChunks: array expected");
                message.remainingChunks = [];
                for (var i = 0; i < object.remainingChunks.length; ++i)
                    if ($util.Long)
                        (message.remainingChunks[i] = $util.Long.fromValue(object.remainingChunks[i])).unsigned = false;
                    else if (typeof object.remainingChunks[i] === "string")
                        message.remainingChunks[i] = parseInt(object.remainingChunks[i], 10);
                    else if (typeof object.remainingChunks[i] === "number")
                        message.remainingChunks[i] = object.remainingChunks[i];
                    else if (typeof object.remainingChunks[i] === "object")
                        message.remainingChunks[i] = new $util.LongBits(object.remainingChunks[i].low >>> 0, object.remainingChunks[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a ChunkDebugMetadata message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {lens.ChunkDebugMetadata} message ChunkDebugMetadata
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ChunkDebugMetadata.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.remainingChunks = [];
            if (message.remainingChunks && message.remainingChunks.length) {
                object.remainingChunks = [];
                for (var j = 0; j < message.remainingChunks.length; ++j)
                    if (typeof message.remainingChunks[j] === "number")
                        object.remainingChunks[j] = options.longs === String ? String(message.remainingChunks[j]) : message.remainingChunks[j];
                    else
                        object.remainingChunks[j] = options.longs === String ? $util.Long.prototype.toString.call(message.remainingChunks[j]) : options.longs === Number ? new $util.LongBits(message.remainingChunks[j].low >>> 0, message.remainingChunks[j].high >>> 0).toNumber() : message.remainingChunks[j];
            }
            return object;
        };

        /**
         * Converts this ChunkDebugMetadata to JSON.
         * @function toJSON
         * @memberof lens.ChunkDebugMetadata
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ChunkDebugMetadata.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ChunkDebugMetadata
         * @function getTypeUrl
         * @memberof lens.ChunkDebugMetadata
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ChunkDebugMetadata.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ChunkDebugMetadata";
        };

        return ChunkDebugMetadata;
    })();

    lens.LensOverlayObjectsResponse = (function() {

        /**
         * Properties of a LensOverlayObjectsResponse.
         * @memberof lens
         * @interface ILensOverlayObjectsResponse
         * @property {Array.<lens.IOverlayObject>|null} [overlayObjects] LensOverlayObjectsResponse overlayObjects
         * @property {lens.IText|null} [text] LensOverlayObjectsResponse text
         * @property {Array.<lens.IDeepGleamData>|null} [deepGleams] LensOverlayObjectsResponse deepGleams
         * @property {lens.ILensOverlayClusterInfo|null} [clusterInfo] LensOverlayObjectsResponse clusterInfo
         */

        /**
         * Constructs a new LensOverlayObjectsResponse.
         * @memberof lens
         * @classdesc Represents a LensOverlayObjectsResponse.
         * @implements ILensOverlayObjectsResponse
         * @constructor
         * @param {lens.ILensOverlayObjectsResponse=} [properties] Properties to set
         */
        function LensOverlayObjectsResponse(properties) {
            this.overlayObjects = [];
            this.deepGleams = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayObjectsResponse overlayObjects.
         * @member {Array.<lens.IOverlayObject>} overlayObjects
         * @memberof lens.LensOverlayObjectsResponse
         * @instance
         */
        LensOverlayObjectsResponse.prototype.overlayObjects = $util.emptyArray;

        /**
         * LensOverlayObjectsResponse text.
         * @member {lens.IText|null|undefined} text
         * @memberof lens.LensOverlayObjectsResponse
         * @instance
         */
        LensOverlayObjectsResponse.prototype.text = null;

        /**
         * LensOverlayObjectsResponse deepGleams.
         * @member {Array.<lens.IDeepGleamData>} deepGleams
         * @memberof lens.LensOverlayObjectsResponse
         * @instance
         */
        LensOverlayObjectsResponse.prototype.deepGleams = $util.emptyArray;

        /**
         * LensOverlayObjectsResponse clusterInfo.
         * @member {lens.ILensOverlayClusterInfo|null|undefined} clusterInfo
         * @memberof lens.LensOverlayObjectsResponse
         * @instance
         */
        LensOverlayObjectsResponse.prototype.clusterInfo = null;

        /**
         * Creates a new LensOverlayObjectsResponse instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {lens.ILensOverlayObjectsResponse=} [properties] Properties to set
         * @returns {lens.LensOverlayObjectsResponse} LensOverlayObjectsResponse instance
         */
        LensOverlayObjectsResponse.create = function create(properties) {
            return new LensOverlayObjectsResponse(properties);
        };

        /**
         * Encodes the specified LensOverlayObjectsResponse message. Does not implicitly {@link lens.LensOverlayObjectsResponse.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {lens.ILensOverlayObjectsResponse} message LensOverlayObjectsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayObjectsResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.overlayObjects != null && message.overlayObjects.length)
                for (var i = 0; i < message.overlayObjects.length; ++i)
                    $root.lens.OverlayObject.encode(message.overlayObjects[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                $root.lens.Text.encode(message.text, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            if (message.deepGleams != null && message.deepGleams.length)
                for (var i = 0; i < message.deepGleams.length; ++i)
                    $root.lens.DeepGleamData.encode(message.deepGleams[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            if (message.clusterInfo != null && Object.hasOwnProperty.call(message, "clusterInfo"))
                $root.lens.LensOverlayClusterInfo.encode(message.clusterInfo, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayObjectsResponse message, length delimited. Does not implicitly {@link lens.LensOverlayObjectsResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {lens.ILensOverlayObjectsResponse} message LensOverlayObjectsResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayObjectsResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayObjectsResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayObjectsResponse} LensOverlayObjectsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayObjectsResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayObjectsResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 2: {
                        if (!(message.overlayObjects && message.overlayObjects.length))
                            message.overlayObjects = [];
                        message.overlayObjects.push($root.lens.OverlayObject.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.text = $root.lens.Text.decode(reader, reader.uint32());
                        break;
                    }
                case 4: {
                        if (!(message.deepGleams && message.deepGleams.length))
                            message.deepGleams = [];
                        message.deepGleams.push($root.lens.DeepGleamData.decode(reader, reader.uint32()));
                        break;
                    }
                case 7: {
                        message.clusterInfo = $root.lens.LensOverlayClusterInfo.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayObjectsResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayObjectsResponse} LensOverlayObjectsResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayObjectsResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayObjectsResponse message.
         * @function verify
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayObjectsResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.overlayObjects != null && message.hasOwnProperty("overlayObjects")) {
                if (!Array.isArray(message.overlayObjects))
                    return "overlayObjects: array expected";
                for (var i = 0; i < message.overlayObjects.length; ++i) {
                    var error = $root.lens.OverlayObject.verify(message.overlayObjects[i]);
                    if (error)
                        return "overlayObjects." + error;
                }
            }
            if (message.text != null && message.hasOwnProperty("text")) {
                var error = $root.lens.Text.verify(message.text);
                if (error)
                    return "text." + error;
            }
            if (message.deepGleams != null && message.hasOwnProperty("deepGleams")) {
                if (!Array.isArray(message.deepGleams))
                    return "deepGleams: array expected";
                for (var i = 0; i < message.deepGleams.length; ++i) {
                    var error = $root.lens.DeepGleamData.verify(message.deepGleams[i]);
                    if (error)
                        return "deepGleams." + error;
                }
            }
            if (message.clusterInfo != null && message.hasOwnProperty("clusterInfo")) {
                var error = $root.lens.LensOverlayClusterInfo.verify(message.clusterInfo);
                if (error)
                    return "clusterInfo." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayObjectsResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayObjectsResponse} LensOverlayObjectsResponse
         */
        LensOverlayObjectsResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayObjectsResponse)
                return object;
            var message = new $root.lens.LensOverlayObjectsResponse();
            if (object.overlayObjects) {
                if (!Array.isArray(object.overlayObjects))
                    throw TypeError(".lens.LensOverlayObjectsResponse.overlayObjects: array expected");
                message.overlayObjects = [];
                for (var i = 0; i < object.overlayObjects.length; ++i) {
                    if (typeof object.overlayObjects[i] !== "object")
                        throw TypeError(".lens.LensOverlayObjectsResponse.overlayObjects: object expected");
                    message.overlayObjects[i] = $root.lens.OverlayObject.fromObject(object.overlayObjects[i]);
                }
            }
            if (object.text != null) {
                if (typeof object.text !== "object")
                    throw TypeError(".lens.LensOverlayObjectsResponse.text: object expected");
                message.text = $root.lens.Text.fromObject(object.text);
            }
            if (object.deepGleams) {
                if (!Array.isArray(object.deepGleams))
                    throw TypeError(".lens.LensOverlayObjectsResponse.deepGleams: array expected");
                message.deepGleams = [];
                for (var i = 0; i < object.deepGleams.length; ++i) {
                    if (typeof object.deepGleams[i] !== "object")
                        throw TypeError(".lens.LensOverlayObjectsResponse.deepGleams: object expected");
                    message.deepGleams[i] = $root.lens.DeepGleamData.fromObject(object.deepGleams[i]);
                }
            }
            if (object.clusterInfo != null) {
                if (typeof object.clusterInfo !== "object")
                    throw TypeError(".lens.LensOverlayObjectsResponse.clusterInfo: object expected");
                message.clusterInfo = $root.lens.LensOverlayClusterInfo.fromObject(object.clusterInfo);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayObjectsResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {lens.LensOverlayObjectsResponse} message LensOverlayObjectsResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayObjectsResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults) {
                object.overlayObjects = [];
                object.deepGleams = [];
            }
            if (options.defaults) {
                object.text = null;
                object.clusterInfo = null;
            }
            if (message.overlayObjects && message.overlayObjects.length) {
                object.overlayObjects = [];
                for (var j = 0; j < message.overlayObjects.length; ++j)
                    object.overlayObjects[j] = $root.lens.OverlayObject.toObject(message.overlayObjects[j], options);
            }
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = $root.lens.Text.toObject(message.text, options);
            if (message.deepGleams && message.deepGleams.length) {
                object.deepGleams = [];
                for (var j = 0; j < message.deepGleams.length; ++j)
                    object.deepGleams[j] = $root.lens.DeepGleamData.toObject(message.deepGleams[j], options);
            }
            if (message.clusterInfo != null && message.hasOwnProperty("clusterInfo"))
                object.clusterInfo = $root.lens.LensOverlayClusterInfo.toObject(message.clusterInfo, options);
            return object;
        };

        /**
         * Converts this LensOverlayObjectsResponse to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayObjectsResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayObjectsResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayObjectsResponse
         * @function getTypeUrl
         * @memberof lens.LensOverlayObjectsResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayObjectsResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayObjectsResponse";
        };

        return LensOverlayObjectsResponse;
    })();

    lens.LensOverlayInteractionRequest = (function() {

        /**
         * Properties of a LensOverlayInteractionRequest.
         * @memberof lens
         * @interface ILensOverlayInteractionRequest
         * @property {lens.ILensOverlayRequestContext|null} [requestContext] LensOverlayInteractionRequest requestContext
         * @property {lens.ILensOverlayInteractionRequestMetadata|null} [interactionRequestMetadata] LensOverlayInteractionRequest interactionRequestMetadata
         * @property {lens.IImageCrop|null} [imageCrop] LensOverlayInteractionRequest imageCrop
         */

        /**
         * Constructs a new LensOverlayInteractionRequest.
         * @memberof lens
         * @classdesc Represents a LensOverlayInteractionRequest.
         * @implements ILensOverlayInteractionRequest
         * @constructor
         * @param {lens.ILensOverlayInteractionRequest=} [properties] Properties to set
         */
        function LensOverlayInteractionRequest(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayInteractionRequest requestContext.
         * @member {lens.ILensOverlayRequestContext|null|undefined} requestContext
         * @memberof lens.LensOverlayInteractionRequest
         * @instance
         */
        LensOverlayInteractionRequest.prototype.requestContext = null;

        /**
         * LensOverlayInteractionRequest interactionRequestMetadata.
         * @member {lens.ILensOverlayInteractionRequestMetadata|null|undefined} interactionRequestMetadata
         * @memberof lens.LensOverlayInteractionRequest
         * @instance
         */
        LensOverlayInteractionRequest.prototype.interactionRequestMetadata = null;

        /**
         * LensOverlayInteractionRequest imageCrop.
         * @member {lens.IImageCrop|null|undefined} imageCrop
         * @memberof lens.LensOverlayInteractionRequest
         * @instance
         */
        LensOverlayInteractionRequest.prototype.imageCrop = null;

        /**
         * Creates a new LensOverlayInteractionRequest instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {lens.ILensOverlayInteractionRequest=} [properties] Properties to set
         * @returns {lens.LensOverlayInteractionRequest} LensOverlayInteractionRequest instance
         */
        LensOverlayInteractionRequest.create = function create(properties) {
            return new LensOverlayInteractionRequest(properties);
        };

        /**
         * Encodes the specified LensOverlayInteractionRequest message. Does not implicitly {@link lens.LensOverlayInteractionRequest.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {lens.ILensOverlayInteractionRequest} message LensOverlayInteractionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayInteractionRequest.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.requestContext != null && Object.hasOwnProperty.call(message, "requestContext"))
                $root.lens.LensOverlayRequestContext.encode(message.requestContext, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.interactionRequestMetadata != null && Object.hasOwnProperty.call(message, "interactionRequestMetadata"))
                $root.lens.LensOverlayInteractionRequestMetadata.encode(message.interactionRequestMetadata, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.imageCrop != null && Object.hasOwnProperty.call(message, "imageCrop"))
                $root.lens.ImageCrop.encode(message.imageCrop, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayInteractionRequest message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionRequest.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {lens.ILensOverlayInteractionRequest} message LensOverlayInteractionRequest message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayInteractionRequest.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayInteractionRequest message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayInteractionRequest} LensOverlayInteractionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayInteractionRequest.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionRequest();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.requestContext = $root.lens.LensOverlayRequestContext.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.interactionRequestMetadata = $root.lens.LensOverlayInteractionRequestMetadata.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.imageCrop = $root.lens.ImageCrop.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayInteractionRequest message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayInteractionRequest} LensOverlayInteractionRequest
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayInteractionRequest.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayInteractionRequest message.
         * @function verify
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayInteractionRequest.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestContext != null && message.hasOwnProperty("requestContext")) {
                var error = $root.lens.LensOverlayRequestContext.verify(message.requestContext);
                if (error)
                    return "requestContext." + error;
            }
            if (message.interactionRequestMetadata != null && message.hasOwnProperty("interactionRequestMetadata")) {
                var error = $root.lens.LensOverlayInteractionRequestMetadata.verify(message.interactionRequestMetadata);
                if (error)
                    return "interactionRequestMetadata." + error;
            }
            if (message.imageCrop != null && message.hasOwnProperty("imageCrop")) {
                var error = $root.lens.ImageCrop.verify(message.imageCrop);
                if (error)
                    return "imageCrop." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayInteractionRequest message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayInteractionRequest} LensOverlayInteractionRequest
         */
        LensOverlayInteractionRequest.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayInteractionRequest)
                return object;
            var message = new $root.lens.LensOverlayInteractionRequest();
            if (object.requestContext != null) {
                if (typeof object.requestContext !== "object")
                    throw TypeError(".lens.LensOverlayInteractionRequest.requestContext: object expected");
                message.requestContext = $root.lens.LensOverlayRequestContext.fromObject(object.requestContext);
            }
            if (object.interactionRequestMetadata != null) {
                if (typeof object.interactionRequestMetadata !== "object")
                    throw TypeError(".lens.LensOverlayInteractionRequest.interactionRequestMetadata: object expected");
                message.interactionRequestMetadata = $root.lens.LensOverlayInteractionRequestMetadata.fromObject(object.interactionRequestMetadata);
            }
            if (object.imageCrop != null) {
                if (typeof object.imageCrop !== "object")
                    throw TypeError(".lens.LensOverlayInteractionRequest.imageCrop: object expected");
                message.imageCrop = $root.lens.ImageCrop.fromObject(object.imageCrop);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayInteractionRequest message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {lens.LensOverlayInteractionRequest} message LensOverlayInteractionRequest
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayInteractionRequest.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.requestContext = null;
                object.interactionRequestMetadata = null;
                object.imageCrop = null;
            }
            if (message.requestContext != null && message.hasOwnProperty("requestContext"))
                object.requestContext = $root.lens.LensOverlayRequestContext.toObject(message.requestContext, options);
            if (message.interactionRequestMetadata != null && message.hasOwnProperty("interactionRequestMetadata"))
                object.interactionRequestMetadata = $root.lens.LensOverlayInteractionRequestMetadata.toObject(message.interactionRequestMetadata, options);
            if (message.imageCrop != null && message.hasOwnProperty("imageCrop"))
                object.imageCrop = $root.lens.ImageCrop.toObject(message.imageCrop, options);
            return object;
        };

        /**
         * Converts this LensOverlayInteractionRequest to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayInteractionRequest
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayInteractionRequest.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayInteractionRequest
         * @function getTypeUrl
         * @memberof lens.LensOverlayInteractionRequest
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayInteractionRequest.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayInteractionRequest";
        };

        return LensOverlayInteractionRequest;
    })();

    lens.LensOverlayInteractionResponse = (function() {

        /**
         * Properties of a LensOverlayInteractionResponse.
         * @memberof lens
         * @interface ILensOverlayInteractionResponse
         * @property {string|null} [encodedResponse] LensOverlayInteractionResponse encodedResponse
         * @property {lens.IText|null} [text] LensOverlayInteractionResponse text
         */

        /**
         * Constructs a new LensOverlayInteractionResponse.
         * @memberof lens
         * @classdesc Represents a LensOverlayInteractionResponse.
         * @implements ILensOverlayInteractionResponse
         * @constructor
         * @param {lens.ILensOverlayInteractionResponse=} [properties] Properties to set
         */
        function LensOverlayInteractionResponse(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayInteractionResponse encodedResponse.
         * @member {string} encodedResponse
         * @memberof lens.LensOverlayInteractionResponse
         * @instance
         */
        LensOverlayInteractionResponse.prototype.encodedResponse = "";

        /**
         * LensOverlayInteractionResponse text.
         * @member {lens.IText|null|undefined} text
         * @memberof lens.LensOverlayInteractionResponse
         * @instance
         */
        LensOverlayInteractionResponse.prototype.text = null;

        /**
         * Creates a new LensOverlayInteractionResponse instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {lens.ILensOverlayInteractionResponse=} [properties] Properties to set
         * @returns {lens.LensOverlayInteractionResponse} LensOverlayInteractionResponse instance
         */
        LensOverlayInteractionResponse.create = function create(properties) {
            return new LensOverlayInteractionResponse(properties);
        };

        /**
         * Encodes the specified LensOverlayInteractionResponse message. Does not implicitly {@link lens.LensOverlayInteractionResponse.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {lens.ILensOverlayInteractionResponse} message LensOverlayInteractionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayInteractionResponse.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.encodedResponse != null && Object.hasOwnProperty.call(message, "encodedResponse"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.encodedResponse);
            if (message.text != null && Object.hasOwnProperty.call(message, "text"))
                $root.lens.Text.encode(message.text, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayInteractionResponse message, length delimited. Does not implicitly {@link lens.LensOverlayInteractionResponse.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {lens.ILensOverlayInteractionResponse} message LensOverlayInteractionResponse message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayInteractionResponse.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayInteractionResponse message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayInteractionResponse} LensOverlayInteractionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayInteractionResponse.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayInteractionResponse();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 3: {
                        message.encodedResponse = reader.string();
                        break;
                    }
                case 5: {
                        message.text = $root.lens.Text.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayInteractionResponse message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayInteractionResponse} LensOverlayInteractionResponse
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayInteractionResponse.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayInteractionResponse message.
         * @function verify
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayInteractionResponse.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.encodedResponse != null && message.hasOwnProperty("encodedResponse"))
                if (!$util.isString(message.encodedResponse))
                    return "encodedResponse: string expected";
            if (message.text != null && message.hasOwnProperty("text")) {
                var error = $root.lens.Text.verify(message.text);
                if (error)
                    return "text." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayInteractionResponse message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayInteractionResponse} LensOverlayInteractionResponse
         */
        LensOverlayInteractionResponse.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayInteractionResponse)
                return object;
            var message = new $root.lens.LensOverlayInteractionResponse();
            if (object.encodedResponse != null)
                message.encodedResponse = String(object.encodedResponse);
            if (object.text != null) {
                if (typeof object.text !== "object")
                    throw TypeError(".lens.LensOverlayInteractionResponse.text: object expected");
                message.text = $root.lens.Text.fromObject(object.text);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayInteractionResponse message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {lens.LensOverlayInteractionResponse} message LensOverlayInteractionResponse
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayInteractionResponse.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.encodedResponse = "";
                object.text = null;
            }
            if (message.encodedResponse != null && message.hasOwnProperty("encodedResponse"))
                object.encodedResponse = message.encodedResponse;
            if (message.text != null && message.hasOwnProperty("text"))
                object.text = $root.lens.Text.toObject(message.text, options);
            return object;
        };

        /**
         * Converts this LensOverlayInteractionResponse to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayInteractionResponse
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayInteractionResponse.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayInteractionResponse
         * @function getTypeUrl
         * @memberof lens.LensOverlayInteractionResponse
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayInteractionResponse.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayInteractionResponse";
        };

        return LensOverlayInteractionResponse;
    })();

    lens.Payload = (function() {

        /**
         * Properties of a Payload.
         * @memberof lens
         * @interface IPayload
         * @property {lens.RequestType|null} [requestType] Payload requestType
         * @property {lens.IImageData|null} [imageData] Payload imageData
         * @property {Uint8Array|null} [contentData] Payload contentData
         * @property {string|null} [contentType] Payload contentType
         * @property {string|null} [pageUrl] Payload pageUrl
         * @property {lens.ILensOverlayDocument|null} [partialPdfDocument] Payload partialPdfDocument
         * @property {lens.CompressionType|null} [compressionType] Payload compressionType
         * @property {lens.IStoredChunkOptions|null} [storedChunkOptions] Payload storedChunkOptions
         * @property {lens.IContent|null} [content] Payload content
         */

        /**
         * Constructs a new Payload.
         * @memberof lens
         * @classdesc Represents a Payload.
         * @implements IPayload
         * @constructor
         * @param {lens.IPayload=} [properties] Properties to set
         */
        function Payload(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Payload requestType.
         * @member {lens.RequestType} requestType
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.requestType = 0;

        /**
         * Payload imageData.
         * @member {lens.IImageData|null|undefined} imageData
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.imageData = null;

        /**
         * Payload contentData.
         * @member {Uint8Array} contentData
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.contentData = $util.newBuffer([]);

        /**
         * Payload contentType.
         * @member {string} contentType
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.contentType = "";

        /**
         * Payload pageUrl.
         * @member {string} pageUrl
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.pageUrl = "";

        /**
         * Payload partialPdfDocument.
         * @member {lens.ILensOverlayDocument|null|undefined} partialPdfDocument
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.partialPdfDocument = null;

        /**
         * Payload compressionType.
         * @member {lens.CompressionType} compressionType
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.compressionType = 0;

        /**
         * Payload storedChunkOptions.
         * @member {lens.IStoredChunkOptions|null|undefined} storedChunkOptions
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.storedChunkOptions = null;

        /**
         * Payload content.
         * @member {lens.IContent|null|undefined} content
         * @memberof lens.Payload
         * @instance
         */
        Payload.prototype.content = null;

        /**
         * Creates a new Payload instance using the specified properties.
         * @function create
         * @memberof lens.Payload
         * @static
         * @param {lens.IPayload=} [properties] Properties to set
         * @returns {lens.Payload} Payload instance
         */
        Payload.create = function create(properties) {
            return new Payload(properties);
        };

        /**
         * Encodes the specified Payload message. Does not implicitly {@link lens.Payload.verify|verify} messages.
         * @function encode
         * @memberof lens.Payload
         * @static
         * @param {lens.IPayload} message Payload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payload.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.imageData != null && Object.hasOwnProperty.call(message, "imageData"))
                $root.lens.ImageData.encode(message.imageData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.contentData != null && Object.hasOwnProperty.call(message, "contentData"))
                writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contentData);
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 4, wireType 2 =*/34).string(message.contentType);
            if (message.pageUrl != null && Object.hasOwnProperty.call(message, "pageUrl"))
                writer.uint32(/* id 5, wireType 2 =*/42).string(message.pageUrl);
            if (message.requestType != null && Object.hasOwnProperty.call(message, "requestType"))
                writer.uint32(/* id 6, wireType 0 =*/48).int32(message.requestType);
            if (message.partialPdfDocument != null && Object.hasOwnProperty.call(message, "partialPdfDocument"))
                $root.lens.LensOverlayDocument.encode(message.partialPdfDocument, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            if (message.compressionType != null && Object.hasOwnProperty.call(message, "compressionType"))
                writer.uint32(/* id 8, wireType 0 =*/64).int32(message.compressionType);
            if (message.storedChunkOptions != null && Object.hasOwnProperty.call(message, "storedChunkOptions"))
                $root.lens.StoredChunkOptions.encode(message.storedChunkOptions, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
            if (message.content != null && Object.hasOwnProperty.call(message, "content"))
                $root.lens.Content.encode(message.content, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified Payload message, length delimited. Does not implicitly {@link lens.Payload.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Payload
         * @static
         * @param {lens.IPayload} message Payload message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Payload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Payload message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Payload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Payload} Payload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payload.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Payload();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 6: {
                        message.requestType = reader.int32();
                        break;
                    }
                case 2: {
                        message.imageData = $root.lens.ImageData.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.contentData = reader.bytes();
                        break;
                    }
                case 4: {
                        message.contentType = reader.string();
                        break;
                    }
                case 5: {
                        message.pageUrl = reader.string();
                        break;
                    }
                case 7: {
                        message.partialPdfDocument = $root.lens.LensOverlayDocument.decode(reader, reader.uint32());
                        break;
                    }
                case 8: {
                        message.compressionType = reader.int32();
                        break;
                    }
                case 9: {
                        message.storedChunkOptions = $root.lens.StoredChunkOptions.decode(reader, reader.uint32());
                        break;
                    }
                case 10: {
                        message.content = $root.lens.Content.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Payload message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Payload
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Payload} Payload
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Payload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Payload message.
         * @function verify
         * @memberof lens.Payload
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Payload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.requestType != null && message.hasOwnProperty("requestType"))
                switch (message.requestType) {
                default:
                    return "requestType: enum value expected";
                case 0:
                case 1:
                case 3:
                case 2:
                    break;
                }
            if (message.imageData != null && message.hasOwnProperty("imageData")) {
                var error = $root.lens.ImageData.verify(message.imageData);
                if (error)
                    return "imageData." + error;
            }
            if (message.contentData != null && message.hasOwnProperty("contentData"))
                if (!(message.contentData && typeof message.contentData.length === "number" || $util.isString(message.contentData)))
                    return "contentData: buffer expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                if (!$util.isString(message.contentType))
                    return "contentType: string expected";
            if (message.pageUrl != null && message.hasOwnProperty("pageUrl"))
                if (!$util.isString(message.pageUrl))
                    return "pageUrl: string expected";
            if (message.partialPdfDocument != null && message.hasOwnProperty("partialPdfDocument")) {
                var error = $root.lens.LensOverlayDocument.verify(message.partialPdfDocument);
                if (error)
                    return "partialPdfDocument." + error;
            }
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                switch (message.compressionType) {
                default:
                    return "compressionType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.storedChunkOptions != null && message.hasOwnProperty("storedChunkOptions")) {
                var error = $root.lens.StoredChunkOptions.verify(message.storedChunkOptions);
                if (error)
                    return "storedChunkOptions." + error;
            }
            if (message.content != null && message.hasOwnProperty("content")) {
                var error = $root.lens.Content.verify(message.content);
                if (error)
                    return "content." + error;
            }
            return null;
        };

        /**
         * Creates a Payload message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Payload
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Payload} Payload
         */
        Payload.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Payload)
                return object;
            var message = new $root.lens.Payload();
            switch (object.requestType) {
            default:
                if (typeof object.requestType === "number") {
                    message.requestType = object.requestType;
                    break;
                }
                break;
            case "REQUEST_TYPE_DEFAULT":
            case 0:
                message.requestType = 0;
                break;
            case "REQUEST_TYPE_PDF":
            case 1:
                message.requestType = 1;
                break;
            case "REQUEST_TYPE_EARLY_PARTIAL_PDF":
            case 3:
                message.requestType = 3;
                break;
            case "REQUEST_TYPE_WEBPAGE":
            case 2:
                message.requestType = 2;
                break;
            }
            if (object.imageData != null) {
                if (typeof object.imageData !== "object")
                    throw TypeError(".lens.Payload.imageData: object expected");
                message.imageData = $root.lens.ImageData.fromObject(object.imageData);
            }
            if (object.contentData != null)
                if (typeof object.contentData === "string")
                    $util.base64.decode(object.contentData, message.contentData = $util.newBuffer($util.base64.length(object.contentData)), 0);
                else if (object.contentData.length >= 0)
                    message.contentData = object.contentData;
            if (object.contentType != null)
                message.contentType = String(object.contentType);
            if (object.pageUrl != null)
                message.pageUrl = String(object.pageUrl);
            if (object.partialPdfDocument != null) {
                if (typeof object.partialPdfDocument !== "object")
                    throw TypeError(".lens.Payload.partialPdfDocument: object expected");
                message.partialPdfDocument = $root.lens.LensOverlayDocument.fromObject(object.partialPdfDocument);
            }
            switch (object.compressionType) {
            default:
                if (typeof object.compressionType === "number") {
                    message.compressionType = object.compressionType;
                    break;
                }
                break;
            case "UNCOMPRESSED":
            case 0:
                message.compressionType = 0;
                break;
            case "ZSTD":
            case 1:
                message.compressionType = 1;
                break;
            }
            if (object.storedChunkOptions != null) {
                if (typeof object.storedChunkOptions !== "object")
                    throw TypeError(".lens.Payload.storedChunkOptions: object expected");
                message.storedChunkOptions = $root.lens.StoredChunkOptions.fromObject(object.storedChunkOptions);
            }
            if (object.content != null) {
                if (typeof object.content !== "object")
                    throw TypeError(".lens.Payload.content: object expected");
                message.content = $root.lens.Content.fromObject(object.content);
            }
            return message;
        };

        /**
         * Creates a plain object from a Payload message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Payload
         * @static
         * @param {lens.Payload} message Payload
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Payload.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.imageData = null;
                if (options.bytes === String)
                    object.contentData = "";
                else {
                    object.contentData = [];
                    if (options.bytes !== Array)
                        object.contentData = $util.newBuffer(object.contentData);
                }
                object.contentType = "";
                object.pageUrl = "";
                object.requestType = options.enums === String ? "REQUEST_TYPE_DEFAULT" : 0;
                object.partialPdfDocument = null;
                object.compressionType = options.enums === String ? "UNCOMPRESSED" : 0;
                object.storedChunkOptions = null;
                object.content = null;
            }
            if (message.imageData != null && message.hasOwnProperty("imageData"))
                object.imageData = $root.lens.ImageData.toObject(message.imageData, options);
            if (message.contentData != null && message.hasOwnProperty("contentData"))
                object.contentData = options.bytes === String ? $util.base64.encode(message.contentData, 0, message.contentData.length) : options.bytes === Array ? Array.prototype.slice.call(message.contentData) : message.contentData;
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = message.contentType;
            if (message.pageUrl != null && message.hasOwnProperty("pageUrl"))
                object.pageUrl = message.pageUrl;
            if (message.requestType != null && message.hasOwnProperty("requestType"))
                object.requestType = options.enums === String ? $root.lens.RequestType[message.requestType] === undefined ? message.requestType : $root.lens.RequestType[message.requestType] : message.requestType;
            if (message.partialPdfDocument != null && message.hasOwnProperty("partialPdfDocument"))
                object.partialPdfDocument = $root.lens.LensOverlayDocument.toObject(message.partialPdfDocument, options);
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                object.compressionType = options.enums === String ? $root.lens.CompressionType[message.compressionType] === undefined ? message.compressionType : $root.lens.CompressionType[message.compressionType] : message.compressionType;
            if (message.storedChunkOptions != null && message.hasOwnProperty("storedChunkOptions"))
                object.storedChunkOptions = $root.lens.StoredChunkOptions.toObject(message.storedChunkOptions, options);
            if (message.content != null && message.hasOwnProperty("content"))
                object.content = $root.lens.Content.toObject(message.content, options);
            return object;
        };

        /**
         * Converts this Payload to JSON.
         * @function toJSON
         * @memberof lens.Payload
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Payload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Payload
         * @function getTypeUrl
         * @memberof lens.Payload
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Payload.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Payload";
        };

        return Payload;
    })();

    lens.StoredChunkOptions = (function() {

        /**
         * Properties of a StoredChunkOptions.
         * @memberof lens
         * @interface IStoredChunkOptions
         * @property {boolean|null} [readStoredChunks] StoredChunkOptions readStoredChunks
         * @property {number|Long|null} [totalStoredChunks] StoredChunkOptions totalStoredChunks
         */

        /**
         * Constructs a new StoredChunkOptions.
         * @memberof lens
         * @classdesc Represents a StoredChunkOptions.
         * @implements IStoredChunkOptions
         * @constructor
         * @param {lens.IStoredChunkOptions=} [properties] Properties to set
         */
        function StoredChunkOptions(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StoredChunkOptions readStoredChunks.
         * @member {boolean} readStoredChunks
         * @memberof lens.StoredChunkOptions
         * @instance
         */
        StoredChunkOptions.prototype.readStoredChunks = false;

        /**
         * StoredChunkOptions totalStoredChunks.
         * @member {number|Long} totalStoredChunks
         * @memberof lens.StoredChunkOptions
         * @instance
         */
        StoredChunkOptions.prototype.totalStoredChunks = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Creates a new StoredChunkOptions instance using the specified properties.
         * @function create
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {lens.IStoredChunkOptions=} [properties] Properties to set
         * @returns {lens.StoredChunkOptions} StoredChunkOptions instance
         */
        StoredChunkOptions.create = function create(properties) {
            return new StoredChunkOptions(properties);
        };

        /**
         * Encodes the specified StoredChunkOptions message. Does not implicitly {@link lens.StoredChunkOptions.verify|verify} messages.
         * @function encode
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {lens.IStoredChunkOptions} message StoredChunkOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoredChunkOptions.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.readStoredChunks != null && Object.hasOwnProperty.call(message, "readStoredChunks"))
                writer.uint32(/* id 1, wireType 0 =*/8).bool(message.readStoredChunks);
            if (message.totalStoredChunks != null && Object.hasOwnProperty.call(message, "totalStoredChunks"))
                writer.uint32(/* id 2, wireType 0 =*/16).int64(message.totalStoredChunks);
            return writer;
        };

        /**
         * Encodes the specified StoredChunkOptions message, length delimited. Does not implicitly {@link lens.StoredChunkOptions.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {lens.IStoredChunkOptions} message StoredChunkOptions message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StoredChunkOptions.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StoredChunkOptions message from the specified reader or buffer.
         * @function decode
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.StoredChunkOptions} StoredChunkOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoredChunkOptions.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.StoredChunkOptions();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.readStoredChunks = reader.bool();
                        break;
                    }
                case 2: {
                        message.totalStoredChunks = reader.int64();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StoredChunkOptions message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.StoredChunkOptions} StoredChunkOptions
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StoredChunkOptions.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StoredChunkOptions message.
         * @function verify
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StoredChunkOptions.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.readStoredChunks != null && message.hasOwnProperty("readStoredChunks"))
                if (typeof message.readStoredChunks !== "boolean")
                    return "readStoredChunks: boolean expected";
            if (message.totalStoredChunks != null && message.hasOwnProperty("totalStoredChunks"))
                if (!$util.isInteger(message.totalStoredChunks) && !(message.totalStoredChunks && $util.isInteger(message.totalStoredChunks.low) && $util.isInteger(message.totalStoredChunks.high)))
                    return "totalStoredChunks: integer|Long expected";
            return null;
        };

        /**
         * Creates a StoredChunkOptions message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.StoredChunkOptions} StoredChunkOptions
         */
        StoredChunkOptions.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.StoredChunkOptions)
                return object;
            var message = new $root.lens.StoredChunkOptions();
            if (object.readStoredChunks != null)
                message.readStoredChunks = Boolean(object.readStoredChunks);
            if (object.totalStoredChunks != null)
                if ($util.Long)
                    (message.totalStoredChunks = $util.Long.fromValue(object.totalStoredChunks)).unsigned = false;
                else if (typeof object.totalStoredChunks === "string")
                    message.totalStoredChunks = parseInt(object.totalStoredChunks, 10);
                else if (typeof object.totalStoredChunks === "number")
                    message.totalStoredChunks = object.totalStoredChunks;
                else if (typeof object.totalStoredChunks === "object")
                    message.totalStoredChunks = new $util.LongBits(object.totalStoredChunks.low >>> 0, object.totalStoredChunks.high >>> 0).toNumber();
            return message;
        };

        /**
         * Creates a plain object from a StoredChunkOptions message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {lens.StoredChunkOptions} message StoredChunkOptions
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StoredChunkOptions.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.readStoredChunks = false;
                if ($util.Long) {
                    var long = new $util.Long(0, 0, false);
                    object.totalStoredChunks = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.totalStoredChunks = options.longs === String ? "0" : 0;
            }
            if (message.readStoredChunks != null && message.hasOwnProperty("readStoredChunks"))
                object.readStoredChunks = message.readStoredChunks;
            if (message.totalStoredChunks != null && message.hasOwnProperty("totalStoredChunks"))
                if (typeof message.totalStoredChunks === "number")
                    object.totalStoredChunks = options.longs === String ? String(message.totalStoredChunks) : message.totalStoredChunks;
                else
                    object.totalStoredChunks = options.longs === String ? $util.Long.prototype.toString.call(message.totalStoredChunks) : options.longs === Number ? new $util.LongBits(message.totalStoredChunks.low >>> 0, message.totalStoredChunks.high >>> 0).toNumber() : message.totalStoredChunks;
            return object;
        };

        /**
         * Converts this StoredChunkOptions to JSON.
         * @function toJSON
         * @memberof lens.StoredChunkOptions
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StoredChunkOptions.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StoredChunkOptions
         * @function getTypeUrl
         * @memberof lens.StoredChunkOptions
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StoredChunkOptions.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.StoredChunkOptions";
        };

        return StoredChunkOptions;
    })();

    /**
     * CompressionType enum.
     * @name lens.CompressionType
     * @enum {number}
     * @property {number} UNCOMPRESSED=0 UNCOMPRESSED value
     * @property {number} ZSTD=1 ZSTD value
     */
    lens.CompressionType = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNCOMPRESSED"] = 0;
        values[valuesById[1] = "ZSTD"] = 1;
        return values;
    })();

    lens.Content = (function() {

        /**
         * Properties of a Content.
         * @memberof lens
         * @interface IContent
         * @property {string|null} [webpageUrl] Content webpageUrl
         * @property {Array.<lens.IContentData>|null} [contentData] Content contentData
         * @property {lens.RequestType|null} [requestType] Content requestType
         */

        /**
         * Constructs a new Content.
         * @memberof lens
         * @classdesc Represents a Content.
         * @implements IContent
         * @constructor
         * @param {lens.IContent=} [properties] Properties to set
         */
        function Content(properties) {
            this.contentData = [];
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Content webpageUrl.
         * @member {string} webpageUrl
         * @memberof lens.Content
         * @instance
         */
        Content.prototype.webpageUrl = "";

        /**
         * Content contentData.
         * @member {Array.<lens.IContentData>} contentData
         * @memberof lens.Content
         * @instance
         */
        Content.prototype.contentData = $util.emptyArray;

        /**
         * Content requestType.
         * @member {lens.RequestType} requestType
         * @memberof lens.Content
         * @instance
         */
        Content.prototype.requestType = 0;

        /**
         * Creates a new Content instance using the specified properties.
         * @function create
         * @memberof lens.Content
         * @static
         * @param {lens.IContent=} [properties] Properties to set
         * @returns {lens.Content} Content instance
         */
        Content.create = function create(properties) {
            return new Content(properties);
        };

        /**
         * Encodes the specified Content message. Does not implicitly {@link lens.Content.verify|verify} messages.
         * @function encode
         * @memberof lens.Content
         * @static
         * @param {lens.IContent} message Content message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Content.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.webpageUrl != null && Object.hasOwnProperty.call(message, "webpageUrl"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.webpageUrl);
            if (message.contentData != null && message.contentData.length)
                for (var i = 0; i < message.contentData.length; ++i)
                    $root.lens.ContentData.encode(message.contentData[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.requestType != null && Object.hasOwnProperty.call(message, "requestType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.requestType);
            return writer;
        };

        /**
         * Encodes the specified Content message, length delimited. Does not implicitly {@link lens.Content.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.Content
         * @static
         * @param {lens.IContent} message Content message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        Content.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a Content message from the specified reader or buffer.
         * @function decode
         * @memberof lens.Content
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.Content} Content
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Content.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.Content();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.webpageUrl = reader.string();
                        break;
                    }
                case 2: {
                        if (!(message.contentData && message.contentData.length))
                            message.contentData = [];
                        message.contentData.push($root.lens.ContentData.decode(reader, reader.uint32()));
                        break;
                    }
                case 3: {
                        message.requestType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a Content message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.Content
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.Content} Content
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        Content.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a Content message.
         * @function verify
         * @memberof lens.Content
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Content.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.webpageUrl != null && message.hasOwnProperty("webpageUrl"))
                if (!$util.isString(message.webpageUrl))
                    return "webpageUrl: string expected";
            if (message.contentData != null && message.hasOwnProperty("contentData")) {
                if (!Array.isArray(message.contentData))
                    return "contentData: array expected";
                for (var i = 0; i < message.contentData.length; ++i) {
                    var error = $root.lens.ContentData.verify(message.contentData[i]);
                    if (error)
                        return "contentData." + error;
                }
            }
            if (message.requestType != null && message.hasOwnProperty("requestType"))
                switch (message.requestType) {
                default:
                    return "requestType: enum value expected";
                case 0:
                case 1:
                case 3:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a Content message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.Content
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.Content} Content
         */
        Content.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.Content)
                return object;
            var message = new $root.lens.Content();
            if (object.webpageUrl != null)
                message.webpageUrl = String(object.webpageUrl);
            if (object.contentData) {
                if (!Array.isArray(object.contentData))
                    throw TypeError(".lens.Content.contentData: array expected");
                message.contentData = [];
                for (var i = 0; i < object.contentData.length; ++i) {
                    if (typeof object.contentData[i] !== "object")
                        throw TypeError(".lens.Content.contentData: object expected");
                    message.contentData[i] = $root.lens.ContentData.fromObject(object.contentData[i]);
                }
            }
            switch (object.requestType) {
            default:
                if (typeof object.requestType === "number") {
                    message.requestType = object.requestType;
                    break;
                }
                break;
            case "REQUEST_TYPE_DEFAULT":
            case 0:
                message.requestType = 0;
                break;
            case "REQUEST_TYPE_PDF":
            case 1:
                message.requestType = 1;
                break;
            case "REQUEST_TYPE_EARLY_PARTIAL_PDF":
            case 3:
                message.requestType = 3;
                break;
            case "REQUEST_TYPE_WEBPAGE":
            case 2:
                message.requestType = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a Content message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.Content
         * @static
         * @param {lens.Content} message Content
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Content.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.arrays || options.defaults)
                object.contentData = [];
            if (options.defaults) {
                object.webpageUrl = "";
                object.requestType = options.enums === String ? "REQUEST_TYPE_DEFAULT" : 0;
            }
            if (message.webpageUrl != null && message.hasOwnProperty("webpageUrl"))
                object.webpageUrl = message.webpageUrl;
            if (message.contentData && message.contentData.length) {
                object.contentData = [];
                for (var j = 0; j < message.contentData.length; ++j)
                    object.contentData[j] = $root.lens.ContentData.toObject(message.contentData[j], options);
            }
            if (message.requestType != null && message.hasOwnProperty("requestType"))
                object.requestType = options.enums === String ? $root.lens.RequestType[message.requestType] === undefined ? message.requestType : $root.lens.RequestType[message.requestType] : message.requestType;
            return object;
        };

        /**
         * Converts this Content to JSON.
         * @function toJSON
         * @memberof lens.Content
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Content.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for Content
         * @function getTypeUrl
         * @memberof lens.Content
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        Content.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.Content";
        };

        return Content;
    })();

    lens.ContentData = (function() {

        /**
         * Properties of a ContentData.
         * @memberof lens
         * @interface IContentData
         * @property {lens.ContentData.ContentType|null} [contentType] ContentData contentType
         * @property {Uint8Array|null} [data] ContentData data
         * @property {lens.CompressionType|null} [compressionType] ContentData compressionType
         * @property {lens.IStoredChunkOptions|null} [storedChunkOptions] ContentData storedChunkOptions
         */

        /**
         * Constructs a new ContentData.
         * @memberof lens
         * @classdesc Represents a ContentData.
         * @implements IContentData
         * @constructor
         * @param {lens.IContentData=} [properties] Properties to set
         */
        function ContentData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * ContentData contentType.
         * @member {lens.ContentData.ContentType} contentType
         * @memberof lens.ContentData
         * @instance
         */
        ContentData.prototype.contentType = 0;

        /**
         * ContentData data.
         * @member {Uint8Array} data
         * @memberof lens.ContentData
         * @instance
         */
        ContentData.prototype.data = $util.newBuffer([]);

        /**
         * ContentData compressionType.
         * @member {lens.CompressionType} compressionType
         * @memberof lens.ContentData
         * @instance
         */
        ContentData.prototype.compressionType = 0;

        /**
         * ContentData storedChunkOptions.
         * @member {lens.IStoredChunkOptions|null|undefined} storedChunkOptions
         * @memberof lens.ContentData
         * @instance
         */
        ContentData.prototype.storedChunkOptions = null;

        /**
         * Creates a new ContentData instance using the specified properties.
         * @function create
         * @memberof lens.ContentData
         * @static
         * @param {lens.IContentData=} [properties] Properties to set
         * @returns {lens.ContentData} ContentData instance
         */
        ContentData.create = function create(properties) {
            return new ContentData(properties);
        };

        /**
         * Encodes the specified ContentData message. Does not implicitly {@link lens.ContentData.verify|verify} messages.
         * @function encode
         * @memberof lens.ContentData
         * @static
         * @param {lens.IContentData} message ContentData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.contentType != null && Object.hasOwnProperty.call(message, "contentType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.contentType);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.data);
            if (message.compressionType != null && Object.hasOwnProperty.call(message, "compressionType"))
                writer.uint32(/* id 3, wireType 0 =*/24).int32(message.compressionType);
            if (message.storedChunkOptions != null && Object.hasOwnProperty.call(message, "storedChunkOptions"))
                $root.lens.StoredChunkOptions.encode(message.storedChunkOptions, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified ContentData message, length delimited. Does not implicitly {@link lens.ContentData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.ContentData
         * @static
         * @param {lens.IContentData} message ContentData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        ContentData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a ContentData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.ContentData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.ContentData} ContentData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.ContentData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.contentType = reader.int32();
                        break;
                    }
                case 2: {
                        message.data = reader.bytes();
                        break;
                    }
                case 3: {
                        message.compressionType = reader.int32();
                        break;
                    }
                case 4: {
                        message.storedChunkOptions = $root.lens.StoredChunkOptions.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a ContentData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.ContentData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.ContentData} ContentData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        ContentData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a ContentData message.
         * @function verify
         * @memberof lens.ContentData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        ContentData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                switch (message.contentType) {
                default:
                    return "contentType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                    break;
                }
            if (message.data != null && message.hasOwnProperty("data"))
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                    return "data: buffer expected";
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                switch (message.compressionType) {
                default:
                    return "compressionType: enum value expected";
                case 0:
                case 1:
                    break;
                }
            if (message.storedChunkOptions != null && message.hasOwnProperty("storedChunkOptions")) {
                var error = $root.lens.StoredChunkOptions.verify(message.storedChunkOptions);
                if (error)
                    return "storedChunkOptions." + error;
            }
            return null;
        };

        /**
         * Creates a ContentData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.ContentData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.ContentData} ContentData
         */
        ContentData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.ContentData)
                return object;
            var message = new $root.lens.ContentData();
            switch (object.contentType) {
            default:
                if (typeof object.contentType === "number") {
                    message.contentType = object.contentType;
                    break;
                }
                break;
            case "CONTENT_TYPE_UNSPECIFIED":
            case 0:
                message.contentType = 0;
                break;
            case "CONTENT_TYPE_PDF":
            case 1:
                message.contentType = 1;
                break;
            case "CONTENT_TYPE_INNER_TEXT":
            case 2:
                message.contentType = 2;
                break;
            case "CONTENT_TYPE_INNER_HTML":
            case 3:
                message.contentType = 3;
                break;
            case "CONTENT_TYPE_ANNOTATED_PAGE_CONTENT":
            case 4:
                message.contentType = 4;
                break;
            case "CONTENT_TYPE_EARLY_PARTIAL_PDF":
            case 5:
                message.contentType = 5;
                break;
            }
            if (object.data != null)
                if (typeof object.data === "string")
                    $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length >= 0)
                    message.data = object.data;
            switch (object.compressionType) {
            default:
                if (typeof object.compressionType === "number") {
                    message.compressionType = object.compressionType;
                    break;
                }
                break;
            case "UNCOMPRESSED":
            case 0:
                message.compressionType = 0;
                break;
            case "ZSTD":
            case 1:
                message.compressionType = 1;
                break;
            }
            if (object.storedChunkOptions != null) {
                if (typeof object.storedChunkOptions !== "object")
                    throw TypeError(".lens.ContentData.storedChunkOptions: object expected");
                message.storedChunkOptions = $root.lens.StoredChunkOptions.fromObject(object.storedChunkOptions);
            }
            return message;
        };

        /**
         * Creates a plain object from a ContentData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.ContentData
         * @static
         * @param {lens.ContentData} message ContentData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        ContentData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.contentType = options.enums === String ? "CONTENT_TYPE_UNSPECIFIED" : 0;
                if (options.bytes === String)
                    object.data = "";
                else {
                    object.data = [];
                    if (options.bytes !== Array)
                        object.data = $util.newBuffer(object.data);
                }
                object.compressionType = options.enums === String ? "UNCOMPRESSED" : 0;
                object.storedChunkOptions = null;
            }
            if (message.contentType != null && message.hasOwnProperty("contentType"))
                object.contentType = options.enums === String ? $root.lens.ContentData.ContentType[message.contentType] === undefined ? message.contentType : $root.lens.ContentData.ContentType[message.contentType] : message.contentType;
            if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            if (message.compressionType != null && message.hasOwnProperty("compressionType"))
                object.compressionType = options.enums === String ? $root.lens.CompressionType[message.compressionType] === undefined ? message.compressionType : $root.lens.CompressionType[message.compressionType] : message.compressionType;
            if (message.storedChunkOptions != null && message.hasOwnProperty("storedChunkOptions"))
                object.storedChunkOptions = $root.lens.StoredChunkOptions.toObject(message.storedChunkOptions, options);
            return object;
        };

        /**
         * Converts this ContentData to JSON.
         * @function toJSON
         * @memberof lens.ContentData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        ContentData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for ContentData
         * @function getTypeUrl
         * @memberof lens.ContentData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        ContentData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.ContentData";
        };

        /**
         * ContentType enum.
         * @name lens.ContentData.ContentType
         * @enum {number}
         * @property {number} CONTENT_TYPE_UNSPECIFIED=0 CONTENT_TYPE_UNSPECIFIED value
         * @property {number} CONTENT_TYPE_PDF=1 CONTENT_TYPE_PDF value
         * @property {number} CONTENT_TYPE_INNER_TEXT=2 CONTENT_TYPE_INNER_TEXT value
         * @property {number} CONTENT_TYPE_INNER_HTML=3 CONTENT_TYPE_INNER_HTML value
         * @property {number} CONTENT_TYPE_ANNOTATED_PAGE_CONTENT=4 CONTENT_TYPE_ANNOTATED_PAGE_CONTENT value
         * @property {number} CONTENT_TYPE_EARLY_PARTIAL_PDF=5 CONTENT_TYPE_EARLY_PARTIAL_PDF value
         */
        ContentData.ContentType = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "CONTENT_TYPE_UNSPECIFIED"] = 0;
            values[valuesById[1] = "CONTENT_TYPE_PDF"] = 1;
            values[valuesById[2] = "CONTENT_TYPE_INNER_TEXT"] = 2;
            values[valuesById[3] = "CONTENT_TYPE_INNER_HTML"] = 3;
            values[valuesById[4] = "CONTENT_TYPE_ANNOTATED_PAGE_CONTENT"] = 4;
            values[valuesById[5] = "CONTENT_TYPE_EARLY_PARTIAL_PDF"] = 5;
            return values;
        })();

        return ContentData;
    })();

    lens.StickinessSignals = (function() {

        /**
         * Properties of a StickinessSignals.
         * @memberof lens
         * @interface IStickinessSignals
         * @property {lens.StickinessSignals.Namespace|null} [idNamespace] StickinessSignals idNamespace
         * @property {lens.IMessageSet|null} [interpretation] StickinessSignals interpretation
         * @property {lens.IEducationInputExtension|null} [educationInputExtension] StickinessSignals educationInputExtension
         */

        /**
         * Constructs a new StickinessSignals.
         * @memberof lens
         * @classdesc Represents a StickinessSignals.
         * @implements IStickinessSignals
         * @constructor
         * @param {lens.IStickinessSignals=} [properties] Properties to set
         */
        function StickinessSignals(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StickinessSignals idNamespace.
         * @member {lens.StickinessSignals.Namespace} idNamespace
         * @memberof lens.StickinessSignals
         * @instance
         */
        StickinessSignals.prototype.idNamespace = 0;

        /**
         * StickinessSignals interpretation.
         * @member {lens.IMessageSet|null|undefined} interpretation
         * @memberof lens.StickinessSignals
         * @instance
         */
        StickinessSignals.prototype.interpretation = null;

        /**
         * StickinessSignals educationInputExtension.
         * @member {lens.IEducationInputExtension|null|undefined} educationInputExtension
         * @memberof lens.StickinessSignals
         * @instance
         */
        StickinessSignals.prototype.educationInputExtension = null;

        /**
         * Creates a new StickinessSignals instance using the specified properties.
         * @function create
         * @memberof lens.StickinessSignals
         * @static
         * @param {lens.IStickinessSignals=} [properties] Properties to set
         * @returns {lens.StickinessSignals} StickinessSignals instance
         */
        StickinessSignals.create = function create(properties) {
            return new StickinessSignals(properties);
        };

        /**
         * Encodes the specified StickinessSignals message. Does not implicitly {@link lens.StickinessSignals.verify|verify} messages.
         * @function encode
         * @memberof lens.StickinessSignals
         * @static
         * @param {lens.IStickinessSignals} message StickinessSignals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickinessSignals.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.idNamespace != null && Object.hasOwnProperty.call(message, "idNamespace"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.idNamespace);
            if (message.interpretation != null && Object.hasOwnProperty.call(message, "interpretation"))
                $root.lens.MessageSet.encode(message.interpretation, writer.uint32(/* id 28, wireType 2 =*/226).fork()).ldelim();
            if (message.educationInputExtension != null && Object.hasOwnProperty.call(message, "educationInputExtension"))
                $root.lens.EducationInputExtension.encode(message.educationInputExtension, writer.uint32(/* id 121, wireType 2 =*/970).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified StickinessSignals message, length delimited. Does not implicitly {@link lens.StickinessSignals.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.StickinessSignals
         * @static
         * @param {lens.IStickinessSignals} message StickinessSignals message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        StickinessSignals.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a StickinessSignals message from the specified reader or buffer.
         * @function decode
         * @memberof lens.StickinessSignals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.StickinessSignals} StickinessSignals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickinessSignals.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.StickinessSignals();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.idNamespace = reader.int32();
                        break;
                    }
                case 28: {
                        message.interpretation = $root.lens.MessageSet.decode(reader, reader.uint32());
                        break;
                    }
                case 121: {
                        message.educationInputExtension = $root.lens.EducationInputExtension.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a StickinessSignals message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.StickinessSignals
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.StickinessSignals} StickinessSignals
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        StickinessSignals.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a StickinessSignals message.
         * @function verify
         * @memberof lens.StickinessSignals
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StickinessSignals.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.idNamespace != null && message.hasOwnProperty("idNamespace"))
                switch (message.idNamespace) {
                default:
                    return "idNamespace: enum value expected";
                case 0:
                case 56:
                case 79:
                    break;
                }
            if (message.interpretation != null && message.hasOwnProperty("interpretation")) {
                var error = $root.lens.MessageSet.verify(message.interpretation);
                if (error)
                    return "interpretation." + error;
            }
            if (message.educationInputExtension != null && message.hasOwnProperty("educationInputExtension")) {
                var error = $root.lens.EducationInputExtension.verify(message.educationInputExtension);
                if (error)
                    return "educationInputExtension." + error;
            }
            return null;
        };

        /**
         * Creates a StickinessSignals message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.StickinessSignals
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.StickinessSignals} StickinessSignals
         */
        StickinessSignals.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.StickinessSignals)
                return object;
            var message = new $root.lens.StickinessSignals();
            switch (object.idNamespace) {
            default:
                if (typeof object.idNamespace === "number") {
                    message.idNamespace = object.idNamespace;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.idNamespace = 0;
                break;
            case "TRANSLATE_LITE":
            case 56:
                message.idNamespace = 56;
                break;
            case "EDUCATION_INPUT":
            case 79:
                message.idNamespace = 79;
                break;
            }
            if (object.interpretation != null) {
                if (typeof object.interpretation !== "object")
                    throw TypeError(".lens.StickinessSignals.interpretation: object expected");
                message.interpretation = $root.lens.MessageSet.fromObject(object.interpretation);
            }
            if (object.educationInputExtension != null) {
                if (typeof object.educationInputExtension !== "object")
                    throw TypeError(".lens.StickinessSignals.educationInputExtension: object expected");
                message.educationInputExtension = $root.lens.EducationInputExtension.fromObject(object.educationInputExtension);
            }
            return message;
        };

        /**
         * Creates a plain object from a StickinessSignals message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.StickinessSignals
         * @static
         * @param {lens.StickinessSignals} message StickinessSignals
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StickinessSignals.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.idNamespace = options.enums === String ? "UNKNOWN" : 0;
                object.interpretation = null;
                object.educationInputExtension = null;
            }
            if (message.idNamespace != null && message.hasOwnProperty("idNamespace"))
                object.idNamespace = options.enums === String ? $root.lens.StickinessSignals.Namespace[message.idNamespace] === undefined ? message.idNamespace : $root.lens.StickinessSignals.Namespace[message.idNamespace] : message.idNamespace;
            if (message.interpretation != null && message.hasOwnProperty("interpretation"))
                object.interpretation = $root.lens.MessageSet.toObject(message.interpretation, options);
            if (message.educationInputExtension != null && message.hasOwnProperty("educationInputExtension"))
                object.educationInputExtension = $root.lens.EducationInputExtension.toObject(message.educationInputExtension, options);
            return object;
        };

        /**
         * Converts this StickinessSignals to JSON.
         * @function toJSON
         * @memberof lens.StickinessSignals
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StickinessSignals.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for StickinessSignals
         * @function getTypeUrl
         * @memberof lens.StickinessSignals
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        StickinessSignals.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.StickinessSignals";
        };

        /**
         * Namespace enum.
         * @name lens.StickinessSignals.Namespace
         * @enum {number}
         * @property {number} UNKNOWN=0 UNKNOWN value
         * @property {number} TRANSLATE_LITE=56 TRANSLATE_LITE value
         * @property {number} EDUCATION_INPUT=79 EDUCATION_INPUT value
         */
        StickinessSignals.Namespace = (function() {
            var valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "UNKNOWN"] = 0;
            values[valuesById[56] = "TRANSLATE_LITE"] = 56;
            values[valuesById[79] = "EDUCATION_INPUT"] = 79;
            return values;
        })();

        return StickinessSignals;
    })();

    lens.EducationInputExtension = (function() {

        /**
         * Properties of an EducationInputExtension.
         * @memberof lens
         * @interface IEducationInputExtension
         * @property {lens.IMathSolverQuery|null} [mathSolverQuery] EducationInputExtension mathSolverQuery
         */

        /**
         * Constructs a new EducationInputExtension.
         * @memberof lens
         * @classdesc Represents an EducationInputExtension.
         * @implements IEducationInputExtension
         * @constructor
         * @param {lens.IEducationInputExtension=} [properties] Properties to set
         */
        function EducationInputExtension(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EducationInputExtension mathSolverQuery.
         * @member {lens.IMathSolverQuery|null|undefined} mathSolverQuery
         * @memberof lens.EducationInputExtension
         * @instance
         */
        EducationInputExtension.prototype.mathSolverQuery = null;

        /**
         * Creates a new EducationInputExtension instance using the specified properties.
         * @function create
         * @memberof lens.EducationInputExtension
         * @static
         * @param {lens.IEducationInputExtension=} [properties] Properties to set
         * @returns {lens.EducationInputExtension} EducationInputExtension instance
         */
        EducationInputExtension.create = function create(properties) {
            return new EducationInputExtension(properties);
        };

        /**
         * Encodes the specified EducationInputExtension message. Does not implicitly {@link lens.EducationInputExtension.verify|verify} messages.
         * @function encode
         * @memberof lens.EducationInputExtension
         * @static
         * @param {lens.IEducationInputExtension} message EducationInputExtension message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EducationInputExtension.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.mathSolverQuery != null && Object.hasOwnProperty.call(message, "mathSolverQuery"))
                $root.lens.MathSolverQuery.encode(message.mathSolverQuery, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified EducationInputExtension message, length delimited. Does not implicitly {@link lens.EducationInputExtension.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.EducationInputExtension
         * @static
         * @param {lens.IEducationInputExtension} message EducationInputExtension message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        EducationInputExtension.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes an EducationInputExtension message from the specified reader or buffer.
         * @function decode
         * @memberof lens.EducationInputExtension
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.EducationInputExtension} EducationInputExtension
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EducationInputExtension.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.EducationInputExtension();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.mathSolverQuery = $root.lens.MathSolverQuery.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes an EducationInputExtension message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.EducationInputExtension
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.EducationInputExtension} EducationInputExtension
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        EducationInputExtension.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies an EducationInputExtension message.
         * @function verify
         * @memberof lens.EducationInputExtension
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EducationInputExtension.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.mathSolverQuery != null && message.hasOwnProperty("mathSolverQuery")) {
                var error = $root.lens.MathSolverQuery.verify(message.mathSolverQuery);
                if (error)
                    return "mathSolverQuery." + error;
            }
            return null;
        };

        /**
         * Creates an EducationInputExtension message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.EducationInputExtension
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.EducationInputExtension} EducationInputExtension
         */
        EducationInputExtension.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.EducationInputExtension)
                return object;
            var message = new $root.lens.EducationInputExtension();
            if (object.mathSolverQuery != null) {
                if (typeof object.mathSolverQuery !== "object")
                    throw TypeError(".lens.EducationInputExtension.mathSolverQuery: object expected");
                message.mathSolverQuery = $root.lens.MathSolverQuery.fromObject(object.mathSolverQuery);
            }
            return message;
        };

        /**
         * Creates a plain object from an EducationInputExtension message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.EducationInputExtension
         * @static
         * @param {lens.EducationInputExtension} message EducationInputExtension
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EducationInputExtension.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.mathSolverQuery = null;
            if (message.mathSolverQuery != null && message.hasOwnProperty("mathSolverQuery"))
                object.mathSolverQuery = $root.lens.MathSolverQuery.toObject(message.mathSolverQuery, options);
            return object;
        };

        /**
         * Converts this EducationInputExtension to JSON.
         * @function toJSON
         * @memberof lens.EducationInputExtension
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EducationInputExtension.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for EducationInputExtension
         * @function getTypeUrl
         * @memberof lens.EducationInputExtension
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        EducationInputExtension.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.EducationInputExtension";
        };

        return EducationInputExtension;
    })();

    lens.LensOverlayVideoContextInputParams = (function() {

        /**
         * Properties of a LensOverlayVideoContextInputParams.
         * @memberof lens
         * @interface ILensOverlayVideoContextInputParams
         * @property {string|null} [url] LensOverlayVideoContextInputParams url
         */

        /**
         * Constructs a new LensOverlayVideoContextInputParams.
         * @memberof lens
         * @classdesc Represents a LensOverlayVideoContextInputParams.
         * @implements ILensOverlayVideoContextInputParams
         * @constructor
         * @param {lens.ILensOverlayVideoContextInputParams=} [properties] Properties to set
         */
        function LensOverlayVideoContextInputParams(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayVideoContextInputParams url.
         * @member {string} url
         * @memberof lens.LensOverlayVideoContextInputParams
         * @instance
         */
        LensOverlayVideoContextInputParams.prototype.url = "";

        /**
         * Creates a new LensOverlayVideoContextInputParams instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {lens.ILensOverlayVideoContextInputParams=} [properties] Properties to set
         * @returns {lens.LensOverlayVideoContextInputParams} LensOverlayVideoContextInputParams instance
         */
        LensOverlayVideoContextInputParams.create = function create(properties) {
            return new LensOverlayVideoContextInputParams(properties);
        };

        /**
         * Encodes the specified LensOverlayVideoContextInputParams message. Does not implicitly {@link lens.LensOverlayVideoContextInputParams.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {lens.ILensOverlayVideoContextInputParams} message LensOverlayVideoContextInputParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVideoContextInputParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                writer.uint32(/* id 1, wireType 2 =*/10).string(message.url);
            return writer;
        };

        /**
         * Encodes the specified LensOverlayVideoContextInputParams message, length delimited. Does not implicitly {@link lens.LensOverlayVideoContextInputParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {lens.ILensOverlayVideoContextInputParams} message LensOverlayVideoContextInputParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVideoContextInputParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayVideoContextInputParams message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayVideoContextInputParams} LensOverlayVideoContextInputParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVideoContextInputParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayVideoContextInputParams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.url = reader.string();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayVideoContextInputParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayVideoContextInputParams} LensOverlayVideoContextInputParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVideoContextInputParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayVideoContextInputParams message.
         * @function verify
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayVideoContextInputParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.url != null && message.hasOwnProperty("url"))
                if (!$util.isString(message.url))
                    return "url: string expected";
            return null;
        };

        /**
         * Creates a LensOverlayVideoContextInputParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayVideoContextInputParams} LensOverlayVideoContextInputParams
         */
        LensOverlayVideoContextInputParams.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayVideoContextInputParams)
                return object;
            var message = new $root.lens.LensOverlayVideoContextInputParams();
            if (object.url != null)
                message.url = String(object.url);
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayVideoContextInputParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {lens.LensOverlayVideoContextInputParams} message LensOverlayVideoContextInputParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayVideoContextInputParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.url = "";
            if (message.url != null && message.hasOwnProperty("url"))
                object.url = message.url;
            return object;
        };

        /**
         * Converts this LensOverlayVideoContextInputParams to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayVideoContextInputParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayVideoContextInputParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayVideoContextInputParams
         * @function getTypeUrl
         * @memberof lens.LensOverlayVideoContextInputParams
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayVideoContextInputParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayVideoContextInputParams";
        };

        return LensOverlayVideoContextInputParams;
    })();

    lens.LensOverlayVideoParams = (function() {

        /**
         * Properties of a LensOverlayVideoParams.
         * @memberof lens
         * @interface ILensOverlayVideoParams
         * @property {lens.ILensOverlayVideoContextInputParams|null} [videoContextInputParams] LensOverlayVideoParams videoContextInputParams
         */

        /**
         * Constructs a new LensOverlayVideoParams.
         * @memberof lens
         * @classdesc Represents a LensOverlayVideoParams.
         * @implements ILensOverlayVideoParams
         * @constructor
         * @param {lens.ILensOverlayVideoParams=} [properties] Properties to set
         */
        function LensOverlayVideoParams(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayVideoParams videoContextInputParams.
         * @member {lens.ILensOverlayVideoContextInputParams|null|undefined} videoContextInputParams
         * @memberof lens.LensOverlayVideoParams
         * @instance
         */
        LensOverlayVideoParams.prototype.videoContextInputParams = null;

        /**
         * Creates a new LensOverlayVideoParams instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {lens.ILensOverlayVideoParams=} [properties] Properties to set
         * @returns {lens.LensOverlayVideoParams} LensOverlayVideoParams instance
         */
        LensOverlayVideoParams.create = function create(properties) {
            return new LensOverlayVideoParams(properties);
        };

        /**
         * Encodes the specified LensOverlayVideoParams message. Does not implicitly {@link lens.LensOverlayVideoParams.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {lens.ILensOverlayVideoParams} message LensOverlayVideoParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVideoParams.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.videoContextInputParams != null && Object.hasOwnProperty.call(message, "videoContextInputParams"))
                $root.lens.LensOverlayVideoContextInputParams.encode(message.videoContextInputParams, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayVideoParams message, length delimited. Does not implicitly {@link lens.LensOverlayVideoParams.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {lens.ILensOverlayVideoParams} message LensOverlayVideoParams message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVideoParams.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayVideoParams message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayVideoParams} LensOverlayVideoParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVideoParams.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayVideoParams();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.videoContextInputParams = $root.lens.LensOverlayVideoContextInputParams.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayVideoParams message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayVideoParams} LensOverlayVideoParams
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVideoParams.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayVideoParams message.
         * @function verify
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayVideoParams.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.videoContextInputParams != null && message.hasOwnProperty("videoContextInputParams")) {
                var error = $root.lens.LensOverlayVideoContextInputParams.verify(message.videoContextInputParams);
                if (error)
                    return "videoContextInputParams." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayVideoParams message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayVideoParams} LensOverlayVideoParams
         */
        LensOverlayVideoParams.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayVideoParams)
                return object;
            var message = new $root.lens.LensOverlayVideoParams();
            if (object.videoContextInputParams != null) {
                if (typeof object.videoContextInputParams !== "object")
                    throw TypeError(".lens.LensOverlayVideoParams.videoContextInputParams: object expected");
                message.videoContextInputParams = $root.lens.LensOverlayVideoContextInputParams.fromObject(object.videoContextInputParams);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayVideoParams message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {lens.LensOverlayVideoParams} message LensOverlayVideoParams
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayVideoParams.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.videoContextInputParams = null;
            if (message.videoContextInputParams != null && message.hasOwnProperty("videoContextInputParams"))
                object.videoContextInputParams = $root.lens.LensOverlayVideoContextInputParams.toObject(message.videoContextInputParams, options);
            return object;
        };

        /**
         * Converts this LensOverlayVideoParams to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayVideoParams
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayVideoParams.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayVideoParams
         * @function getTypeUrl
         * @memberof lens.LensOverlayVideoParams
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayVideoParams.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayVideoParams";
        };

        return LensOverlayVideoParams;
    })();

    lens.LensOverlayVisualSearchInteractionData = (function() {

        /**
         * Properties of a LensOverlayVisualSearchInteractionData.
         * @memberof lens
         * @interface ILensOverlayVisualSearchInteractionData
         * @property {lens.LensOverlayInteractionRequestMetadata.Type|null} [interactionType] LensOverlayVisualSearchInteractionData interactionType
         * @property {lens.IZoomedCrop|null} [zoomedCrop] LensOverlayVisualSearchInteractionData zoomedCrop
         * @property {string|null} [objectId] LensOverlayVisualSearchInteractionData objectId
         * @property {lens.ILensOverlayVisualSearchInteractionLogData|null} [logData] LensOverlayVisualSearchInteractionData logData
         */

        /**
         * Constructs a new LensOverlayVisualSearchInteractionData.
         * @memberof lens
         * @classdesc Represents a LensOverlayVisualSearchInteractionData.
         * @implements ILensOverlayVisualSearchInteractionData
         * @constructor
         * @param {lens.ILensOverlayVisualSearchInteractionData=} [properties] Properties to set
         */
        function LensOverlayVisualSearchInteractionData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayVisualSearchInteractionData interactionType.
         * @member {lens.LensOverlayInteractionRequestMetadata.Type} interactionType
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @instance
         */
        LensOverlayVisualSearchInteractionData.prototype.interactionType = 0;

        /**
         * LensOverlayVisualSearchInteractionData zoomedCrop.
         * @member {lens.IZoomedCrop|null|undefined} zoomedCrop
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @instance
         */
        LensOverlayVisualSearchInteractionData.prototype.zoomedCrop = null;

        /**
         * LensOverlayVisualSearchInteractionData objectId.
         * @member {string} objectId
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @instance
         */
        LensOverlayVisualSearchInteractionData.prototype.objectId = "";

        /**
         * LensOverlayVisualSearchInteractionData logData.
         * @member {lens.ILensOverlayVisualSearchInteractionLogData|null|undefined} logData
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @instance
         */
        LensOverlayVisualSearchInteractionData.prototype.logData = null;

        /**
         * Creates a new LensOverlayVisualSearchInteractionData instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {lens.ILensOverlayVisualSearchInteractionData=} [properties] Properties to set
         * @returns {lens.LensOverlayVisualSearchInteractionData} LensOverlayVisualSearchInteractionData instance
         */
        LensOverlayVisualSearchInteractionData.create = function create(properties) {
            return new LensOverlayVisualSearchInteractionData(properties);
        };

        /**
         * Encodes the specified LensOverlayVisualSearchInteractionData message. Does not implicitly {@link lens.LensOverlayVisualSearchInteractionData.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {lens.ILensOverlayVisualSearchInteractionData} message LensOverlayVisualSearchInteractionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVisualSearchInteractionData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.interactionType != null && Object.hasOwnProperty.call(message, "interactionType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.interactionType);
            if (message.objectId != null && Object.hasOwnProperty.call(message, "objectId"))
                writer.uint32(/* id 3, wireType 2 =*/26).string(message.objectId);
            if (message.logData != null && Object.hasOwnProperty.call(message, "logData"))
                $root.lens.LensOverlayVisualSearchInteractionLogData.encode(message.logData, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
            if (message.zoomedCrop != null && Object.hasOwnProperty.call(message, "zoomedCrop"))
                $root.lens.ZoomedCrop.encode(message.zoomedCrop, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
            return writer;
        };

        /**
         * Encodes the specified LensOverlayVisualSearchInteractionData message, length delimited. Does not implicitly {@link lens.LensOverlayVisualSearchInteractionData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {lens.ILensOverlayVisualSearchInteractionData} message LensOverlayVisualSearchInteractionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVisualSearchInteractionData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayVisualSearchInteractionData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayVisualSearchInteractionData} LensOverlayVisualSearchInteractionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVisualSearchInteractionData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayVisualSearchInteractionData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.interactionType = reader.int32();
                        break;
                    }
                case 7: {
                        message.zoomedCrop = $root.lens.ZoomedCrop.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.objectId = reader.string();
                        break;
                    }
                case 5: {
                        message.logData = $root.lens.LensOverlayVisualSearchInteractionLogData.decode(reader, reader.uint32());
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayVisualSearchInteractionData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayVisualSearchInteractionData} LensOverlayVisualSearchInteractionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVisualSearchInteractionData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayVisualSearchInteractionData message.
         * @function verify
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayVisualSearchInteractionData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.interactionType != null && message.hasOwnProperty("interactionType"))
                switch (message.interactionType) {
                default:
                    return "interactionType: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 9:
                case 10:
                case 11:
                    break;
                }
            if (message.zoomedCrop != null && message.hasOwnProperty("zoomedCrop")) {
                var error = $root.lens.ZoomedCrop.verify(message.zoomedCrop);
                if (error)
                    return "zoomedCrop." + error;
            }
            if (message.objectId != null && message.hasOwnProperty("objectId"))
                if (!$util.isString(message.objectId))
                    return "objectId: string expected";
            if (message.logData != null && message.hasOwnProperty("logData")) {
                var error = $root.lens.LensOverlayVisualSearchInteractionLogData.verify(message.logData);
                if (error)
                    return "logData." + error;
            }
            return null;
        };

        /**
         * Creates a LensOverlayVisualSearchInteractionData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayVisualSearchInteractionData} LensOverlayVisualSearchInteractionData
         */
        LensOverlayVisualSearchInteractionData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayVisualSearchInteractionData)
                return object;
            var message = new $root.lens.LensOverlayVisualSearchInteractionData();
            switch (object.interactionType) {
            default:
                if (typeof object.interactionType === "number") {
                    message.interactionType = object.interactionType;
                    break;
                }
                break;
            case "UNKNOWN":
            case 0:
                message.interactionType = 0;
                break;
            case "TAP":
            case 1:
                message.interactionType = 1;
                break;
            case "REGION":
            case 2:
                message.interactionType = 2;
                break;
            case "TEXT_SELECTION":
            case 3:
                message.interactionType = 3;
                break;
            case "REGION_SEARCH":
            case 4:
                message.interactionType = 4;
                break;
            case "OBJECT_FULFILLMENT":
            case 5:
                message.interactionType = 5;
                break;
            case "CONTEXTUAL_SEARCH_QUERY":
            case 9:
                message.interactionType = 9;
                break;
            case "PDF_QUERY":
            case 10:
                message.interactionType = 10;
                break;
            case "WEBPAGE_QUERY":
            case 11:
                message.interactionType = 11;
                break;
            }
            if (object.zoomedCrop != null) {
                if (typeof object.zoomedCrop !== "object")
                    throw TypeError(".lens.LensOverlayVisualSearchInteractionData.zoomedCrop: object expected");
                message.zoomedCrop = $root.lens.ZoomedCrop.fromObject(object.zoomedCrop);
            }
            if (object.objectId != null)
                message.objectId = String(object.objectId);
            if (object.logData != null) {
                if (typeof object.logData !== "object")
                    throw TypeError(".lens.LensOverlayVisualSearchInteractionData.logData: object expected");
                message.logData = $root.lens.LensOverlayVisualSearchInteractionLogData.fromObject(object.logData);
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayVisualSearchInteractionData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {lens.LensOverlayVisualSearchInteractionData} message LensOverlayVisualSearchInteractionData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayVisualSearchInteractionData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.interactionType = options.enums === String ? "UNKNOWN" : 0;
                object.objectId = "";
                object.logData = null;
                object.zoomedCrop = null;
            }
            if (message.interactionType != null && message.hasOwnProperty("interactionType"))
                object.interactionType = options.enums === String ? $root.lens.LensOverlayInteractionRequestMetadata.Type[message.interactionType] === undefined ? message.interactionType : $root.lens.LensOverlayInteractionRequestMetadata.Type[message.interactionType] : message.interactionType;
            if (message.objectId != null && message.hasOwnProperty("objectId"))
                object.objectId = message.objectId;
            if (message.logData != null && message.hasOwnProperty("logData"))
                object.logData = $root.lens.LensOverlayVisualSearchInteractionLogData.toObject(message.logData, options);
            if (message.zoomedCrop != null && message.hasOwnProperty("zoomedCrop"))
                object.zoomedCrop = $root.lens.ZoomedCrop.toObject(message.zoomedCrop, options);
            return object;
        };

        /**
         * Converts this LensOverlayVisualSearchInteractionData to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayVisualSearchInteractionData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayVisualSearchInteractionData
         * @function getTypeUrl
         * @memberof lens.LensOverlayVisualSearchInteractionData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayVisualSearchInteractionData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayVisualSearchInteractionData";
        };

        return LensOverlayVisualSearchInteractionData;
    })();

    lens.LensOverlayVisualSearchInteractionLogData = (function() {

        /**
         * Properties of a LensOverlayVisualSearchInteractionLogData.
         * @memberof lens
         * @interface ILensOverlayVisualSearchInteractionLogData
         * @property {lens.IFilterData|null} [filterData] LensOverlayVisualSearchInteractionLogData filterData
         * @property {lens.IUserSelectionData|null} [userSelectionData] LensOverlayVisualSearchInteractionLogData userSelectionData
         * @property {boolean|null} [isParentQuery] LensOverlayVisualSearchInteractionLogData isParentQuery
         * @property {lens.ClientPlatform|null} [clientPlatform] LensOverlayVisualSearchInteractionLogData clientPlatform
         */

        /**
         * Constructs a new LensOverlayVisualSearchInteractionLogData.
         * @memberof lens
         * @classdesc Represents a LensOverlayVisualSearchInteractionLogData.
         * @implements ILensOverlayVisualSearchInteractionLogData
         * @constructor
         * @param {lens.ILensOverlayVisualSearchInteractionLogData=} [properties] Properties to set
         */
        function LensOverlayVisualSearchInteractionLogData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * LensOverlayVisualSearchInteractionLogData filterData.
         * @member {lens.IFilterData|null|undefined} filterData
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @instance
         */
        LensOverlayVisualSearchInteractionLogData.prototype.filterData = null;

        /**
         * LensOverlayVisualSearchInteractionLogData userSelectionData.
         * @member {lens.IUserSelectionData|null|undefined} userSelectionData
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @instance
         */
        LensOverlayVisualSearchInteractionLogData.prototype.userSelectionData = null;

        /**
         * LensOverlayVisualSearchInteractionLogData isParentQuery.
         * @member {boolean} isParentQuery
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @instance
         */
        LensOverlayVisualSearchInteractionLogData.prototype.isParentQuery = false;

        /**
         * LensOverlayVisualSearchInteractionLogData clientPlatform.
         * @member {lens.ClientPlatform} clientPlatform
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @instance
         */
        LensOverlayVisualSearchInteractionLogData.prototype.clientPlatform = 0;

        /**
         * Creates a new LensOverlayVisualSearchInteractionLogData instance using the specified properties.
         * @function create
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {lens.ILensOverlayVisualSearchInteractionLogData=} [properties] Properties to set
         * @returns {lens.LensOverlayVisualSearchInteractionLogData} LensOverlayVisualSearchInteractionLogData instance
         */
        LensOverlayVisualSearchInteractionLogData.create = function create(properties) {
            return new LensOverlayVisualSearchInteractionLogData(properties);
        };

        /**
         * Encodes the specified LensOverlayVisualSearchInteractionLogData message. Does not implicitly {@link lens.LensOverlayVisualSearchInteractionLogData.verify|verify} messages.
         * @function encode
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {lens.ILensOverlayVisualSearchInteractionLogData} message LensOverlayVisualSearchInteractionLogData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVisualSearchInteractionLogData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filterData != null && Object.hasOwnProperty.call(message, "filterData"))
                $root.lens.FilterData.encode(message.filterData, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
            if (message.userSelectionData != null && Object.hasOwnProperty.call(message, "userSelectionData"))
                $root.lens.UserSelectionData.encode(message.userSelectionData, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
            if (message.isParentQuery != null && Object.hasOwnProperty.call(message, "isParentQuery"))
                writer.uint32(/* id 3, wireType 0 =*/24).bool(message.isParentQuery);
            if (message.clientPlatform != null && Object.hasOwnProperty.call(message, "clientPlatform"))
                writer.uint32(/* id 4, wireType 0 =*/32).int32(message.clientPlatform);
            return writer;
        };

        /**
         * Encodes the specified LensOverlayVisualSearchInteractionLogData message, length delimited. Does not implicitly {@link lens.LensOverlayVisualSearchInteractionLogData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {lens.ILensOverlayVisualSearchInteractionLogData} message LensOverlayVisualSearchInteractionLogData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        LensOverlayVisualSearchInteractionLogData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a LensOverlayVisualSearchInteractionLogData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.LensOverlayVisualSearchInteractionLogData} LensOverlayVisualSearchInteractionLogData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVisualSearchInteractionLogData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.LensOverlayVisualSearchInteractionLogData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.filterData = $root.lens.FilterData.decode(reader, reader.uint32());
                        break;
                    }
                case 2: {
                        message.userSelectionData = $root.lens.UserSelectionData.decode(reader, reader.uint32());
                        break;
                    }
                case 3: {
                        message.isParentQuery = reader.bool();
                        break;
                    }
                case 4: {
                        message.clientPlatform = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a LensOverlayVisualSearchInteractionLogData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.LensOverlayVisualSearchInteractionLogData} LensOverlayVisualSearchInteractionLogData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        LensOverlayVisualSearchInteractionLogData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a LensOverlayVisualSearchInteractionLogData message.
         * @function verify
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        LensOverlayVisualSearchInteractionLogData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filterData != null && message.hasOwnProperty("filterData")) {
                var error = $root.lens.FilterData.verify(message.filterData);
                if (error)
                    return "filterData." + error;
            }
            if (message.userSelectionData != null && message.hasOwnProperty("userSelectionData")) {
                var error = $root.lens.UserSelectionData.verify(message.userSelectionData);
                if (error)
                    return "userSelectionData." + error;
            }
            if (message.isParentQuery != null && message.hasOwnProperty("isParentQuery"))
                if (typeof message.isParentQuery !== "boolean")
                    return "isParentQuery: boolean expected";
            if (message.clientPlatform != null && message.hasOwnProperty("clientPlatform"))
                switch (message.clientPlatform) {
                default:
                    return "clientPlatform: enum value expected";
                case 0:
                case 2:
                    break;
                }
            return null;
        };

        /**
         * Creates a LensOverlayVisualSearchInteractionLogData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.LensOverlayVisualSearchInteractionLogData} LensOverlayVisualSearchInteractionLogData
         */
        LensOverlayVisualSearchInteractionLogData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.LensOverlayVisualSearchInteractionLogData)
                return object;
            var message = new $root.lens.LensOverlayVisualSearchInteractionLogData();
            if (object.filterData != null) {
                if (typeof object.filterData !== "object")
                    throw TypeError(".lens.LensOverlayVisualSearchInteractionLogData.filterData: object expected");
                message.filterData = $root.lens.FilterData.fromObject(object.filterData);
            }
            if (object.userSelectionData != null) {
                if (typeof object.userSelectionData !== "object")
                    throw TypeError(".lens.LensOverlayVisualSearchInteractionLogData.userSelectionData: object expected");
                message.userSelectionData = $root.lens.UserSelectionData.fromObject(object.userSelectionData);
            }
            if (object.isParentQuery != null)
                message.isParentQuery = Boolean(object.isParentQuery);
            switch (object.clientPlatform) {
            default:
                if (typeof object.clientPlatform === "number") {
                    message.clientPlatform = object.clientPlatform;
                    break;
                }
                break;
            case "CLIENT_PLATFORM_UNSPECIFIED":
            case 0:
                message.clientPlatform = 0;
                break;
            case "CLIENT_PLATFORM_LENS_OVERLAY":
            case 2:
                message.clientPlatform = 2;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a LensOverlayVisualSearchInteractionLogData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {lens.LensOverlayVisualSearchInteractionLogData} message LensOverlayVisualSearchInteractionLogData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        LensOverlayVisualSearchInteractionLogData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults) {
                object.filterData = null;
                object.userSelectionData = null;
                object.isParentQuery = false;
                object.clientPlatform = options.enums === String ? "CLIENT_PLATFORM_UNSPECIFIED" : 0;
            }
            if (message.filterData != null && message.hasOwnProperty("filterData"))
                object.filterData = $root.lens.FilterData.toObject(message.filterData, options);
            if (message.userSelectionData != null && message.hasOwnProperty("userSelectionData"))
                object.userSelectionData = $root.lens.UserSelectionData.toObject(message.userSelectionData, options);
            if (message.isParentQuery != null && message.hasOwnProperty("isParentQuery"))
                object.isParentQuery = message.isParentQuery;
            if (message.clientPlatform != null && message.hasOwnProperty("clientPlatform"))
                object.clientPlatform = options.enums === String ? $root.lens.ClientPlatform[message.clientPlatform] === undefined ? message.clientPlatform : $root.lens.ClientPlatform[message.clientPlatform] : message.clientPlatform;
            return object;
        };

        /**
         * Converts this LensOverlayVisualSearchInteractionLogData to JSON.
         * @function toJSON
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        LensOverlayVisualSearchInteractionLogData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for LensOverlayVisualSearchInteractionLogData
         * @function getTypeUrl
         * @memberof lens.LensOverlayVisualSearchInteractionLogData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        LensOverlayVisualSearchInteractionLogData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.LensOverlayVisualSearchInteractionLogData";
        };

        return LensOverlayVisualSearchInteractionLogData;
    })();

    lens.FilterData = (function() {

        /**
         * Properties of a FilterData.
         * @memberof lens
         * @interface IFilterData
         * @property {lens.LensOverlayFilterType|null} [filterType] FilterData filterType
         */

        /**
         * Constructs a new FilterData.
         * @memberof lens
         * @classdesc Represents a FilterData.
         * @implements IFilterData
         * @constructor
         * @param {lens.IFilterData=} [properties] Properties to set
         */
        function FilterData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FilterData filterType.
         * @member {lens.LensOverlayFilterType} filterType
         * @memberof lens.FilterData
         * @instance
         */
        FilterData.prototype.filterType = 0;

        /**
         * Creates a new FilterData instance using the specified properties.
         * @function create
         * @memberof lens.FilterData
         * @static
         * @param {lens.IFilterData=} [properties] Properties to set
         * @returns {lens.FilterData} FilterData instance
         */
        FilterData.create = function create(properties) {
            return new FilterData(properties);
        };

        /**
         * Encodes the specified FilterData message. Does not implicitly {@link lens.FilterData.verify|verify} messages.
         * @function encode
         * @memberof lens.FilterData
         * @static
         * @param {lens.IFilterData} message FilterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilterData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.filterType != null && Object.hasOwnProperty.call(message, "filterType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.filterType);
            return writer;
        };

        /**
         * Encodes the specified FilterData message, length delimited. Does not implicitly {@link lens.FilterData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.FilterData
         * @static
         * @param {lens.IFilterData} message FilterData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        FilterData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a FilterData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.FilterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.FilterData} FilterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilterData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.FilterData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.filterType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a FilterData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.FilterData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.FilterData} FilterData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        FilterData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a FilterData message.
         * @function verify
         * @memberof lens.FilterData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FilterData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.filterType != null && message.hasOwnProperty("filterType"))
                switch (message.filterType) {
                default:
                    return "filterType: enum value expected";
                case 0:
                case 2:
                case 7:
                    break;
                }
            return null;
        };

        /**
         * Creates a FilterData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.FilterData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.FilterData} FilterData
         */
        FilterData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.FilterData)
                return object;
            var message = new $root.lens.FilterData();
            switch (object.filterType) {
            default:
                if (typeof object.filterType === "number") {
                    message.filterType = object.filterType;
                    break;
                }
                break;
            case "UNKNOWN_FILTER_TYPE":
            case 0:
                message.filterType = 0;
                break;
            case "TRANSLATE":
            case 2:
                message.filterType = 2;
                break;
            case "AUTO_FILTER":
            case 7:
                message.filterType = 7;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a FilterData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.FilterData
         * @static
         * @param {lens.FilterData} message FilterData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FilterData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.filterType = options.enums === String ? "UNKNOWN_FILTER_TYPE" : 0;
            if (message.filterType != null && message.hasOwnProperty("filterType"))
                object.filterType = options.enums === String ? $root.lens.LensOverlayFilterType[message.filterType] === undefined ? message.filterType : $root.lens.LensOverlayFilterType[message.filterType] : message.filterType;
            return object;
        };

        /**
         * Converts this FilterData to JSON.
         * @function toJSON
         * @memberof lens.FilterData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FilterData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for FilterData
         * @function getTypeUrl
         * @memberof lens.FilterData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        FilterData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.FilterData";
        };

        return FilterData;
    })();

    lens.UserSelectionData = (function() {

        /**
         * Properties of a UserSelectionData.
         * @memberof lens
         * @interface IUserSelectionData
         * @property {lens.LensOverlaySelectionType|null} [selectionType] UserSelectionData selectionType
         */

        /**
         * Constructs a new UserSelectionData.
         * @memberof lens
         * @classdesc Represents a UserSelectionData.
         * @implements IUserSelectionData
         * @constructor
         * @param {lens.IUserSelectionData=} [properties] Properties to set
         */
        function UserSelectionData(properties) {
            if (properties)
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UserSelectionData selectionType.
         * @member {lens.LensOverlaySelectionType} selectionType
         * @memberof lens.UserSelectionData
         * @instance
         */
        UserSelectionData.prototype.selectionType = 0;

        /**
         * Creates a new UserSelectionData instance using the specified properties.
         * @function create
         * @memberof lens.UserSelectionData
         * @static
         * @param {lens.IUserSelectionData=} [properties] Properties to set
         * @returns {lens.UserSelectionData} UserSelectionData instance
         */
        UserSelectionData.create = function create(properties) {
            return new UserSelectionData(properties);
        };

        /**
         * Encodes the specified UserSelectionData message. Does not implicitly {@link lens.UserSelectionData.verify|verify} messages.
         * @function encode
         * @memberof lens.UserSelectionData
         * @static
         * @param {lens.IUserSelectionData} message UserSelectionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSelectionData.encode = function encode(message, writer) {
            if (!writer)
                writer = $Writer.create();
            if (message.selectionType != null && Object.hasOwnProperty.call(message, "selectionType"))
                writer.uint32(/* id 1, wireType 0 =*/8).int32(message.selectionType);
            return writer;
        };

        /**
         * Encodes the specified UserSelectionData message, length delimited. Does not implicitly {@link lens.UserSelectionData.verify|verify} messages.
         * @function encodeDelimited
         * @memberof lens.UserSelectionData
         * @static
         * @param {lens.IUserSelectionData} message UserSelectionData message or plain object to encode
         * @param {$protobuf.Writer} [writer] Writer to encode to
         * @returns {$protobuf.Writer} Writer
         */
        UserSelectionData.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
        };

        /**
         * Decodes a UserSelectionData message from the specified reader or buffer.
         * @function decode
         * @memberof lens.UserSelectionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @param {number} [length] Message length if known beforehand
         * @returns {lens.UserSelectionData} UserSelectionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSelectionData.decode = function decode(reader, length) {
            if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
            var end = length === undefined ? reader.len : reader.pos + length, message = new $root.lens.UserSelectionData();
            while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                case 1: {
                        message.selectionType = reader.int32();
                        break;
                    }
                default:
                    reader.skipType(tag & 7);
                    break;
                }
            }
            return message;
        };

        /**
         * Decodes a UserSelectionData message from the specified reader or buffer, length delimited.
         * @function decodeDelimited
         * @memberof lens.UserSelectionData
         * @static
         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
         * @returns {lens.UserSelectionData} UserSelectionData
         * @throws {Error} If the payload is not a reader or valid buffer
         * @throws {$protobuf.util.ProtocolError} If required fields are missing
         */
        UserSelectionData.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
            return this.decode(reader, reader.uint32());
        };

        /**
         * Verifies a UserSelectionData message.
         * @function verify
         * @memberof lens.UserSelectionData
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UserSelectionData.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.selectionType != null && message.hasOwnProperty("selectionType"))
                switch (message.selectionType) {
                default:
                    return "selectionType: enum value expected";
                case 0:
                case 1:
                case 3:
                case 7:
                case 10:
                case 15:
                case 18:
                case 21:
                case 22:
                case 25:
                case 26:
                case 52:
                case 53:
                    break;
                }
            return null;
        };

        /**
         * Creates a UserSelectionData message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof lens.UserSelectionData
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {lens.UserSelectionData} UserSelectionData
         */
        UserSelectionData.fromObject = function fromObject(object) {
            if (object instanceof $root.lens.UserSelectionData)
                return object;
            var message = new $root.lens.UserSelectionData();
            switch (object.selectionType) {
            default:
                if (typeof object.selectionType === "number") {
                    message.selectionType = object.selectionType;
                    break;
                }
                break;
            case "UNKNOWN_SELECTION_TYPE":
            case 0:
                message.selectionType = 0;
                break;
            case "TAP_ON_EMPTY":
            case 1:
                message.selectionType = 1;
                break;
            case "SELECT_TEXT_HIGHLIGHT":
            case 3:
                message.selectionType = 3;
                break;
            case "REGION_SEARCH":
            case 7:
                message.selectionType = 7;
                break;
            case "INJECTED_IMAGE":
            case 10:
                message.selectionType = 10;
                break;
            case "TAP_ON_REGION_GLEAM":
            case 15:
                message.selectionType = 15;
                break;
            case "MULTIMODAL_SEARCH":
            case 18:
                message.selectionType = 18;
                break;
            case "SELECT_TRANSLATED_TEXT":
            case 21:
                message.selectionType = 21;
                break;
            case "TAP_ON_OBJECT":
            case 22:
                message.selectionType = 22;
                break;
            case "MULTIMODAL_SUGGEST_TYPEAHEAD":
            case 25:
                message.selectionType = 25;
                break;
            case "MULTIMODAL_SUGGEST_ZERO_PREFIX":
            case 26:
                message.selectionType = 26;
                break;
            case "TRANSLATE_CHIP":
            case 52:
                message.selectionType = 52;
                break;
            case "SYMBOLIC_MATH_OBJECT":
            case 53:
                message.selectionType = 53;
                break;
            }
            return message;
        };

        /**
         * Creates a plain object from a UserSelectionData message. Also converts values to other types if specified.
         * @function toObject
         * @memberof lens.UserSelectionData
         * @static
         * @param {lens.UserSelectionData} message UserSelectionData
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UserSelectionData.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            var object = {};
            if (options.defaults)
                object.selectionType = options.enums === String ? "UNKNOWN_SELECTION_TYPE" : 0;
            if (message.selectionType != null && message.hasOwnProperty("selectionType"))
                object.selectionType = options.enums === String ? $root.lens.LensOverlaySelectionType[message.selectionType] === undefined ? message.selectionType : $root.lens.LensOverlaySelectionType[message.selectionType] : message.selectionType;
            return object;
        };

        /**
         * Converts this UserSelectionData to JSON.
         * @function toJSON
         * @memberof lens.UserSelectionData
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UserSelectionData.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        /**
         * Gets the default type url for UserSelectionData
         * @function getTypeUrl
         * @memberof lens.UserSelectionData
         * @static
         * @param {string} [typeUrlPrefix] your custom typeUrlPrefix(default "type.googleapis.com")
         * @returns {string} The default type url
         */
        UserSelectionData.getTypeUrl = function getTypeUrl(typeUrlPrefix) {
            if (typeUrlPrefix === undefined) {
                typeUrlPrefix = "type.googleapis.com";
            }
            return typeUrlPrefix + "/lens.UserSelectionData";
        };

        return UserSelectionData;
    })();

    return lens;
})();

module.exports = $root;
